#!/bin/sh
# Copyright (c) 2011 WorkWare Systems http://www.workware.net.au/
# All rights reserved
# vim:se syntax=tcl:
# \
dir=`dirname "$0"`; exec "`$dir/find-tclsh`" "$0" "$@"

# ==================================================================
# Initialiation
# ==================================================================

set tmake(version) 0.1
set tmake(debug) 0
#  d = dynamic dependency
#  D = ignored dynamic dependency 
#  b = reasons for building
#  n = reasons for not building
#  r = show rule for target being considered (combines with -db, -dn)
#  t = target rule creation/update
#  c = configuration checking
#  C = cache
#  g = graph dependencies executed
#  p = show high level rules as they are parsed
#  m = miscellaneous debug
set tmake(debugtypes) {d 0 n 0 r 0 b 0 t 0 c 0 g 0 p 0 m 0 D 0 C 0}
set tmake(verbose) 0
set tmake(norun) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(exitcode) 0
set tmake(modules) {}
set tmake(autosubdirs) 1
set tmake(cache) {}
set tmake(cmdcache) {}
set tmake(writecache) 0
set tmake(deferred) {}
set tmake(projfiles) {}
set tmake(fixedvars) {}

# Should these really be here?
set tmake(headerscancache) {}
set tmake(testruncount) 0
set tmake(testpasscount) 0

set tmake(current) {}
set tmake(rules) {}
set tmake(targets) {}
set tmake(numtargets) 0
set tmake(subdirvars) {}
set tmake(subdirs) {}
set tmake(prefix) ""
set tmake(localmakefile) Makefile

# ==================================================================
# Argument Processing
# ==================================================================

proc make {argv} {
	global tmake
	#puts "make $argv"
	#parray ::env

	# 'compat' is needed before we can do anything, so set a temporary libdir
	set tmake(libdir) [file dirname $::argv0]/lib

	use compat

	set tmake(exe) [file-normalize $::argv0]
	set tmake(dir) [file dirname $tmake(exe)]
	set tmake(libdir) $tmake(dir)/lib
	set tmake(start) [clock-millis]

	use getopt config

	# Parse the user options
	set targets {}
	foreach a $argv {
		if {[regexp {^(\w[^=]*)=(.*)} $a -> n v]} {
			if {$n eq "V"} {
				set tmake(verbose) $v
			} elseif {$n eq "D"} {
				set tmake(debug) $v
			} elseif {$n eq "P"} {
				set tmake(showrules) 1
			} elseif {$n eq "N"} {
				incr tmake(norun)
			} elseif {$n eq "T"} {
				incr tmake(showtime)
			} elseif {$n eq "Q"} {
				incr tmake(quickstop)
			} else {
				dputs m "define $n $v"
				define! $n $v
			}
		} elseif {[string match -* $a]} {
			if {$a eq "-d*"} {
				foreach i [dict keys $tmake(debugtypes)] {
					dict set tmake(debugtypes) $i 1
				}
				continue
			}
			switch -glob -- $a {
				--find=* {
					regexp {^--find=(.*)} $a -> tmake(findtarget)
				}
				-d* {
					foreach i [split [string range $a 2 end] {}] {
						dict-incr tmake(debugtypes) $i 1
					}
					set tmake(debug) 1
				}
				--debug {
					# Equivalent to -dg
					set tmake(debug) 1
					dict-incr tmake(debugtypes) g 1
				}
				--verbose - -v {
					set tmake(verbose) 1
				}
				--version {
					use help
					puts [show-version]
					exit 0
				}
				--help - -h {
					use help
					show-help $argv
					exit 0
				}
				--dry-run - --just-print - -n {
					set tmake(norun) 1
				}
				-N {
					set tmake(norun) 2
				}
				--tim* - -t {
					incr tmake(showtime)
				}
				-q - --quickstop {
					incr tmake(quickstop)
				}
				-p - --print* {
					incr tmake(showrules)
				}
				-C* {
					# XXX: Should be "-C dir" but that is waiting for getopt
					cd [string range $a 2 end]
				}
				-- {
				}
				--* {
					user-error "Unknown option $a"
				}
				default {
					# Ignore unknown options
					#error "Unknown option $a"
				}
			}
		} else {
			lappend targets $a
		}
	}

	#parray tmake
	set tmake(topdir) [find-project-top]
	cd $tmake(topdir)

	set tmake(prefix) ""

	if {[info exists rulebase.spec]} {
		invoke-spec-file rulebase.spec
	} else {
		invoke-spec-file $tmake(libdir)/rulebase.default
	}

	# Save the global state unless we need to reload
	# XXX: It would be MUCH nicer of this wasn't held in global vars!
	#      Maybe 'dict with' ?

	set tmake_save [array get tmake]
	set gobalvars {}
	# And save all the global vars too
	foreach i [info globals {[A-Z]*}] {
		dict set globalvars $i [set ::$i]
	}

	load-build-description 1

	if {$tmake(showrules)} {
		show-all-rules
	}

	# Try to build all Load targets

	# If any files specified to Load are targets,
	# build them before anything else
	set reload 0
	foreach t $tmake(projfiles) {
		set rc [build $t]
		if {$rc < 0} {
			if {$tmake(exitcode) == 0} {
				build-error "Error: Don't know how to build $t"
			}
			break
		}
		if {$rc > 0} {
			dputs m "$t has changed, reloading..."
			set reload 1
		}
	}

	if {$reload} {
		if {$tmake(writecache)} {
			# Cache has been updated, so save it
			dict set tmake_save cache $tmake(cache)
			dict set tmake_save cmdcache $tmake(cmdcache)
			dict set tmake_save writecache 1
		}

		# Restore the state
		unset tmake
		array set tmake $tmake_save

		# Including global vars
		foreach i [dict keys $globalvars] {
			set ::$i [dict get $globalvars $i]
		}
		load-build-description 0
	}

	unset tmake_save
	unset globalvars

	# Now build the targets
	if {[info exists tmake(findtarget)]} {
		if {[is-target? $tmake(findtarget)]} {
			show-rule [get-target-rule $tmake(findtarget)]
			tmake-exit 0
		}
		foreach target [dict keys $tmake(targets)] {
			if {[string match *$tmake(findtarget)* $target]} {
				show-rule $target
				puts ""
			}
		}
		tmake-exit 0
	}

	if {[llength $targets] == 0} {
		set targets all
	}

	foreach t $targets {
		if {[build $t] < 0} {
			if {$tmake(exitcode) == 0} {
				build-error "Error: Don't know how to build $t"
			}
			break
		}
	}
}

proc load-build-description {loadcache} {
	global tmake

	invoke-spec-file project.spec

	# Loaded in the global scope 
	if {![file exists build.spec]} {
		user-error "No build.spec in the current directory"
	}

	foreach i $tmake(deferred) {
		uplevel #0 $i
	}

	# Now load the cache if it exists and it isn't the second time through
	if {$loadcache && [file exists .makecache]} {
		lassign [time {source .makecache}] us
		dputs C "Loaded cache, .makecache in [expr {($us + 500) / 1000}]ms"
	}

	process-build-spec-file .

	resolve-deferred-dependencies
}

# ==================================================================
# .spec file processing
# ==================================================================

proc find-project-top {} {
	set topdir [pwd]
	while {![file exists $topdir/project.spec]} {
		set parent [file dir $topdir]
		if {$topdir eq $parent} {
			user-error "Failed to find project.spec in any parent directory."
		}
		set topdir $parent
	}
	dputs m "Project top found at $topdir"
	return $topdir
}

proc local-prefix {} {
	return $::tmake(prefix)
}

proc make-local {args} {
	prefix [local-prefix] $args
}

proc invoke-spec-file {filename} {
	global tmake
	lappend tmake(specfiles) $filename
	dputs m "Parsing $filename"

	uplevel #0 source $filename
}

proc AutoSubDirs {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(autosubdirs) 1
		}
		off {
			set ::tmake(autosubdirs) 0
		}
		default {
			dev-error "on or off expected"
		}
	}
}

proc SubDirs {args} {
	lappend ::tmake(subdirs) {*}$args
}

proc save-subdir-vars {} {
	set saved {}
	foreach n $::tmake(subdirvars) {
		dict set saved $n [set ::$n]
	}
	return $saved
}

proc restore-subdir-vars {dict} {
	foreach {n v} $dict {
		set ::$n $v
	}
}

# Read in the given spec file in the given directory (relative to topdir)
# Returns 1 if OK, or 0 if subdirs should be skipped
proc process-build-spec-file {dir} {
	global tmake
	dputs m "process-build-spec dir=$dir"
	#set dir [make_path $::automf(topdir) $dir]

	# XXX: Need to save and restore the following:
	#      autosubdirs, subdirs?

	if {$dir eq "."} {
		set tmake(prefix) ""
	} else {
		set tmake(prefix) $dir/
	}
	set path $tmake(prefix)build.spec

	if {![file exists $path]} {
		user-error "$path does not exist"
	}

	set saved [save-subdir-vars]

	BuildSpecProlog
	set rc [catch {invoke-spec-file $path} msg opts]
	BuildSpecEpilog

	restore-subdir-vars $saved

	if {$rc == 20} {
		puts "Skipping $path"
		return
	}
	if {$rc != 0 && $rc != 2} {
		return -code $rc {*}$opts $msg 
	}

	# Now subdirectories
	incr tmake(depth)

	#local_lappend subdirs $dir

	# Find the explicitly set subdirs
	set subdirs $tmake(subdirs)
	set tmake(subdirs) {}

	# Normally we search for dirs containing build.spec
	if {$tmake(autosubdirs)} {
		foreach d [glob -nocomplain $dir/*] {
			if {[file isdirectory $d] && [file exists $d/build.spec] && $d ni $subdirs} {
				lappend subdirs $d
			}
		}
	}

	# Now process subdirs
	foreach d $subdirs {
		if {[file exists $d/build.ignore]} {
			dputs m "Ignoring $d because build.ignore exists"
		} else {
			process-build-spec-file $d
		}
	}
	incr tmake(depth) -1
}

# Returns a list of all files which were once a target but are no longer
proc get-orphan-targets {} {
	set result {}
	foreach i [dict keys $::tmake(cache)] {
		if {![is-target? $i]} {
			lappend result $i
		}
	}
	return $result
}

proc discard-orphan-targets {} {
	foreach i [dict keys $::tmake(cache)] {
		if {![is-target? $i]} {
			dict unset ::tmake(cache) $i
			catch {
				dict unset ::tmake(cmdcache) [get-rule-target $i]
			}
			if {$::tmake(writecache) == 0} {
				dputs C "discarding orphans, updated cache"
				set ::tmake(writecache) 1
			}
		}
	}
}

# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	foreach m $args {
		if {[dict exists $::tmake(modules) $m]} {
			continue
		}
		dict set ::tmake(modules) $m 1

		set source $::tmake(libdir)/${m}.tcl
		if {![file exists $source]} {
			dev-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		#lappend ::automf(makefiledeps) $source
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {msg} {
	puts stderr "Error: $msg"
	puts stderr "Try: 'tmake --help' for options"
	tmake-exit 1
}

# @build-error msg
#
# Indicate that something failed to build and set exitcode=1
proc build-error {msg} {
	dputs b "BUILD ERROR: $msg"
	puts stderr $msg
	set ::tmake(exitcode) 1
}
# @user-notice msg
#
# Output the given message to stderr.
#
proc user-notice {msg} {
	puts stderr $msg
}

# Incorrect usage in the build.spec file. Identify the location.
proc dev-error {msg} {
	puts stderr [error-location $msg]
	tmake-exit 1
}

proc tmake-exit {code} {
	global tmake

	# Write the cache before exiting
	if {$tmake(writecache)} {
		lassign [time {
			set f [open .makecache w]
			puts $f [list set tmake(cache) $tmake(cache)]
			puts $f [list set tmake(cmdcache) $tmake(cmdcache)]
			puts $f [list set tmake(headerscancache) $tmake(headerscancache)]
			close $f
		}] us
		dputs C "Wrote cache, .makecache in [expr {($us + 500) / 1000}]ms"
	}
	exit $code
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		puts $msg
	}
}

# Returns 1 if any of the debug types is set
proc debug-is-set {types} {
	foreach t $types {
		if {[dict get $::tmake(debugtypes) $t]} {
			return 1
		}
	}
	return 0
}

# Output a message to stdout if --debug is set.
#
proc dputs {types msg} {
	if {[debug-is-set $types]} {
		puts "[dbg-msg-indent] \[$types\] $msg"
	}
}

proc dbg-msg-indent {} {
	set now [clock-millis]
	set elapsed [expr {$now - $::tmake(start)}]
	return [format %5dms $elapsed][string repeat "  " [llength $::tmake(current)]]
}

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	set lines [split $do \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set ruletarget [get-rule-target $target]
	} else {
		set ruletarget $target
	}
	if {[is-rule? $ruletarget]} {
		array set t [get-rule $ruletarget]
		set flags {}
		set lines {}
		foreach n [lsort [array names t]] {
			set v $t($n)
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				phony - nofail {
					if {$v} {
						lappend flags $n
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vv"
					}
				}
				onerror {
					if {$v ne ""} {
						lappend lines "$n={[join [split [string trim $v] \n] {;}]}"
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
				}
			}
		}
		if {[llength $flags]} {
			append target " \[$flags\]"
		}
		puts "$t(target): $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		foreach do $t(do) {
			show-rule-commands $do
		}
	} else {
		puts "No rule for $ruletarget"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(rules)]] {
		puts "-------------------------------------------"
		show-rule $i
		puts ""
	}
}

# ==================================================================
# Variable Handling
# ==================================================================

# Set a variable to the given value
# 
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	#puts "define $name $args"
	if {![dict exists $::tmake(fixedvars) $name]} {
		upvar #0 $name n
		set n [join $args]
	}
}

proc define! {name args} {
	#puts "define! $name $args"
	dict set ::tmake(fixedvars) $name 1
	upvar #0 $name n
	set n [join $args]
}

# Set a variable to the given value
# unless it is already set to a non-empty value.
#
proc define? {name args} {
	#puts "define? $name $args"
	upvar #0 $name n
	if {![info exists n] || $n eq ""} {
		define $name {*}$args
	}
}

# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	upvar #0 $name n
	append-with-space ::$name [join $args]
}

# If the given var is not set or is "", sets it to $value
# Otherise appends $value with a space separator (or $space)
#
proc append-with-space {varname value {space " "}} {
	upvar $varname n
	if {[info exists n] && $n ne ""} {
		append n $space $value
	} else {
		set n $value
	}
}

# Takes a list and returns a new list with $suf appended
# to each element
# 
# suffix .c a b c => a.c b.c c.c
#
proc suffix {suf args} {
	set result {}
	foreach p [join $args] {
		lappend result $p$suf
	}
	return $result
}

# Takes a list and returns a new list with $pre prepended
# to each element
# 
# suffix jim- a.c b.c => jim-a.c jim-b.c
#
proc prefix {pre args} {
	set result {}
	foreach p [join $args] {
		lappend result $pre$p
	}
	return $result
}

# Takes a list of filenames and returns a new list with
# the extension of each filename changed to $ext
# 
# change-ext .c a.o b.o c => a.c b.c c.c
#
proc change-ext {ext args} {
	set result {}
	foreach p [join $args] {
		lappend result [file rootname $p]$ext
	}
	return $result
}

# Merges target variables.
# These are stored in dictionaries, where $dict1 is the current vars
# and the new vars $dict2 need to be merged.
# Where there is no overlap, the dictionaries are simply merged.
# Where a var exists in both, the values are combined with a space separator.
proc merge-vars {dict1 dict2} {
	if {[dict size $dict2]} {
		if {[dict size $dict1] == 0} {
			return $dict2
		}
		array set d1 $dict1
		foreach {n v} $dict2 {
			append-with-space d1($n) $v
		}
		return [array get d1]
	}
	return $dict1
}

# Appends the given arguments to the given keylist in the dictionary
proc dict-lappend {dictname keys args} {
	upvar $dictname d
	if {[dict exists $d {*}$keys]} {
		set list [dict get $d {*}$keys]
		lappend list {*}$args
	} else {
		set list $args
	}
	dict set d {*}$keys $list
}

# Increments a value in the dictionary
proc dict-incr {dictname key {incr 1}} {
	upvar $dictname d
	set value [dict get $d $key]
	incr value $incr
	dict set d $key $value
}

# ==================================================================
# File Utilities
# ==================================================================

# @readfile filename ?default=""?
#
# Return the contents of the file, without the trailing newline.
# If the doesn't exist or can't be read, returns $default.
#
proc readfile {filename {default_value ""}} {
	set result $default_value
	catch {
		set f [open $filename]
		set result [read -nonewline $f]
		close $f
	}
	return $result
}

# @writefile filename value
#
# Creates the given file containing $value.
# Does not add an extra newline.
#
proc writefile {filename value} {
	set f [open $filename w]
	puts -nonewline $f $value
	close $f
}

# ==================================================================
# Rule Handling
# ==================================================================

# Returns 1 if the target is an individual target
proc is-target? {target} {
	dict exists $::tmake(targets) $target
}

# Returns 1 if the target is a rule target
proc is-rule? {target} {
	dict exists $::tmake(rules) $target
}

# Converts a target to the rule target
proc get-rule-target {target} {
	dict get $::tmake(targets) $target
}

# Returns the rule for an individual target
proc get-target-rule {target} {
	get-rule [get-rule-target $target]
}

# Returns the rule for a rule target
proc get-rule {target} {
	dict get $::tmake(rules) $target
}

proc update-rule {ruledict} {
	set ruletarget [dict get $ruledict target]
	if {![is-rule? $ruletarget]} {
		# Haven't seen this rule before so individual target pointers
		foreach t $ruletarget {
			if {[dict exists $::tmake(targets) $t]} {
				set orig [get-target-rule $t]
				dev-error "Rule for $t was already specified at [make-source-location $t(source)]"
			}
			dict set ::tmake(targets) $t $ruletarget
		}
	}
	dict set ::tmake(rules) $ruletarget $ruledict
}

proc show-this-rule {} {
	if {[debug-is-set p]} {
		puts "\[p\] [make-source-location [find-source-location]] [info level -1]"
	}
}

proc make-source-location {list {prefix {}} {suffix {}}} {
	if {$list eq "unknown"} {
		return ""
	}
	return $prefix[join $list ", "]$suffix
}

# This is the only way to create a rule
#
# Parses the arguments and adds them to the rule base
#
proc target {ruletarget args} {
	# If the rule aready exists, we are updating
	if {[is-rule? $ruletarget]} {
		array set orig [get-rule $ruletarget]
	} elseif {[is-target? $ruletarget]} {
		# Can't update a rule via the invidual target
		array set orig [get-target-rule $ruletarget]
		dev-error "Multiple-target rule for $ruletarget was already specified at [make-source-location $orig(source) @]"
	}
	# XXX: Where to we check that we don't have rules {a b} and {b a}? In update-rule?

	array set info [parse-rule $ruletarget $args]

	#show-this-rule

	set replace $info(replace)
	unset info(replace)

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	if {$replace} {
		if {[info exists orig]} {
			dputs t "Replacing existing rule for $ruletarget @$orig(source)"
			unset orig
		} else {
			dputs t "Rule for $ruletarget with -replace but not existing target @$info(source)"
		}
	}
	if {[info exists orig]} {
		# There is already a rule for this target, so attempt
		# to merge the two rules

		if {[llength $info(do)] && [llength $orig(do)]} {
			dev-error "$ruletarget already has '-do' @$orig(source)"
		}
		if {$info(dyndep) ne "" && $orig(dyndep) ne ""} {
			dev-error "$ruletarget already has '-dyndep' @$orig(source)"
		}
		lappend info(depends) {*}$orig(depends)
		lappend info(inputs) {*}$orig(inputs)
		lappend info(clean) {*}$orig(clean)
		incr info(phony) $orig(phony)
		incr info(nofail) $orig(nofail)
		append-with-space info(onerror) $orig(onerror) \n
		# Only one of these will be non-blank
		lappend orig(do) {*}$info(add-do)
		unset info(add-do)
		append-with-space info(dyndep) $orig(dyndep)

		if {$info(source) eq "unknown"} {
			set info(source) $orig(source)
		} elseif {$orig(source) ne "unknown"} {
			lappend info(source) {*}$orig(source)
		}

		# Need to append to any vars which exist
		set info(vars) [merge-vars $orig(vars) $info(vars)]

		# Whichever rule has '-do' also specifies '-inputs' and '-msg'
		if {[llength $info(do)] == 0} {
			set info(do) $orig(do)
			set info(inputs) $orig(inputs)
			set info(msg) $orig(msg)
		}
	}

	# Now create/update the rule
	update-rule [array get info]
}

# Adds the list elements to the target-specific variable.
#
# This a much faster equivalent of:
#
#     target $ruletarget -vars $varname {*}$list
#
proc target-add-var {ruletarget varname list} {
	# The rule must already exist
	if {![is-rule? $ruletarget]} {
		dev-error "$ruletarget is not a rule target"
	}

	dict-lappend ::tmake(rules) [list $ruletarget vars $varname] {*}$list
}

proc resolve-deferred-dependencies {} {
	global tmake
	foreach ruletarget [dict keys $tmake(rules)] {
		array unset t
		array set t [get-rule $ruletarget]
		foreach dd $t(maybe-depends) {
			if {[is-target? $dd]} {
				dputs m "Resolving deferred dependency $dd for $ruletarget"
				lappend t(depends) $dd
			} else {
				dputs m "Discarding deferred dependency $dd for $ruletarget"
			}
		}
		unset t(maybe-depends)
		update-rule [array get t]
	}
}

proc parse-rule-args {arglistname optname} {
	upvar $arglistname arglist
	upvar $optname opt
	set arglist [lassign $arglist opt]

	if {![string match -* $opt]} {
		dev-error "Unexpected parameter for rule: $opt"
	}
	set opt [string range $opt 1 end]
	if {$opt eq "vars"} {
		set incr 2
	} else {
		set incr 1
	}

	for {set i 0} {$i < [llength $arglist]} {incr i $incr} {
		if {[string match -* [lindex $arglist $i]]} {
			incr i -1
			break
		}
	}
	set optlist [lrange $arglist 0 $i]
	incr i
	set arglist [lrange $arglist $i end]
	return $optlist
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-rule {target arglist} {
	set info(source) [find-source-location]
	set info(target) $target

	array set info {
		status unknown
		inputs {} depends {} maybe-depends {} clean {} do {} onerror {} msg {} vars {} dyndep {} add-do {}
		replace 0 add 0 nofail 0 phony 0
	}

	# Parse an option followed by multiple non-options
	while {[llength $arglist]} {
		set optargs [parse-rule-args arglist opt]
		switch -exact -- $opt {
			phony - nofail - replace - add {
				if {[llength $optargs]} {
					dev-error "Rule for $target has non-option parameters after -$opt: $optargs"
				}
				set info($opt) 1
			}
			inputs - depends - maybe-depends {
				lappend info($opt) {*}[join $optargs]
			}
			clean {
				set info($opt) $optargs
			}
			do - msg - dyndep - onerror {
				if {[llength $optargs] > 1} {
					dev-error "Rule for $target has more than one '-$opt' parameter"
				}
				if {$opt eq "do"} {
					set info($opt) $optargs
				} else {
					set info($opt) [lindex $optargs 0]
				}
			}
			vars {
				if {[llength $optargs] % 2} {
					dev-error "Rule for $target has an odd number of parameters to '-vars'"
				}
				lappend info($opt) {*}$optargs
			}
			getvars {
				foreach v $optargs {
					if {![info exists ::$v]} {
						dev-error "Rule for $target has -getvars for non-existent variable: $v"
					}
					lappend info(vars) $v [set ::$v]
				}
			}
			default {
				dev-error "Rule for $target has unknown option: -$opt"
			}
		}
	}

	if {$info(add) && $info(replace)} {
		dev-error "Rule for $target has both '-add' and '-replace'"
	}
	if {$info(add)} {
		if {![llength $info(do)]} {
			dev-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) $info(do)
		set info(do) {}
	}
	unset info(add)

	if {[llength $info(do)] == 0 && [llength $info(inputs)]} {
		dev-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {[llength $info(do)] == 0 && $info(msg) ne ""} {
		dev-error "Rule for $target has '-msg' but no '-do'"
	}

	array get info
}

# ==================================================================
# Dependency Engine
# ==================================================================

proc file-real-mtime {filename} {
	file mtime $filename
}

proc file-virtual-mtime {filename} {
	set mtime [file-real-mtime $filename]
	if {[dict exists $::tmake(cache) $filename]} {
		lassign [dict get $::tmake(cache) $filename] vmtime omtime
		# If the actual mtime is different from the saved mtime, we
		# ignore the cached (virtual) mtime.
		if {$omtime == $mtime} {
			# The cache is up to date, so use the virtual mtime
			set mtime $vmtime
		}
	}
	return $mtime
}

proc find-oldest-time {list name} {
	upvar $name oldestname
	lassign $list oldestname
	set oldesttime [file-virtual-mtime $oldestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-virtual-mtime $file]
			if {$t < $oldesttime} {
				set oldesttime $t
				set oldestname $file
			}
		}
	}
	#puts "find-oldest-time: $oldestname $oldesttime ($list)"
	return $oldesttime
}

proc find-newest-time {list name} {
	upvar $name newestname
	lassign $list newestname
	set newesttime [file-real-mtime $newestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-real-mtime $file]
			if {$t > $newesttime} {
				set newesttime $t
				set newestname $file
			}
		}
	}
	#puts "find-newest-time: $newestname $newesttime ($list)"
	return $newesttime
}

# Both $targets and $depends are lists of files which must exist
# If any file is $targets is older than any file in $depends, the
# targets are out of date and 1 is returned. In this case the 
# variable named $depname is set to the name of the newest
# file in $depends
# Otherwise 0 is returned.
#
proc needbuild? {targets depends depname} {
	upvar $depname newest_depends
	set depends_time [find-newest-time $depends newest_depends]
	#puts "newest depends: [clock format $depends_time] $newest_depends"
	set targets_time [find-oldest-time $targets oldest_target]
	#puts "oldest targets: [clock format $targets_time] $oldest_target"
	if {$targets_time < $depends_time} {
		dputs b "$oldest_target is older than $newest_depends, so forcing rebuild"
		return 1
	}
	dputs n "$targets is newer than $depends, so not forcing rebuild"
	return 0
}

# Sets target-local variables. e.g. $inputs, $depends and $target
proc set-target-vars {info} {
	foreach {n v} [dict get $info vars] {
		set ::$n $v
	}
	foreach n {target depends inputs} {
		set ::$n [dict get $info $n]
	}
}
proc clear-target-vars {vars} {
	foreach n [dict keys $vars] {
		set ::$n ""
	}
}

proc set-target-result {target result} {
	set ruletarget [get-real-target $target]
	if {[dict get $::tmake(rules) $ruletarget result] == 0} {
		dict set ::tmake(rules) $ruletarget result $result
	}
}

proc note {args} {
	if {$::tmake(verbose) == 0} {
		puts [join $args]
	}
}

proc run {args} {
	set cmdline [join $args]
	vputs [string trim $cmdline]
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 1} {
		# On error, display the command and the error and return break
		build-error \n\t$cmdline\n$msg\n
		return -code break
	}
	# XXX: What to do on signal?
}

proc calc-dyndeps {target} {
	array set t [get-rule $target]

	set dyndeps {}
	if {$t(dyndep) ne ""} {
		foreach i $t(depends) {
			lappend dyndeps {*}[uplevel #0 $t(dyndep) $i]
		}
		dputs d "Dynamic dependencies for $target: $dyndeps"
	}
	return $dyndeps
}

proc file-exists-all {list missingname} {
	foreach f $list {
		if {![file exists $f]} {
			upvar $missingname missing
			set missing $f
			return 0
		}
	}
	return 1
}

proc build {target} {
	global tmake
	set current $tmake(current)
	lappend current $target
	if {![is-target? $target]} {
		if {[file exists $target]} {
			dputs n "$target is not a target, but exists"
			return 0
		}
		dputs b "$target is not a target and does not exist"
		return -1
	}
	array set t [get-target-rule $target]
	set ruletarget $t(target)
	if {$t(status) eq "checking"} {
		dev-error "Recursive definition for [join [lreverse $current] { <= }] [make-source-location $t(source) @]"
	}
	if {$t(status) eq "uptodate"} {
		return 0
	}
	if {$t(status) eq "failed"} {
		dputs b "$target has previously failed to build"
		return -1
	}
	if {$t(status) eq "built"} {
		dputs b "$target has previously been built"
		return 1
	}

	set t(status) checking
	update-rule [array get t]

	set reason {}
	if {$t(phony)} {
		dputs b "$target is phony, so rebuilding"
		lappend reason phony
		set result 1
	} elseif {![file-exists-all $ruletarget missing]} {
		dputs b "$missing doesn't exist, so rebuilding"
		lappend reason noexist
		set result 1
	} else {
		#dputs b "$ruletarget exists, so checking dependencies"
		set result 0
	}

	set oldcurrent $tmake(current)
	set tmake(current) $current

	# Here is the plan to build $target
	# 1. Run 'build' for each static dependency
	#    - If 'build' returns -1 (fails) and --quickstop is specified, we are done
	#    - If 'build' returns 1, the target needs to be built
	# 2. Calculate any dynamic dependencies for $target and run 'build' for each one
	#    - If 'build' returns -1 (fails) and --quickstop is specified, we are done
	#    - If 'build' returns 1, the target needs to be built
	# 3. If nothing was built ($result is 0), check each static+dynamic dependency for time
	#    - If needbuild? returns 1, the target needs to be built
	# 4. If build not forced, check substituted '-do' against any cached value
	#    - If cached commands exists and they are different, the target needs to be built

	# First check dynamic dependencies
	set depends $t(depends)

	# 1. Static dependencies
	foreach i $depends {
		set rc [build $i]
		if {$rc < 0} {
			if {$tmake(exitcode) == 0} {
				build-error "Error: Don't know how to build $i: [join [lreverse $current] { <= }] [make-source-location $t(source) @]"
			}
			set result -1
			if {$tmake(quickstop)} {
				break
			}
		} elseif {$rc > 0} {
			lappend reason depend $i
			if {$result == 0} {
				dputs b "Rebuilding $target because $i was built"
				set result 1
			}
		}
	}

	if {$result >= 0} {
		# 2. Dynamic dependencies. Only targets or existing files are returned by calc-dyndeps.
		# Need to set target vars before doing this
		set-target-vars [array get t]

		foreach i [calc-dyndeps $ruletarget] {
			lappend depends $i

			if {[check-signal]} {
				set result -1
				break
			}

			set rc [build $i]
			if {$rc < 0} {
				if {$tmake(exitcode) == 0} {
					build-error "Error: Don't know how to build $i: [join [lreverse $current] { <= }] [make-source-location $t(source) @]"
				}
				set result -1
				if {$tmake(quickstop)} {
					break
				}
			} elseif {$rc > 0} {
				lappend reason depend $i
				if {$result == 0} {
					dputs b "Rebuilding $ruletarget because $i was built"
					set result 1
				}
			}
		}
	}

	if {$tmake(quickstop) && $tmake(exitcode)} {
		tmake-exit $tmake(exitcode)
	}

	if {$result == 0 && [llength $depends]} {
		# 3.  Target exists but no dependencies were built so check time dependencies
		if {[needbuild? $ruletarget $depends depfile]} {
			lappend reason older $depfile
			set result 1
		}
	}

	set-target-vars [array get t]

	if {$result == 0 && [llength $t(do)] && [dict exists $tmake(cmdcache) $ruletarget]} {
		# 4. Compare previous '-do' commands with current commands
		set rc [catch {uplevel #0 [list subst $t(do)]} do]
		if {$rc != 0} {
			dputs m "Warning: subst failed for rule $ruletarget"
		}
		set prevdo [dict get $tmake(cmdcache) $ruletarget]
		if {$rc == 0 && $do ne $prevdo} {
			dputs b "Commands for $ruletarget have changed, so forcing rebuild"
			#puts "=== old ==="
			#puts $prevdo
			#puts "=== new ==="
			#puts $do
			#puts "-----------"
			lappend reason commands
			set result 1
		} else {
			dputs n "Commands for $ruletarget are unchanged"
		}
	}

	if {$result > 0} {
		if {[debug-is-set g]} {
			puts "\[g\] [join $current { --> }] ($reason)"
		}
	}

	if {$result > 0 && [llength $t(do)]} {
		#puts "Running rules for $ruletarget"
		dputs b "Building [join [lreverse $current] { <= }] [make-source-location $t(source) "with rule @"]"
		uplevel #0 $t(msg)
		if {[dict get $tmake(debugtypes) r]} {
			show-rule $ruletarget
		}
		if {$tmake(norun)} {
			foreach do $t(do) {
				if {[catch {uplevel #0 [list subst $do]} expanded]} {
					# The rule probably refers to a command or variable which
					# doesn't exist, so show it without the subst
					set expanded $do
				}
				if {$tmake(norun) == 1} {
					show-rule-commands $expanded
				}
			}
			set rc 0
		} else {
			foreach do $t(do) {
				set rc [catch {uplevel #0 $do} msg opts]
				if {$rc} {
					# XXX: Check for signal?
					if {$t(nofail)} {
						user-notice "\[ignored\] $msg"
						set rc 0
					} else {
						break
					}
				}
			}
		}

		if {[check-signal 1]} {
			puts ""
			set tmake(exitcode) 2
			set rc 5
		}

		# Always delete $t(clean) files after the rule has run
		if {[llength $t(clean)]} {
			file delete {*}$t(clean)
		}

		# Did the rule make the targets?
		if {$rc == 0 && !$t(phony) && !$tmake(norun)} {
			set now [clock seconds]
			foreach f $ruletarget {
				if {![file exists $f]} {
					# XXX: Should onerror run here if --quickstop is set?
					build-error "[make-source-location $t(source) "" ": "]Error: Rule for $target failed to build target(s) $f"
					# Use break to indicate that we have already output the message
					set rc 3
				} else {
					# Record the time that this target was created, along with the real mtime
					dict set tmake(cache) $f [list $now [file-real-mtime $f]]
					if {$tmake(writecache) == 0} {
						dputs C "Targets built, updating cache"
						set tmake(writecache) 1
					}
					#puts "Set cachetime of $f [clock format $now] [clock format [file-real-mtime $f]]"

					# And save the commands in the command cache
					dict set tmake(cmdcache) $ruletarget [uplevel #0 [list subst $t(do)]]
				}
			}
		}

		if {$rc == 0} {
			incr tmake(numtargets)
		} else {
			# On failure, delete the target(s)
			file delete {*}$ruletarget

			# Try to run onerror
			if {[catch {
				dputs b $t(onerror)
				uplevel #0 $t(onerror)
				if {$rc == 1} {
					build-error [error-stacktrace $msg]
				}
			} fmsg fopts]} {
				build-error [error-stacktrace $fmsg]
			}
			set result -1
		}

		if {$rc == 5 || ($tmake(quickstop) && $tmake(exitcode))} {
			tmake-exit $tmake(exitcode)
		}

		clear-target-vars $t(vars)
	}

	if {$result < 0} {
		set t(status) failed
	} elseif {$result > 1} {
		set t(status) built
	} else {
		set t(status) uptodate
	}
	update-rule [array get t]

	set tmake(current) $oldcurrent
	return $result
}

# ==================================================================
# Dynamic dependencies
# ==================================================================

# XXX: Stops scanning after 200 lines with no #include - should be at least configurable
# 
proc header-scan-regexp {regex filename} {
	global tmake

	# memoize the result
	set mtime [file-real-mtime $filename]
	if {[dict exists $tmake(headerscancache) $filename]} {
		lassign [dict get $tmake(headerscancache) $filename] cache_mtime cache_regex headers
		if {$cache_mtime == $mtime && $cache_regex eq $regex} {
			# Can reuse the cache
			dputs d "header-scan-regexp $filename (cached) => $headers"
			return $headers
		}
		# Stale
		dict unset tmake(headerscancache) $filename
	}
	set headers {}
	set f [open $filename]
	set n 0
	while {[gets $f buf] >= 0} {
		if {[regexp $regex $buf -> name]} {
			lappend headers $name
			set n 0
		} elseif {[incr n] > 200} {
			break
		}
	}
	close $f
	dict set tmake(headerscancache) $filename [list $mtime $regex $headers]
	if {$tmake(writecache) == 0} {
		dputs C "New header scan, updating cache"
		set tmake(writecache) 1
	}
	dputs d "header-scan-regexp $filename => $headers"
	return $headers
}

proc find-file {filename paths} {
	foreach p $paths {
		if {$p eq "" || $p eq "."} {
			set f $filename
		} else {
			set f [file join $p $filename]
		}
		if {[is-target? $f] || [file exists $f]} {
			return $f
		}
	}
	dputs D "Not a file and not a target, $filename"
	return ""
}

# XXX: This could be done better
proc header-scan-regexp-recursive {incpaths regex filename} {
	if {![file exists $filename]} {
		return {}
	}
	dputs d "Scanning $filename for headers: incpaths=$incpaths"
	array set deps {}
	set scanned($filename) 1
	set toscan [header-scan-regexp $regex $filename]
	while {[llength $toscan]} {
		set newscan {}
		foreach d $toscan {
			if {![info exists scanned($d)]} {
				set scanned($d) 1
				set df [find-file $d $incpaths]
				if {$df ne ""} {
					set d $df
					set deps($d) 1
					if {[file exists $df]} {
						lappend newscan {*}[header-scan-regexp $regex $d]
					}
				}
			}
		}
		set toscan $newscan
	}
	array names deps
}

# ==================================================================
# ENTRY POINT
# ==================================================================

if {[info exists env(MAKEFLAGS)]} {
	# Running under make
	set argv [list {*}-$env(MAKEFLAGS) {*}$argv]
}

if {[catch {make $argv} msg]} {
	puts stderr [error-stacktrace $msg]
	set tmake(exitcode) 1
}

if {$tmake(numtargets) || $tmake(showtime)} {
	set elapsed [expr {([clock-millis] - $tmake(start)) / 1000.0}]
	puts "Built $tmake(numtargets) target(s) in [format %.2f $elapsed] seconds"
}

tmake-exit $tmake(exitcode)
