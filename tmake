#!/usr/bin/env jimsh
# Copyright (c) 2011-2016 WorkWare Systems http://www.workware.net.au/
# All rights reserved
# vim:se syntax=tcl:

# ==================================================================
# Initialiation
# ==================================================================

set tmake(version) {0.7.0 (2-Sep-2016)}
set tmake(cacheversion) 3

# Turn on debugging as early as possible
set tmake(debug) $("--debug" in $argv)

set tmake(debugtypes) {d 0 n 0 r 0 b 0 t 0 c 0 g 0 G 0 p 0 m 0 l 0 D 0 C 0 T 0 B 0 v 0 x 0 j 0}
set tmake(debughelp) {
	* "Enable all debug"
	? "Display help for debug types"
	d "Dynamic dependencies"
	D "Dynamic dependencies (detailed)"
	n "Reasons for targets NOT built"
	b "Reasons for targets BUILT"
	B "Reasons for targets BUILT - changed commands or targets"
	r "Display rules when triggered"
	g "Depencency graph for each target"
	G "List goals (targets) as they are attempted"
	p "Print rules while parsing"
	m "Miscellaneous (locating and parsing of files)"
	l "Locating sources and targets"
	c "Configuration expressions via ifconfig"
	C "Cache handling"
	T "Timing (add --delta for delta times)"
	v "Variable definition"
	j "Parallel (job-based) builds"
}
set tmake(verbose) 0
set tmake(showdelta) 0
set tmake(norun) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(exitcode) 0
set tmake(modules) {}
set tmake(autosubdirs) 1
set tmake(checkexternalcmds) 0
set tmake(deferred) {}
set tmake(projfiles) {}
set tmake(defines) {}
set tmake(fixedvars) {}
set tmake(installed) 0
set tmake(cleaning) 0
set tmake(quiet) 0
set tmake(ignoreforce) 0
set tmake(force) 0
set tmake(usepager) 1
set tmake(showcache) 0
set tmake(showvars) 0
set tmake(showaliases) 0
set tmake(showwarnings) 0
set tmake(depfindcache) {}
set tmake(addtargets) {}
set tmake(emptycache) {file {} cmd {} deps {} target {} headerscan {} warnings {} exec {} version 0 writecache 0}
set tmake(commands-overview) {}
set tmake(commands) {}
set tmake(cli-options) {}
# The known clean targets
set tmake(clean-targets) {clean distclean clean-orphans}

set tmakecache $tmake(emptycache)
set tmakeprecache {}

set tmake(defaulttarget) all
set tmake(loadedprojectspec) 0
set tmake(current) {}
set tmake(rules) {}
set tmake(ruledefaultopts) {}
set tmake(aliases) {}
set tmake(rulestatus) {}
set tmake(targetstatus) {}
set tmake(targets) {}
set tmake(parsedone) 0
set tmake(numtargets) 0
set tmake(subdirs) {}
set tmake(prefix) ""
set tmake(localdir) .
set tmake(warningmsgs) {}
set tmake(running) {}
set tmake(pending) {}
set tmake(jobpid) -1
set tmake(resetstatus) 0

# ==================================================================
# Argument Processing
# ==================================================================

proc make-parse-options {argv} {
	global tmake
	#puts "make-parse-options [list $argv]"

	use argparse

	# Do we need to remove anything from cli-options
	# e.g. -C?
	set tmake(cli-options) $argv

	argparse argv {
		--configure {
			# Just want to run configure with the remaining args
			set tmake(configure) 1
			break
		}
		--showcache {
			incr tmake(showcache)
		}
		{--find --find=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 0
		}
		{--findall --findall=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 1
		}
		{--jobs=*} {
			define! MAXJOBS [argparam $arg]
		}
		--delta {
			incr tmake(showdelta)
		}
		--build=* {
			set tmake(build) [argparam $arg]
		}
		--force {
			incr tmake(force)
		}
		--showvars {
			incr tmake(showvars)
		}
		--showaliases {
			incr tmake(showaliases)
		}
		--warnings {
			incr tmake(showwarnings)
		}
		--rulebase {
			set rulebase [get-rulebase]
			if {[llength $rulebase] > 1} {
				puts [lindex $rulebase 1]
			} else {
				puts [readfile [lindex $rulebase 0]]
			}
			exit 0
		}
		--rules {
			user-notice purple "Warning: Use --commands rather than the deprecated --rules"
			set tmake(listcommands) 1
		}
		--commands {
			set tmake(listcommands) 1
		}
		{--targets --targets=all} {
			set tmake(listtargets) [argparam $arg]
		}
		--debug {
			# Enable full stack traces as well as -dg
			set tmake(debug) 1
			dict set tmake(debugtypes) g 1
		}
		-d* {
			if {$arg eq "-d?"} {
				puts "Debugging can be enabled with -d..."
				puts "The debugging categories are as follows:\n"

				foreach {n desc} $tmake(debughelp) {
					puts "\t$n\t$desc"
				}
				exit 0
			}
			if {$arg eq "-d*"} {
				foreach i [dict keys $tmake(debugtypes)] {
					dict set tmake(debugtypes) $i 1
				}
				lappend tmake(cli-options) $arg
			} else {
				foreach i [split [string range $arg 2 end] {}] {
					dict set tmake(debugtypes) $i 1
				}
			}
		}
		{--install=* --install} {
			use install
			tmake_install [argparam $arg]
		}
		{--verbose -v} {
			incr tmake(verbose)
		}
		--col* {
			set tmake(colout) 1
			set tmake(colerr) 1
		}
		--nocol* {
			set tmake(colout) 0
			set tmake(colerr) 0
		}
		--version {
			use help
			pputs [show-version]
			exit 0
		}
		{--help -h} {
			use help
			show-help $tmake(cli-options)
			exit 0
		}
		--ref {
			use help
			show-reference
			exit 0
		}
		--nopager {
			set tmake(usepager) 0
		}
		--genie {
			use genie
			tmake-genie $tmake(cli-options)
			exit 0
		}
		{--dry-run --just-print -n} {
			set tmake(norun) 1
		}
		{-N -nn} {
			set tmake(norun) 2
		}
		{--tim* -t} {
			incr tmake(showtime)
		}
		{-q --quickstop} {
			incr tmake(quickstop)
		}
		{-Q --quiet} {
			incr tmake(quiet)
		}
		{-p --print*} {
			incr tmake(showrules)
		}
		-C {
			set arg [argnext argv]
			# This will fail with a fatal error if not a dir
			enter-new-dir [file-normalize $arg]
			cd $arg
		}
		-- {
			break
		}
		--* {
			user-error "Unknown option $arg"
		}
		*=* {
			if {[regexp {^([^=]*)=(.*)} $arg -> n v]} {
				# ABC=DEF
				define! $n $v
			}
		}
	}
	return $argv
}

proc callmake {__argv} {
	# This stack frame is designed specifically to hold 'define' variables
	return [make $__argv]
}

proc make {argv} {
	global tmake

	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "early"} {
		fake-an-error
	}

	# 'compat' is needed before we can do anything, so set a temporary $tmake(dir)
	if {!$tmake(installed)} {
		set argv0 $::argv0
		while {[file type $argv0] eq "link"} {
			set argv0 [file readlink $argv0]
		}
		set tmake(dir) [file dirname $argv0]
		use compat
	}

	use colour util fileutil

	set tmake(exe) [file-normalize $::argv0]
	set tmake(dir) [file dirname $tmake(exe)]
	set tmake(start) [clock millis]
	set tmake(prevtime) $tmake(start)
	set tmake(initialdir) [pwd]
	set tmake(lastchdir) $tmake(initialdir)

	# Parse the options and return the list of targets to build

	# XXX Need to do this first to find -C, but
	# tmake.opt and TMAKEFLAGS should really be done first
	# so that command line options can override them
	set tmake(cmdline) [make-parse-options $argv]

	# Need to find the project top
	set tmake(topsrcdir) [find-project-top]
	if {$tmake(topsrcdir) eq ""} {
		user-error "Failed to find project.spec in any parent directory."
	}
	if {[file exists $tmake(topsrcdir)/tmake.opt]} {
		dputs m "tmake.opt exists, so loading command line options"
		make-parse-options [readfile $tmake(topsrcdir)/tmake.opt]
	}
	set TMAKEFLAGS [env TMAKEFLAGS ""]
	if {$TMAKEFLAGS ne ""} {
		dputs m "TMAKEFLAGS is set, so parsing"
		make-parse-options $TMAKEFLAGS
	}

	# We want disabled debugging to be as fast as possible
	# These are called very frequently
	foreach i {n G d D} {
		if {[debug-is-set $i]} {
			alias dputs-$i dputs $i
		} else {
			# proc with null body is specially optimised
			proc dputs-$i {args} {}
		}
	}

	# Find the current dir relative to topsrcdir
	set tmake(subdir) [relative-path [pwd] $tmake(topsrcdir)]

	# Builds run from topsrcdir
	cd $tmake(topsrcdir)

	# Full path
	set tmake(topsrcdir) [pwd]

	# By default, the build directory is 'objdir', but this
	# can be changed with --build, either on the command line or from tmake.opt
	# XXX: Currently tmake.opt overrides the command line because it it parsed later.
	if {![info exists tmake(build)]} {
		dputs m "Setting --build=objdir"
		set tmake(build) objdir
	} else {
		dputs m "Got --build=$tmake(build)"
	}

	# Create the build dir now
	file mkdir $tmake(build)

	set tmake(topbuilddir) [file-normalize $tmake(build)]

	# Make these available in the environment for the benefit of generator programs and scripts
	# which want to be able to find things
	setenv TOPSRCDIR $tmake(topsrcdir)
	setenv TOPBUILDDIR $tmake(topbuilddir)
	setenv BUILDDIR $tmake(build)

	define TOPSRCDIR $tmake(topsrcdir)
	define TOPBUILDDIR $tmake(topbuilddir)
	define BUILDDIR $tmake(build)

	if {$tmake(showcache)} {
		show-cache
		exit 0
	}

	flush stdout

	set tmake(prefix) ""

	if {[exists tmake(configure)]} {
		dputs m "--configure options, so taking over targets"
		# Put the command line in CONFIGURE_OPTS
		# and build configure
		define! CONFIGURE_OPTS $tmake(cmdline)
		set tmake(cmdline) configure
	}

	use getopt config

	# Core implementation simply removes files
	# Project or rulebase can override this
	alias delete-orphan-files file delete

	set rulebase [get-rulebase]

	lassign [invoke-spec-file {*}$rulebase] rc msg opts
	dputs T "Parsed [lindex $rulebase 0]"

	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed rulebase"

	rulebase-invoke init

	dputs T "Initialised rulebase"

	# Save the global state in case we need to reload
	# At this stage it includes defaults, options and the rulebase

	set tmake_save $tmake

	load-build-description 1

	dputs T "Parsing phase complete"
	set tmake(parsedone) 1

	if {$tmake(showrules)} {
		show-all-rules
		tmake-exit 0
	}
	if {$tmake(showvars)} {
		show-all-defines
		tmake-exit 0
	}
	if {$tmake(showaliases)} {
		show-all-aliases
		tmake-exit 0
	}
	if {[info exists tmake(listtargets)]} {
		show-all-targets $tmake(listtargets)
		tmake-exit 0
	}
	if {[info exists tmake(listcommands)]} {
		show-all-commands
		tmake-exit 0
	}
	if {[info exists tmake(findtarget)]} {
		show-find-results $tmake(findtarget) $tmake(findall)
		tmake-exit 0
	}

	# Targets are relative to the local dir, $tmake(subdir),
	# unless prefixed with / in which case they are global.
	if {[llength $tmake(cmdline)]} {
		foreach arg $tmake(cmdline) {
			if {[regexp {//(.*)} $arg -> realtarget] || [regexp {^/(.*)} $arg -> realtarget]} {
				lappend targets $realtarget
			} else {
				lappend targets [file-join $tmake(subdir) $arg]
			}
		}
	} else {
		lappend targets [file-join $tmake(subdir) $tmake(defaulttarget)]
	}

	# Finally we can begin building the specified targets.
	# Build each target, resetting the status and possibly reloading every time
	while {[llength $targets] && $tmake(exitcode) == 0} {
		set targets [lassign $targets target]

		set tmake(addtargets) {}

		if {$target in $tmake(clean-targets)} {
			set tmake(cleaning) 1
		} else {
			# Try to build all Load files
			# If any files specified to Load are targets,
			# build them before anything else
			# Note that these targets ignore --force
			set reload 0
			set tmake(ignoreforce) 1
			foreach {t nocare} $tmake(projfiles) {
				if {$nocare && ![is-target? $t]} {
					dputs-n "Load --nocare $t, not a target"
					continue
				}
				set status [build-sync $t]
				if {$status eq "failed"} {
					if {$tmake(exitcode) == 0} {
						build-error "Error: Don't know how to build $t"
						tmake-exit 1
					}
					break
				}
				if {$status eq "built"} {
					dputs m "$t has changed, reloading..."
					set reload 1
				}
			}
			set tmake(ignoreforce) 0

			if {$reload} {
				# Restore the state
				set tmake $tmake_save
				tmake-reset-defines

				# reinitialise the rulebase
				rulebase-invoke init

				dputs T "Reinitialised rulebase"

				load-build-description 0

				dputs T "Reparsing phase complete"
			}

			# Discard orphans before building any non-cleaning target
			do-delete-orphans [get-orphan-targets]
		}

		dputs {b T} "Building target $target"

		set status [build-sync $target]
		if {$status eq "failed"} {
			if {$tmake(exitcode) == 0} {
				build-error "Error: Don't know how to build $target"
			}
			if {$tmake(quickstop)} {
				wait-for-background-jobs
				tmake-exit $tmake(exitcode)
			}
			break
		}

		if {$tmake(cleaning) || $tmake(resetstatus)} {
			# Reset the status of every rule to "unknown" after cleaning or if reset-target-status was called
			set tmake(cleaning) 0
			set tmake(resetstatus) 0
			foreach ruletarget [dict keys $tmake(rules)] {
				set-rule-status $ruletarget unknown
			}
		}

		# Add any new targets to the target list
		# These are added before current targets, so 
		set addtargets {}
		foreach new $tmake(addtargets) {
			if {$new ni $targets && $new ni $addtargets} {
				dputs m "$target has added new build target $new"
				lappend addtargets $new
			}
		}
		set targets [list {*}$addtargets {*}$targets]
	}
}

proc rulebase-invoke {cmd} {
	dputs m "No rulebase-invoke, ignoring $cmd"
}

proc get-rulebase {} {
	global tmake
	if {[file exists rulebase.spec]} {
		return rulebase.spec
	} elseif {$tmake(installed)} {
		return [list rulebase.builtin $tmake(defaultrulebase)]
	} else {
		return [list $tmake(dir)/rulebase.default]
	}
}

# Add the given targets to the list of targets that need to be built
proc add-build-targets {args} {
	global tmake
	lappend tmake(addtargets) {*}$args
}

# If files have been manually changed (e.g. in a phony rule),
# reset-target-status causes the status of all targets to be reset
# to unknown for any new build targets added with add-build-targets
proc reset-target-status {} {
	global tmake
	set tmake(resetstatus) 1
}

proc add-project-file {filename nocare} {
	global tmake
	lappend tmake(projfiles) $filename $nocare
}

# @add-clean-targets target...
#
# Adds the targets to list of those considered to be "cleaning" targets.
# i.e. Those that don't need to force projfiles to be loaded
proc add-clean-targets {args} {
	global tmake
	lappend tmake(clean-targets) {*}$args
}

# @set-default-target target
#
# Sets the default target, when tmake is invoked with no options.
# The default is 'all'
proc set-default-target {target} {
	global tmake
	set tmake(defaulttarget) $target
}

proc load-cache {} {
	global tmake

	if {[file exists $tmake(topbuilddir)/.makecache]} {
		global tmake tmakecache
		try {
			lassign [time {source $tmake(topbuilddir)/.makecache}] us
			dputs C "Loaded cache, .makecache in [expr {($us + 500) / 1000}]ms"
			if {$tmakecache(version) != $tmake(cacheversion)} {
				user-notice cyan ".makecache is out-of-date -- ignoring"
				set tmakecache $tmake(emptycache)
				# But overwrite the cache next time around
				set tmakecache(writecache) 1
			}
		} on error msg {
			dputs C "Cached failed to load, starting with empty cache"
			set tmakecache $tmake(emptycache)
			# But overwrite the cache next time around
			set tmakecache(writecache) 1
		}
	} else {
		dputs C "Missing cache, starting with empty cache"
	}
}

proc mark-cache-dirty {msg} {
	global tmakecache
	if {$tmakecache(writecache) == 0} {
		dputs C "$msg, marking cache dirty"
		set tmakecache(writecache) 1
	}
}

proc write-cache {} {
	global tmake tmakecache
	if {$tmakecache(writecache)} {
		set tmakecache(version) $tmake(cacheversion)
		unset tmakecache(writecache)
		lassign [time {
			set f [open $tmake(topbuilddir)/.makecache w]
			foreach i [dict keys $tmakecache] {
				puts $f [list set tmakecache($i) $tmakecache($i)]
			}
			close $f
		}] us
		dputs C "Wrote cache, .makecache in [expr {($us + 500) / 1000}]ms"
	} else {
		dputs C "Cache unchanged, not writing"
	}
}

proc load-build-description {loadcache} {
	global tmake tmakecache

	lassign [invoke-spec-file project.spec] rc msg opts

	# ifconfig returns code 20 to skip some or all of the file
	if {[info return $rc] ni {ok return 20}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed project.spec"

	# Note that these are global, not per-directory, so fetch the values now
	set tmake(maxjobs) [get-define MAXJOBS [get-num-cpus]]
	dputs m "Setting maxjobs=$tmake(maxjobs)"
	set tmake(sepjobio) [get-define SEPJOBIO 1]

	# Loaded in the global scope 

	foreach i $tmake(deferred) {
		uplevel #0 $i
	}

	# Now load the cache if it exists and it isn't the second time through
	if {$loadcache} {
		load-cache

		if {!$tmake(checkexternalcmds) && [dict size $tmakecache(exec)]} {
			# If disabled, discard any previously cached external command info
			dict set tmakecache exec {}
			mark-cache-dirty "external cmd cache discarded"
		}
	}

	set tmake(loadedprojectspec) 1

	process-build-spec-file . 1

	unset tmake(prefix)
	unset tmake(localdir)

	# Now validate that there is no non-phony target which depends on a phony target
	foreach ruletarget [dict keys $::tmake(rules)] {
		if {![get-rule-attr $ruletarget phony]} {
			foreach dep [get-rule-attr $ruletarget depends] {
				if {[is-target? $dep]} {
					if {[dict get [get-target-rule $dep] phony]} {
						user-notice purple "Non phony target $ruletarget [make-source-location $ruletarget @] depends on phony $dep"
						tmake-exit 1
					}
				}
			}
		}
	}
}

proc is-cleaning? {} {
	return $::tmake(cleaning)
}

# ==================================================================
# .spec file processing
# ==================================================================

# Returns "" if project top not found
proc find-project-top {} {
	set topdir [pwd]
	while {![file exists $topdir/project.spec]} {
		set parent [file dirname $topdir]
		if {$topdir eq $parent} {
			dputs m "Project top not found"
			return ""
		}
		set topdir $parent
	}
	dputs m "Project top found at $topdir"
	return $topdir
}

proc local-prefix {} {
	if {![exists ::tmake(prefix)]} {
		error "local-prefix invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(prefix)
}

proc local-src-prefix {} {
	return $::tmake(topsrcdir)/$::tmake(prefix)
}

proc local-dir {} {
	if {![exists ::tmake(localdir)]} {
		error "local-dir invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(localdir)
}

proc top-src-dir {} {
	return $::tmake(topsrcdir)
}

proc make-local {args} {
	prefix [local-prefix] $args
}

proc make-local-dirs {args} {
	lmap dir $args {
		file-join [local-dir] $dir
	}
}

# Reverses make-local
proc make-unlocal {args} {
	set striplen [string length [local-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

# Reverses make-local-src
proc make-unlocal-src {args} {
	set striplen [string length [local-src-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

proc make-prefix {dir} {
	if {$dir eq "."} {
		return ""
	} else {
		return $dir/
	}
}

proc make-local-src {args} {
	prefix [local-src-prefix] $args
}

# @invoke-spec-file filename ?script?
#
# Returns a list of rc msg opts, as returned from run-do
proc invoke-spec-file {filename args} {
	global tmake

	lappend tmake(specfiles) $filename

	# If given, the argument is the contents of the file
	if {[llength $args]} {
		set cmd [list eval-source [lindex $args 0] $filename 1]
	} else {
		set cmd [list source $filename]
	}

	# Spec files are loaded at frame level #1, in the scope of run-do
	# 'define' relies on this
	set result [uplevel #0 [list run-do {} $cmd]]

	if {[info return [lindex $result 0]] ni {ok return 20}} {
		# If there is an error, ensure the 'Entering directory' message
		# is shown first
		enter-new-dir $tmake(topsrcdir)
	}

	if {[check-signal]} {
		tmake-exit 1
	}
	return $result
}

# @AutoSubDirs on|off
#
# If enabled (it is enabled by default), subdirectories containing
# build.spec files are automatically entered.
#
# If not enabled, SubDirs must be used to specifically select project subdirs.
proc AutoSubDirs {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(autosubdirs) 1
		}
		off {
			set ::tmake(autosubdirs) 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

# @SubDirs dir ...
#
# If AutoSubDirs is set to off, SubDirs may be used to identify which directories
# are entered.
#
# Can be used in any directory, but directory names are relative to the project top.
proc SubDirs {args} {
	foreach dir $args {
		if {![file exists $dir/build.spec]} {
			parse-error "Subdirs: No $dir/build.spec found"
		}
	}
	lappend ::tmake(subdirs) {*}$args
}

# @CheckExternalCommands on|off
#
# Normally disabled, it may be enabled in project.spec
# If enabled, external commands run with 'run' are checked
# (by path, mtime and size), and if the command changes, the corresponding target is rebuilt.
#
# Note that 'distclean' should be run if enabling this in an already-built project
proc CheckExternalCommands {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(checkexternalcmds) 1
		}
		off {
			set ::tmake(checkexternalcmds) 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

proc file-build {path} {
	if {[string match <* $path]} {
		# Special <lib>, <bin>, etc. are already build paths
		# XXX But are all aliases build paths?
		return $path
	} else {
		#puts "$::tmake(build) + $path => [file-join $::tmake(build) $path]"
		return [file-join $::tmake(build) $path]
	}
}

proc file-build-list {paths} {
	lmap p $paths { file-build $p }
}

proc build-prefix {} {
	make-prefix $::tmake(build)
}

proc build-dir {} {
	return $::tmake(build)
}

proc file-build-exists {path} {
	file exists [file-build $path]
}

# If $srcdir is a dir from the top of the source tree,
# (defaults to [local-dir])
# return a relative path to $buildpath from the build tree.
#
proc file-build-relative {buildpath {srcdir {}}} {
	if {$srcdir eq ""} {
		set srcdir [local-dir]
	}
	if {$srcdir eq $buildpath} {
		return .
	}
	set build [file join $::tmake(topbuilddir) $buildpath]
	set src [file join $::tmake(topsrcdir) $srcdir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file mkdir [file dirname $src]
	relative-path $build $src
}

# If $builddir is a dir from the top of the build tree,
# (defaults to [local-dir])
# return a relative path to $srcpath from the build tree.
#
proc file-src-relative {srcpath {builddir {}}} {
	if {$builddir eq ""} {
		set builddir [local-dir]
	}
	set there [file join $::tmake(topsrcdir) $srcpath]
	set here [file join $::tmake(topbuilddir) $builddir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file mkdir [file dirname $here]
	relative-path $there $here
}

# Restore all defines as local variables in stack frame #1
proc tmake-reset-defines {} {
	uplevel #1 {
		unset {*}[info vars]
		dict with ::tmake(defines) {}
	}
}

proc Scope {script} {
	global tmake
	# Save all defines
	set defines $tmake(defines)
	uplevel 1 $script
	set tmake(defines) $defines
	# Now need to reset/restore all the variables at frame #1
	tmake-reset-defines
}


# Read in the given spec file in the given directory (relative to topdir)
# Returns 1 if OK, or 0 if subdirs should be skipped
proc process-build-spec-file {dir {optional 0}} {
	global tmake
	dputs m "process-build-spec $dir"
	set ignore 0

	set tmake(localdir) $dir
	set tmake(prefix) [make-prefix $dir]

	set path [file-join $dir build.spec]

	if {![file exists $path]} {
		# The top level build.spec is optional
		if {!$optional} {
			user-error "$path does not exist"
		}
		incr ignore
	}

	Scope {
		rulebase-invoke prolog
		if {$ignore} {
			set rc 0
		} else {
			lassign [invoke-spec-file $path] rc msg opts

			dputs T "Parsed [local-prefix]build.spec"
		}
		rulebase-invoke epilog
	}


	if {$rc == 20} {
		dputs m "Skipping $path"
		return
	}
	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	# Now subdirectories
	incr tmake(depth)

	# Find the explicitly set subdirs
	set subdirs $tmake(subdirs)
	set tmake(subdirs) {}

	# Normally we search for dirs containing build.spec
	if {$tmake(autosubdirs)} {
		foreach d [readdir $dir] {
			if {[file exists $dir/$d/build.spec] && $d ni $subdirs} {
				lappend subdirs [file-join $dir $d]
			}
		}
	}

	# Now process subdirs
	foreach d $subdirs {
		process-build-spec-file $d
	}
	incr tmake(depth) -1
}

proc do-delete-orphans {orphans} {
	if {[llength $orphans]} {
		delete-orphan-files {*}[file-build-list $orphans]
		note Clean removing [llength $orphans] orphan target(s)
		dputs C $orphans
		discard-orphan-targets
	}
}

# Returns a list of all files which were once a target but are no longer
proc get-orphan-targets {} {
	global tmakecache

	set result {}
	foreach i [dict keys $tmakecache(file)] {
		if {![is-target? $i]} {
			lappend result $i
		}
	}
	return $result
}

proc discard-orphan-targets {} {
	global tmake tmakecache
	set discard 0

	foreach i [get-orphan-targets] {
		#puts "Discarding orphan file $i"
		dict unset tmakecache(file) $i
		set discard 1
	}

	# Also discard the build commands, targets and dependencies
	foreach i [dict keys $tmakecache(cmd)] {
		if {![is-rule? $i]} {
			#puts "Discarding orphan rule $i"
			dict unset tmakecache(cmd) $i
			set discard 1
			foreach j $i {
				#puts "Discarding orphan target and deps $j"
				dict unset tmakecache(targets) $j
				dict unset tmakecache(deps) $j
				dict unset tmakecache(exec) $j
			}
		}
	}
	if {$discard} {
		mark-cache-dirty "discarded orphan targets"
	}
}

# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	if {$::tmake(installed)} {
		return
	}
	foreach m $args {
		if {[dict exists $::tmake(modules) $m]} {
			continue
		}
		dict set ::tmake(modules) $m 1

		set source $::tmake(dir)/lib/${m}.tcl
		if {![file exists $source]} {
			parse-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		if {[info procs init-$m] ne {}} {
			init-$m
		}
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {{col lred} msg} {
	puts stderr [colerr $col "Error: $msg"]
	puts stderr "Try: 'tmake --help' for options"
	tmake-exit 1
}

# @build-error msg
#
# Indicate that something failed to build and set exitcode=1
proc build-error {{col lred} msg} {
	if {$msg eq ""} {
		set msg "-- no message --"
	}
	dputs b "BUILD ERROR: $msg"
	puts stderr [colerr $col $msg]
	stderr flush
	set ::tmake(exitcode) 1
}

# @build-fatal-error msg
#
# Indicate that something failed to build and exit with exitcode=1
proc build-fatal-error {msg} {
	dputs b "BUILD FATAL ERROR: $msg"
	puts stderr [colerr lred $msg]
	stderr flush
	tmake-exit 1
}


# @user-notice msg
#
# Output the given message to stderr, possibly with the given colour.
#
proc user-notice {{col {}} msg} {
	if {$col eq {}} {
		puts stderr $msg
	} else {
		puts stderr [colerr $col $msg]
	}
}

# Incorrect usage in the build.spec file. Identify the location.
proc parse-error {msg} {
	global tmake
	# Message may contain a source reference relative to the top source dir
	enter-new-dir $tmake(topsrcdir)

	user-notice lred [error-location "Error: $msg"]
	tmake-exit 1
}

proc parse-warning {msg} {
	user-notice purple [warning-location "Warning: $msg"]
}

proc wait-for-background-jobs {} {
	global tmake
	if {$tmake(jobpid)} {
		while {[wait-for-one-job] != 0} {
			dputs j "Waiting for background jobs to finish"
		}
	}
}

proc tmake-exit {code {msg {}}} {
	global tmake

	if {$tmake(jobpid) == 0} {
		exit $code
	}

	if 0 {
		if {$code != $tmake(exitcode)} {
			puts "Got tmake-exit $code, but exitcode=$tmake(exitcode)"
		}
	}

	wait-for-background-jobs
	if {$msg ne ""} {
		user-notice lred $msg
	}

	if 0 {
		# Kill off any running jobs
		foreach pid [dict keys $tmake(running)] {
			dputs j "[pid] Killing background child $pid"
			catch {kill $pid}
		}

		wait-for-background-jobs
	}

	# Write the cache before exiting
	write-cache

	dputs T Done
	exit $code
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		pputs cyan $msg
	}
}

proc pputs {{col {}} msg} {
	if {$col eq {}} {
		puts $msg
	} else {
		puts [colout $col $msg]
	}
	flush stdout
}

# Returns 1 if any of the debug types is set
proc debug-is-set {types} {
	foreach t $types {
		if {[dict get $::tmake(debugtypes) $t]} {
			return 1
		}
	}
	return 0
}

# Output a message to stdout if --debug is set.
#
proc dputs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		pputs "[colout purple [dbg-msg-indent $indent]] \[$types\] [colout yellow $msg]"
	}
}

proc dputs-null {args} {}

# Like dputs, but msg needs to be expanded with subst
# This is used for messages which may be expensive to evaluate
proc dputxs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		dputs $types [uplevel 1 [list subst $msg]]
	}
}

proc dbg-msg-indent {{autoindent 1}} {
	global tmake

	set now [clock millis]
	if {$tmake(showdelta)} {
		set time [expr {$now - $tmake(prevtime)}]
		set tmake(prevtime) $now
	} else {
		set time [expr {$now - $tmake(start)}]
	}
	if {$autoindent && [debug-is-set G]} {
		set indent [string repeat "    " [llength $::tmake(current)]]
	} else {
		set indent {}
	}
	return [format %5dms $time]$indent
}

# ==================================================================
# Show rules, targets, aliases, etc.
# ==================================================================

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	# Note that we don't want to lose source info for $do, so
	# go to special effort to make a copy first
	set docmd [string cat $do ""]
	set lines [split $docmd \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set ruletarget [get-rule-target $target]
	} else {
		set ruletarget $target
	}
	if {[is-rule? $ruletarget]} {
		set t [get-rule $ruletarget]
		set flags {}
		set lines {}
		puts [pad "-- $ruletarget " 60 -]--
		foreach n [lsort [dict keys $t]] {
			set v $t($n)
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				phony - nofail - chdir - nocache - fatal - slow {
					if {$v} {
						lappend flags $n
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vv"
					}
				}
				onerror - finally {
					if {$v ne ""} {
						lappend lines "$n={[join [split [string trim $v] \n] {;}]}"
					}
				}
				alias {
					if {$v ne ""} {
						lappend lines "$n=$v"
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
				}
			}
		}
		if {[llength $flags]} {
			set flags " \[$flags\]"
		}
		puts "$t(target)$flags: $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		foreach do $t(do) {
			show-rule-commands $do
		}
	} else {
		puts "No rule for $ruletarget"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(rules)]] {
		show-rule $i
		puts ""
	}
}

proc show-cache {} {
	global tmake

	if {![file exists $tmake(topbuilddir)/.makecache]} {
		user-notice purple "No .makecache"
		return
	}
	set tmakecache $tmake(emptycache)
	source $tmake(topbuilddir)/.makecache

	# Files
	puts "File times (V=virtual mtime, M=mtime)"
	puts "-------------------------------------"

	foreach i [lsort [dict keys $tmakecache(file)]] {
		lassign [dict get $tmakecache(file) $i] vmtime mtime
		if {$mtime == $vmtime} {
			set mtimestr "(same)"
		} else {
			set mtimestr [clock format $mtime -format "%H:%M:%S %d-%b-%Y"]
		}
		puts [format "%25s  V=%s  M=%s" $i [clock format $vmtime -format "%H:%M:%S %d-%b-%Y"] $mtimestr]
	}
	puts ""

	puts "Commands used to build targets and warnings"
	puts "-------------------------------------------"
	# Commands
	foreach i [lsort [dict keys $tmakecache(cmd)]] {
		puts $i:
		foreach do [dict get $tmakecache(cmd) $i] {
			show-rule-commands $do
		}
		if {[dict exists $tmakecache(warnings) $i]} {
			set warnings [dict get $tmakecache(warnings) $i]
			if {[llength $warnings]} {
				foreach msg $warnings {
					pputs grey $msg
				}
			}
		}
		puts ""
	}
}

proc show-all-targets {detailed} {
	set shown 0
	foreach i [lsort [dict keys $::tmake(targets)]] {
		if {$detailed eq ""} {
			if {![dict get [get-target-rule $i] phony]} {
				incr shown
				puts $i
			}
		} else {
			puts "$i @[make-source-location $i]"
		}
	}
	if {$shown == 0 && $detailed eq ""} {
		puts "Note: All targets are phony. Use --targets=all to show all targets"
	}
}

proc show-all-commands {} {
	global tmake

	foreach info $tmake(commands-overview) {
		lassign $info loc helptext
		set lines [split [string trim $helptext] \n]
		set lines [string trim [join $lines \n]]
		pputs $lines
		pputs [string repeat - 60]
	}

	set commands $tmake(commands)
	foreach cmd [lsort [dict keys $commands]] {
		lassign $commands($cmd) loc helptext
		set otherlines [lassign [split [string trim $helptext] \n] firstline]
		set otherlines [string trim [join $otherlines \n]]
		regexp {^([^ ]*) +(.*)$} $firstline -> cmdname cmdargs
		pputs "\n[colout purple $cmdname] [colout yellow $cmdargs]"
		pputs \n$otherlines
		#puts [string repeat - 60]
	}
}

proc show-find-results {findtarget findall} {
	global tmake
	if {!$findall} {
		# Prefer a local exact match
		foreach try [list [file-join $tmake(subdir) $findtarget] $findtarget] {
			if {[is-target? $try]} {
				dputs r "find: Found exact match for $try"
				show-rule $try
				# Are there any non-exact matches?
				set count 0
				foreach target [dict keys $tmake(targets)] {
					if {[string match *$findtarget* $target]} {
						incr count
					}
				}
				if {$count > 1} {
					incr count -1
					pputs cyan "Note: $count non-exact matches also exist, use --findall to show them"
				}
				tmake-exit 0
			}
		}
	}
	dputs r "find: Showing all targets that match *$findtarget*"
	foreach target [lsort [dict keys $tmake(targets)]] {
		if {[string match *$findtarget* $target]} {
			show-rule $target
			pputs ""
		}
	}
}

proc num-nonphony-targets {} {
	set n 0
	foreach i [dict keys $::tmake(targets)] {
		if {![dict get [get-target-rule $i] phony]} {
			incr n
		}
	}
	return $n
}

# ==================================================================
# Variable Handling
# ==================================================================

# @define name arg ...
#
# Set a variable to the given value, unless it was defined with define!
# 
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	if {![dict exists $::tmake(fixedvars) $name]} {
		if {[llength $args]} {
			set value [join $args]
		} else {
			set value 1
		}
		#dputs v "define $name $value"
		dict set ::tmake(defines) $name $value
		# Ensure that the value is visibile the current spec file
		uplevel #1 [list set $name $value]
	} else {
		dputs v "define $name => not overwriting fixed value"
	}
}

# @define! name arg ...
#
# Like 'define', but marks the variable as fixed. It won't be overwritten by 'define'.
#
proc define! {name args} {
	set value [join $args]
	dputs v "define! $name $value"
	dict set ::tmake(fixedvars) $name 1
	dict set ::tmake(defines) $name $value
	uplevel #1 [list set $name $value]
}

# @define? name arg ...
#
# Like 'define', but only sets the variable if it is undefined
# or set to an empty value.
#
proc define? {name args} {
	global $name
	dputs v "define? $name $args"
	if {[get-define $name] eq ""} {
		define $name {*}$args
	}
}

# @define-append name arg ...
#
# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	dputs v "define-append $name $args"
	set value [get-define $name]
	append-with-space value [join $args]
	define $name $value
}

# @get-define name ?default?
#
# Returns the current value of the given defined variable, or $default
# if not set. If not specified, $default is ""
#
proc get-define {name {default ""}} {
	if {$::tmake(parsedone)} {
		build-fatal-error "get-define $name called during build phase"
	}
	if {[dict exists $::tmake(defines) $name]} {
		#dputs v "get-define $name => [dict get $::tmake(defines) $name]"
		dict get $::tmake(defines) $name
	} else {
		#dputs v "get-define $name => default ($default)"
		return $default
	}
}

proc get-all-defines {} {
	return $::tmake(defines)
}

proc show-all-defines {} {
	set d [get-all-defines]
	foreach k [lsort [dict keys $d]] {
		puts "$k=[dict get $d $k]"
	}
}

proc show-all-aliases {} {
	set d $::tmake(aliases)
	foreach k [lsort [dict keys $d]] {
		puts "$k=[dict get $d $k]"
	}
}

proc define-exists {name} {
	dict exists $::tmake(defines) $name
}


# ==================================================================
# Rule Handling
# ==================================================================

# If $target is an alias, return the aliased target
# Otherwise return $target
proc map-alias {target} {
	if {[dict exists $::tmake(aliases) $target]} {
		set target [dict get $::tmake(aliases) $target]
	}
	return $target
}

# Returns 1 if the target is an individual target
proc is-target? {target} {
	dict exists $::tmake(targets) [map-alias $target]
}

# Returns 1 if the target is a rule target
proc is-rule? {ruletarget} {
	dict exists $::tmake(rules) $ruletarget
}

# Converts a target to the rule target
proc get-rule-target {target} {
	dict get $::tmake(targets) [map-alias $target]
}

# Returns the rule for an individual target
proc get-target-rule {target} {
	dict get $::tmake(rules) [dict get $::tmake(targets) [map-alias $target]]
}

# Returns the rule for a rule target
proc get-rule {ruletarget} {
	dict get $::tmake(rules) $ruletarget
}

# Returns the single attribute for the given rule target
proc get-rule-attr {ruletarget attr} {
	dict get $::tmake(rules) $ruletarget $attr
}

# Like get-rule, but temporarily zaps the current rule.
# Makes it faster when updating the rule
proc take-rule {ruletarget} {
	set rule [dict get $::tmake(rules) $ruletarget]
	dict set ::tmake(rules) $ruletarget {}
	return $rule
}

proc update-rule {ruledict} {
	set ruletarget [dict get $ruledict target]
	if {![is-rule? $ruletarget]} {
		# Haven't seen this rule before so individual target pointers
		foreach t $ruletarget {
			if {[dict exists $::tmake(targets) $t]} {
				parse-error "Rule for $t was already specified [make-source-location $t @]"
			}
			dict set ::tmake(targets) $t $ruletarget
		}
		set-rule-status $ruletarget unknown
	}
	set alias [dict get $ruledict alias]
	if {$alias ne ""} {
		dict set ::tmake(aliases) $alias [lindex $ruletarget 0]
	}

	dict set ::tmake(rules) $ruletarget $ruledict
}

proc set-rule-status {ruletarget status} {
	dict set ::tmake(rulestatus) $ruletarget $status
}

proc get-rule-status {ruletarget} {
	dict get $::tmake(rulestatus) $ruletarget
}

proc show-this-rule {args} {
	if {[debug-is-set p]} {
		global tmake
		set extra ""
		set where "[find-source-location] "
		if {$where eq "unknown "} {
			set where ""
		}
		# We wan't to include any default options
		set ruleargs [lassign [info level -1] rule]
		if {[dict exists $tmake(ruledefaultopts) $rule]} {
			set ruleargs [list \[[dict get $tmake(ruledefaultopts) $rule]\] {*}$ruleargs]
		}
		lappend ruleargs {*}$args
		dputs p "$where$rule [join $ruleargs]" 0
	}
}

proc make-source-location {ruletarget {prefix {}} {suffix {}}} {
	if {[is-rule? $ruletarget]} {
		set source [get-rule-attr $ruletarget source]
	} else {
		set source [dict get [get-target-rule $ruletarget] source]
	}

	if {$source eq "unknown"} {
		return ""
	}
	return $prefix[join $source ", "]$suffix
}

# Defines a high level command.
proc rule {cmdname arglist {helptext {}} body} {
	global tmake
	if {[dict exists $tmake(commands) $cmdname]} {
		lassign [dict get $tmake(commands) $cmdname] loc help
		parse-error "Command $cmdname already defined @$loc"
	}
	if {$helptext eq ""} {
		user-notice purple "[join [info source $cmdname] :]:Warning: rule $cmdname has no help"
	}
	dict set tmake(commands) $cmdname [list [info source $cmdname] $helptext]
	proc $cmdname $arglist $body
}

# Should be called as the very first command in a rule that supports default option setting.
# Prepends any options given with set-default-opts
#
# 
proc add-default-opts {&arglist} {
	global tmake
	set rule [lindex [info level -1] 0]
	if {[dict exists $tmake(ruledefaultopts) $rule]} {
		# Prepend any default options to the arglist
		set arglist [list {*}[dict get $tmake(ruledefaultopts) $rule] {*}$arglist]
	}
}

# Sets default options, to be prepended to the given rule
proc set-default-opts {rule options} {
	dict set ::tmake(ruledefaultopts) $rule $options
}

proc rule-overview {text} {
	global tmake
	lappend tmake(commands-overview) [list [info source $text] $text]
}

proc add-deferred-action {action} {
	global tmake
	lappend tmake(deferred) $action
}

# Create a target dependency
#
# Parses the arguments and adds them to the rule base
#
proc target {ruletarget args} {
	# If the rule aready exists, we are updating
	if {[is-rule? $ruletarget]} {
		# Use take-rule here for efficiency
		set orig [take-rule $ruletarget]
	} elseif {[is-target? $ruletarget]} {
		# Can't update a rule via the invidual target
		set source [dict get [get-target-rule $ruletarget] source]
		parse-error "A multiple-target rule for $ruletarget was already specified at $source"
	}

	set info [parse-rule $ruletarget $args]

	#dputs p "target $ruletarget @ $info(source)"

	#show-this-rule

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	# Cache the prefix with the rule, also
	set info(local) [local-dir]

	if {![info exists orig]} {
		# Now create/update the rule
		update-rule $info
		return $ruletarget
	} else {
		set identical 1
		foreach i {chdir depends do dyndep inputs local msg nocache nofail onerror finally phony target vars fatal slow} {
			if {$info($i) ne $orig($i)} {
				set identical 0
				break
			}
		}
		if {$identical} {
			parse-warning "$ruletarget duplicate rule ignored at  $orig(source)"
			update-rule $orig
			return $ruletarget
		}
	}

	# There is already a rule for this target, so attempt
	# to merge the two rules
	# Note: We generally want the new values to come after the existing values, so
	# merge the new data into orig

	if {[llength $info(do)] && [llength $orig(do)]} {
		#parse-error "$ruletarget already has '-do' at $orig(source)"
		if {$info(do) ne $orig(do)} {
			parse-warning "$ruletarget already has '-do' at $orig(source)"
		}
		set info(do) {}
	}
	if {$info(dyndep) ne "" && $orig(dyndep) ne ""} {
		if {$info(dyndep) eq $orig(dyndep)} {
			set info(dyndep) ""
		} else {
			parse-error "$ruletarget already has '-dyndep' at $orig(source)"
		}
	}
	lappend orig(depends) {*}$info(depends)
	lappend orig(inputs) {*}$info(inputs)
	incr orig(phony) $info(phony)
	incr orig(nofail) $info(nofail)
	incr orig(chdir) $info(chdir)
	incr orig(nocache) $info(nocache)
	incr orig(fatal) $info(fatal)
	incr orig(slow) $info(slow)
	append-with-space orig(onerror) $info(onerror) \n
	append-with-space orig(finally) $info(finally) \n
	# Only one of these will be non-blank
	lappend orig(do) {*}$info(add-do)
	append-with-space orig(dyndep) $info(dyndep) \n

	if {$info(source) eq "unknown" || $info(source) in $orig(source)} {
		# Nothing to do
	} elseif {$info(source) ne "unknown"} {
		lappend orig(source) $info(source)
	}

	# Need to append to any vars which exist
	set orig(vars) [merge-vars $orig(vars) $info(vars)]

	# Whichever rule has '-do' also specifies '-inputs' and '-msg'
	if {[llength $orig(do)] == 0} {
		set orig(do) $info(do)
		set orig(inputs) $info(inputs)
		set orig(msg) $info(msg)
	}
	update-rule $orig

	# Return the rule target for composability
	return $ruletarget
}

# Adds the list elements to the target-specific variable.
#
# This a much faster equivalent of:
#
#     target $ruletarget -vars $varname {*}$list
#
proc target-add-var {ruletarget varname list} {
	# The rule must already exist
	if {![is-rule? $ruletarget]} {
		parse-error "$ruletarget is not a rule target"
	}
	# Note that if we do this blindly, we will duplicate the dict
	# Instead, get the current value. Replace it.
	# lappend.
	# Update it
	set vars [dict get $::tmake(rules) $ruletarget vars $varname]
	dict set ::tmake(rules) $ruletarget vars $varname {}
	lappend vars {*}$list
	dict set ::tmake(rules) $ruletarget vars $varname $vars
}

proc parse-rule-args {arglist} {
	set info {}

	set opt {}
	set skip 1
	set n 0
	foreach arg $arglist {
		if {($n % $skip == 0) && [string match -* $arg]} {
			# Remove the leading dash
			set opt [string range $arg 1 end]
			if {![exists info($opt)]} {
				set info($opt) {}
			}
			set n 0
			set skip 1
			if {$opt eq "vars"} {
				set skip 2
			}
			continue
		}
		if {$opt eq ""} {
			parse-error "Missing option: $arglist"
		}
		lappend info($opt) $arg
		incr n
	}
	return $info
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-rule {target arglist} {
	set info {
		inputs {} depends {} do {} onerror {} finally {} msg {} vars {} dyndep {} add-do {} alias {}
		add 0 nofail 0 phony 0 chdir 0 nocache 0 fatal 0 slow 0
	}

	set info(source) [find-source-location *build.spec]
	if {$info(source) eq "unknown"} {
		set info(source) [find-source-location *.spec]
		if {$info(source) eq "unknown"} {
			set info(source) [find-source-location *.default]
		}
	}
	set info(target) $target

	# split the arglist into a dictionary
	set arginfo [parse-rule-args $arglist]

	# And check/post-process the options
	foreach {opt optargs} $arginfo {
		switch -exact -- $opt {
			phony - nofail - add - chdir - nocache - fatal - slow {
				if {[llength $optargs]} {
					parse-error "Rule for $target has non-option parameters after -$opt: $optargs"
				}
				set info($opt) 1
			}
			inputs - depends {
				set info($opt) [join $optargs]
			}
			msg {
				# last one wins
				set info($opt) [lindex $optargs end]
			}
			do - dyndep - onerror - finally - alias {
				if {[llength $optargs] > 1} {
					parse-error "Rule for $target has more than one '-$opt' parameter"
				}
				if {$opt eq "do"} {
					set info($opt) $optargs
				} else {
					set info($opt) [lindex $optargs 0]
				}
			}
			vars {
				if {[llength $optargs] % 2} {
					parse-error "Rule for $target has an odd number of parameters to '-vars'"
				}
				# Need to use lappend here so that they are combined with getvars
				lappend info($opt) {*}$optargs
			}
			getvars {
				foreach v $optargs {
					if {![define-exists $v]} {
						parse-error "Rule for $target has -getvars for non-existent variable: $v"
					}
					lappend info(vars) $v [get-define $v]
				}
			}
			default {
				parse-error "Rule for $target has unknown option: -$opt"
			}
		}
	}

	if {$info(add)} {
		if {![llength $info(do)]} {
			parse-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) $info(do)
		set info(do) {}
	}
	unset info(add)

	if {[llength $info(do)] == 0 && [llength $info(inputs)]} {
		parse-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {[llength $info(do)] == 0 && $info(msg) ne ""} {
		parse-error "Rule for $target has '-msg' but no '-do'"
	}

	return $info
}

# ==================================================================
# Dependency Engine
# ==================================================================

proc file-real-mtime {filename} {
	if {[is-target? $filename]} {
		set filename [file-build [map-alias $filename]]
	}
	file mtime $filename
}

proc file-virtual-mtime {filename} {
	global tmakecache

	set mtime [file-real-mtime $filename]
	if {[dict exists $tmakecache(file) $filename]} {
		lassign [dict get $tmakecache(file) $filename] vmtime omtime
		# If the actual mtime is different from the saved mtime, we
		# ignore the cached (virtual) mtime.
		if {$omtime == $mtime} {
			# The cache is up to date, so use the virtual mtime
			set mtime $vmtime
		}
	}
	return $mtime
}

proc find-oldest-time {list name} {
	upvar $name oldestname
	lassign $list oldestname
	set oldesttime [file-virtual-mtime $oldestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-virtual-mtime $file]
			if {$t < $oldesttime} {
				set oldesttime $t
				set oldestname $file
			}
		}
	}
	#puts "find-oldest-time: $oldestname $oldesttime ($list)"
	return $oldesttime
}

proc find-newest-time {list name} {
	upvar $name newestname
	lassign $list newestname
	set newesttime [file-real-mtime $newestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-real-mtime $file]
			if {$t > $newesttime} {
				set newesttime $t
				set newestname $file
			}
		}
	}
	#puts "find-newest-time: $newestname $newesttime ($list)"
	return $newesttime
}

# Both $targets and $depends are lists of files which must exist
# If any file is $targets is older than any file in $depends, the
# targets are out of date and 1 is returned. In this case the 
# variable named $depname is set to the name of the newest
# file in $depends
# Otherwise 0 is returned.
#
proc needbuild? {targets depends depname} {
	upvar $depname newest_depends
	set depends_time [find-newest-time $depends newest_depends]
	#puts "newest depends: [clock format $depends_time] $newest_depends"
	set targets_time [find-oldest-time $targets oldest_target]
	#puts "oldest targets: [clock format $targets_time] $oldest_target"
	if {$targets_time < $depends_time} {
		dputs b "$oldest_target is older than $newest_depends, so forcing rebuild"
		return 1
	}
	dputs-n "$targets is newer than $depends, so not forcing rebuild"
	return 0
}

proc locate-files {files} {
	set result {}
	foreach f $files {
		if {[is-target? $f]} {
			#puts "$f is a target => [file-build $f]"
			# If the target is a full path, keep it
			lappend result [file-build $f]
		} else {
			#puts "$f is not a target"
			lappend result $f
		}
	}
	#puts "locate-files $files => $result"
	return $result
}

# Returns a dictionary with the bound and rule-specific variables
proc make-var-dict {info} {
	set vardict [dict get $info vars]
	dict set vardict target [file-build-list [dict get $info target]]
	dict set vardict targetname [dict get $info target]
	dict set vardict local [dict get $info local]
	dict set vardict build [file-build [dict get $info local]]
	dict set vardict depends [locate-files [dict get $info depends]]
	dict set vardict inputs [locate-files [dict get $info inputs]]
	#parray vardict
	return $vardict
}

proc add-warning-msg {msg} {
	lappend ::tmake(warningmsgs) $msg
}

proc note {type args} {
	if {$::tmake(verbose) != 1} {
		pputs "    [pad $type 12] [join $args]"
	}
}

# @tmake-require-version <version-needed>
#
# Checks the current version of tmake against that required.
# A fatal error is generated if the current version is less than that needed.
#
proc tmake-require-version {needversion} {
	use util

	global tmake
	set haveversion [lindex $tmake(version) 0]
	if {[compare-versions $haveversion $needversion] < 0} {
		build-fatal-error "tmake $needversion required, but this is $tmake(version)"
	}
}

proc fork-job-if-required {} {
	global tmake

	if {$tmake(maxjobs) > 1 && $tmake(sync) == 0 && $tmake(jobpid) == -1} {
		wait-for-job-slots
		set pid [add-new-job $tmake(currentruletarget) $tmake(currentnotifytarget) $tmake(chdir)]
		set tmake(jobpid) $pid
	}
	return $tmake(jobpid)
}

# Searches for the command '$cmd' in the path and returns a string that combines:
# - fullpath (or - if not found)
# - mtime
# - size
# Thus is the external command changes, the returned key will change.
proc stat-cmd-in-path {cmd} {
	# Dummy stat
	set stat {mtime 0 size 0 cmdpath -}
	# At this point, before forking, determine if we need to cache the external
	# command as a dependency
	foreach path [split-path] {
		set cmdpath [file join $path $cmd]
		if {[file-isexec $cmdpath]} {
			# Found in the path
			file stat $cmdpath stat
			set stat(cmdpath) $cmdpath
			break
		}
	}
	return $stat(cmdpath),$stat(mtime),$stat(size)
}

proc run {args} {
	global tmake tmakecache

	set cmdline [join $args]
	set cmd [lindex $cmdline 0]
	#puts "run: do we need to convert $cmd to a path from [pwd]?"
	# Is cmd a file in the current dir?
	if {![string match */* $cmd] && [file isfile $cmd]} {
		set cmdline ./$cmdline
	} elseif {$tmake(checkexternalcmds)} {
		# Update the cache with the details of this command
		dict set tmakecache exec $tmake(currentruletarget) $cmd [stat-cmd-in-path $cmd]
	}

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	vputs [string trim $cmdline]
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		add-warning-msg $msg
		pputs grey $msg
	}
	if {$rc} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		if {$msg ne ""} {
			build-error "$msg\n"
		}
		return -code break
	}
	# XXX: What to do on signal?
}

proc run-tmake {args} {
	global tmake

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	set cmdline [list tmake {*}$tmake(cli-options) {*}$args]

	dputs m $cmdline
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		pputs grey $msg
	}
	if {$rc == 1} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		build-error "$msg\n"
		return -code break
	}
}

proc calc-dyndeps {vardict target} {
	set t [get-rule $target]
	#puts "=============="
	#parray t

	set dyndeps {}
	if {$t(dyndep) ne ""} {
		foreach i $t(depends) {
			lassign [run-do $vardict [concat $t(dyndep) $i]] rc result opts
			if {$rc == 0} {
				lappend dyndeps {*}$result
			} else {
				return -code $rc {*}$opts $result
			}
		}
		dputs-d "Dynamic dependencies for $target: $dyndeps"
	}
	return $dyndeps
}

proc file-exists-all {list missingname} {
	foreach f $list {
		if {![file exists [file-build $f]]} {
			upvar $missingname missing
			set missing $f
			return 0
		}
	}
	return 1
}

# Run variable [subst] on the given '-do' scripts (a list of -do commabds)
# This is used to determine if the commands have changed for the target.
proc subst-do {__target __vardict __do_list} {
	# Create local vars based on $::tmake(defines) and $__vardict
	# to be used in subst
	dict with ::tmake(defines) {}
	dict with __vardict {}

	# Return a list of substituted '-do' scripts
	lmap __each_do $__do_list {
		# Force __each_do to be copied so that we don't lose source info in the original
		set __each_do [string cat $__each_do ""]
		set source [info source $__each_do]
		# Note: It is an error if the subst fails
		if {[catch {subst -nob -noc $__each_do} __result __opts]} {
			# subst failed -- most likely because a variable was referenced that didn't exist.
			tmake-exit 1 "[join $source :]:Error: $__result while building $__target"
		}
		set __result
	}
}

# Set up the defines and local vars and evaluate the script
# Returns a list of {ret msg opts stacktrace} from catch
#
proc run-do {__vardict __script} {
	if {[string length $__script] == 0} {
		# Optimisation
		return [list 0 {} {}]
	}
	dict with ::tmake(defines) {}
	dict with __vardict {}
	set result [list [catch $__script msg opts] $msg $opts]
	#puts "run-do returned $result"
	return $result
}

proc enter-new-dir {dirname} {
	global tmake
	if {$tmake(lastchdir) ne $dirname} {
		# emulate make for vim quickerr
		pputs green "tmake: Entering directory `$dirname'"
		set tmake(lastchdir) $dirname
	}
}

proc wait-for-one-job {} {
	global tmake
	while {[dict size $tmake(running)]} {
		lassign [wait -1] status pid code
		if {$pid <= 0} {
			#user-notice purple "Warning: No child processes, but tmake(running) is not empty"
			break
		}
		if {[dict exists $tmake(running) $pid]} {
			set job [dict get $tmake(running) $pid]
			dict unset tmake(running) $pid

			lassign $job ruletarget notifytarget chdir outfile errfile
			dputs j "Job $pid has finished with $status\($code) for {$ruletarget $notifytarget}"
			if {$status eq "CHILDSTATUS" && $code == 0} {
				set rc 0
			} else {
				set rc 1
			}

			# If job I/O was captured in separate files, display it now
			if {$outfile ne ""} {
				set stdmsg [readfile $outfile]
				if {$stdmsg ne ""} {
					# Remove any trailing newlines
					set stdmsg [string trimright $stdmsg \n]
					add-warning-msg $stdmsg
					enter-new-dir $chdir
					pputs grey $stdmsg
				}
				file delete $outfile
			}
			if {$errfile ne ""} {
				set errmsg [readfile $errfile]
				if {$errmsg ne ""} {
					set stdmsg [string trimright $errmsg \n]
					enter-new-dir $chdir
					if {$rc} {
						build-error $errmsg
					} else {
						pputs lred $errmsg
					}
				}
				file delete $errfile
			}

			# Set the status, update the cache, delete any files on error, etc.
			target-post-build $ruletarget $rc

			if {$rc == 0} {
				dict incr tmake(pending) $notifytarget -1
				if {[dict get $tmake(pending) $notifytarget] == 0} {
					if {[get-rule-status $notifytarget] eq "waiting"} {
						dputs j "Status of $notifytarget set to unknown"
						set-rule-status $notifytarget unknown
					}
				}
			} else {
				dputs j "Status of $notifytarget set to failed"
				set-rule-status $notifytarget failed

				if {$tmake(quickstop)} {
					tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
				}
			}
			return 1
		}
		dputs j "Ignoring unknown pid $pid"
	}
	dputs j "All jobs have finished"
	return 0
}

proc wait-for-job-slots {} {
	global tmake

	while {[dict size $tmake(running)] >= $tmake(maxjobs)} {
		dputs j "Waiting for a job slot to be available"
		wait-for-one-job
	}
}

proc add-new-job {ruletarget notifytarget chdir} {
	global tmake
	if {$tmake(sepjobio)} {
		# Capture job I/O to temporary files so that it doesn't interleave
		set fout [open [file tempfile] w]
		set ferr [open [file tempfile] w]
	} else {
		set fout ""
		set ferr ""
	}
	set pid [os.fork]
	if {$pid == 0} {
		# Turn off debugging in the child unless --debug is set to avoid confusion
		if {!$tmake(debug)} {
			foreach t [dict keys $tmake(debugtypes)] {
				dict set tmake(debugtypes) $t 0
			}
		}
		# And turn off colour output
		set tmake(colout) 0
		set tmake(colerr) 0
	}
	if {$pid > 0} {
		dputs j "Adding job $pid for $ruletarget"
		# Insert the job in the slot
		set-rule-status $ruletarget running
		if {$tmake(sepjobio)} {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir [$fout filename] [$ferr filename]]
			$fout close
			$ferr close
		} else {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir "" ""]
		}
		dict incr tmake(pending) $notifytarget
	} elseif {$tmake(sepjobio)} {
		# This is the child. Redirect stdout and stderr to temporary files.
		rename stdout ""
		rename $fout stdout
		rename stderr ""
		rename $ferr stderr
	}
	return $pid
}

# Runs [build $target] until it either fails or succeeds
proc build-sync {target} {
	while 1 {
		set status [build $target]
		if {$status in {waiting running}} {
			dputs j "Waiting for $target to complete..."
			wait-for-one-job
			continue
		}
		return $status
	}
}

proc target-post-build {ruletarget rc {msg {}} {opts {}}} {
	global tmake tmakeprecache tmakecache

	# Pick up the info from the precache

	set info $tmakeprecache($ruletarget)

	set t $info(rule)
	set target $info(target)
	set dyndeps $info(dyndeps)
	set vardict $info(vardict)

	set status built

	# These needs to be run from topsrcdir
	set savepwd [pwd]
	cd $tmake(topsrcdir)

	# Did the rule make the targets?
	if {$rc == 0 && !$t(phony) && ![is-cleaning?]} {
		set now [clock seconds]
		foreach f $ruletarget {
			if {![file exists [file-build $f]]} {
				# XXX: Should onerror run here if --quickstop is set?
				# XXX: Should the cache still be updated?
				build-error "[make-source-location $ruletarget "" ": "]Error: Rule for $target failed to build target(s) $f ([file-build $f])"
				# Use break to indicate that we have already output the message
				set rc 3
			} elseif {!$t(nocache)} {
				# Record the time that this target was created, along with the real mtime
				dict set tmakecache(file) $f [list $now [file-real-mtime $f]]
				#puts "Set cachetime of $f [clock format $now] [clock format [file-real-mtime $f]]"
				# Remember the rule which built this target
				dict set tmakecache(target) $f $ruletarget
			}
		}

		# Save the commands in the command cache and the list of dyndeps
		# and any warning messages
		dict set tmakecache(cmd) $ruletarget [subst-do $ruletarget $vardict $t(do)]
		dict set tmakecache(deps) $ruletarget [lsort $dyndeps]
		dict set tmakecache(warnings) $ruletarget $tmake(warningmsgs)
		mark-cache-dirty "Targets built"
	}

	if {$rc == 0} {
		if {!$t(phony)} {
			incr tmake(numtargets)
		}
	} else {
		# On failure, delete the target(s)
		file delete {*}$ruletarget

		# Try to run onerror
		lassign [run-do $vardict $t(onerror)] frc fmsg fopts
		if {$frc} {
			# Hmmm. Is the stack trace going to be useful if this is a background job?
			# We really want the subprocess to collect that as part of its error output
			build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		} elseif {$rc == 1} {
			if {$msg ne ""} {
				# failed background task will supply it's own error message
				build-error [error-stacktrace $msg $opts(-errorinfo)]
			}
		}
		set status failed
	}

	lassign [run-do $vardict $t(finally)] frc fmsg fopts
	if {$frc} {
		build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		set status failed
	}

	set-rule-status $ruletarget $status

	# No longer need this
	unset tmakeprecache($ruletarget)

	# Reset warnings
	set tmake(warningmsgs) {}

	cd $savepwd
}

proc build-deps {target ruletarget status depends phony &reason} {
	global tmake

	set count {
		failed 0
		waiting 0
		running 0
		built 0
		uptodate 0
	}

	foreach dep $depends {
		set ret [build $dep $ruletarget]

		if {[check-signal]} {
			tmake-exit 2 "*** Build cancelled"
		}

		incr count($ret)

		switch $ret {
			failed {
				if {$tmake(exitcode) == 0} {
					build-error "[make-source-location $ruletarget]: Error: Don't know how to build $dep: [join [lreverse $tmake(current)] { <= }]"
				}
				if {$tmake(quickstop)} {
					tmake-exit 1 "*** Error: Targets failed to build"
				}
			}
			built {
				lappend reason depend $dep
			}
		}
	}

	if {$count(running) || $count(waiting)} {
		dputs {b j} "$target has $($count(running) + $count(waiting)) outstanding jobs - waiting"
		return waiting
	}
	if {$count(failed)} {
		dputs b "$target has failed dependencies - failed"
		return failed
	}

	if {!$phony && $tmake(norun) && $count(built)} {
		# If running tmake -n, we can't rely on the actual target to be updated
		# We need to assume that the target needs updating
		dputs b "$target has built dependencies (-n) - built"
		return built
	}

	# Note that previously we returned "built" if a dependency was "built"
	# but there is no need to do this. This allows commands to run but leave targets unchanged.

	#dputs n "$target dependencies are all uptodate - $status"
	return $status
}


# ==================================================================
# build
#
# This is the workhorse of tmake.
# If possible, it builds $target, including any required dependencies
# Returns the target status (also stored as targetstatus):
#          uptodate    if nothing to do,
#          failed      if unable to be built
#          built       if built
#          waiting     if waiting for dependencies to build
#          running     if job is running in the background
# ==================================================================

proc build {target {notifytarget {}}} {
	global tmake tmakecache
	if {![is-target? $target]} {
		# Cache the result here, mostly to avoid excess messages
		if {[dict exists $tmake(targetstatus) $target]} {
			set ret [dict get $tmake(targetstatus) $target]
		} else {
			dputs-G "build $target"
			if {[file exists $target]} {
				dputs-n "$target is not a target, but exists"
				set ret uptodate
			} else {
				dputs b "$target is not a target and does not exist"
				set ret failed
			}
			dict set tmake(targetstatus) $target $ret
		}
		return $ret
	}

	set ruletarget [get-rule-target $target]
	set oldstatus [get-rule-status $ruletarget]

	switch $oldstatus {
		running {
			dputs j "$ruletarget is still running"
			return running
		}
		uptodate {
			return uptodate
		}
		built {
			#dputs b "$target has previously been built"
			return built
		}
		checking {
			set current [list {*}$tmake(current) $target]
			build-fatal-error "[make-source-location $ruletarget]:Error: Recursive definition for [join [lreverse $current] { <= }]"
		}
		failed {
			dputs b "$target has previously failed to build"
			return failed
		}
		unknown - waiting {
			dputs-G "build $target"
		}
		default {
			error "Bad status: $oldstatus"
		}
	}

	# Set the status now to detect recursive dependencies
	set-rule-status $ruletarget checking
	set oldcurrent $tmake(current)
	lappend tmake(current) $target

	set t [get-rule $ruletarget]

	set reason {}
	if {$t(phony)} {
		dputs b "$target is phony, so rebuilding"
		lappend reason phony
		set status built
	} elseif {![file-exists-all $ruletarget missing]} {
		dputs b "$missing doesn't exist, so rebuilding"
		lappend reason noexist
		set status built
	} else {
		#dputs b "$ruletarget exists, so checking dependencies"
		set status uptodate
	}

	# Here is the plan to build $target
	# 1. Run 'build' for each static dependency
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 2. Calculate any dynamic dependencies for $target and run 'build' for each one
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 3. If nothing was built ($result is uptodate), check each static+dynamic dependency for time
	#    - If needbuild? returns 1, the target needs to be built
	# 4. If build not forced, check substituted '-do' against any cached value
	#    - If cached commands exists and they are different, the target needs to be built
	# 5. If build not forced, check any cached 'exec' entries to see if external dependencies have changed
	#    - If so, the target needs to be built

	set vardict [make-var-dict $t]

	# 1. First build static dependencies
	set depends $t(depends)
	set status [build-deps $target $ruletarget $status $t(depends) $t(phony) reason]
	if {$status in {uptodate built}} {
		# 2. Build dynamic dependencies
		# Note: Only targets or existing files are returned by calc-dyndeps.
		set dyndeps [calc-dyndeps $vardict $ruletarget]
		lappend depends {*}$dyndeps
		set status [build-deps $target $ruletarget $status $dyndeps $t(phony) reason]
	}

	if {$status eq "uptodate" && !$t(phony) && [llength $t(do)]} {
		# If the list of dependencies has changed, the target needs to be built

		if {![dict exists $tmakecache(deps) $ruletarget]} {
			# XXX why are we checking llength $t(depends) here?
			if {[llength $t(depends)]} {
				dputs b "No previous dyndeps for $ruletarget"
				set status built
				lappend reason nocache
			}
		} elseif {[lsort $dyndeps] ne [dict get $tmakecache(deps) $ruletarget]} {
			dputs b "dyndeps for $ruletarget have changed, so forcing build"
			if {[debug-is-set d] && [debug-is-set b]} {
				set olddeps [dict get $tmakecache(deps) $ruletarget]
				puts "=== old ==="
				puts [join [lsort $olddeps] \n]
				puts "=== new ==="
				puts [join [lsort $dyndeps] \n]
				puts "-----------"
			}
			set status built
			lappend reason dyndeps
		}
	}

	if {$tmake(quickstop) && $tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}

	if {$status eq "uptodate" && [llength $depends]} {
		# 3.  Target exists but no dependencies were built so check time dependencies
		if {[needbuild? $ruletarget $depends depfile]} {
			lappend reason older $depfile
			set status built
		}
	}

	# If this target belongs to a different rule than previously...
	if {$status eq "uptodate" && [llength $t(do)] && [dict exists $tmakecache(target) $target]} {
		if {$ruletarget ne [dict get $tmakecache(target) $target]} {
			dputs b "Target $target is built by a different rule"
			dputs B "Was [dict get $tmakecache(target) $target] but is now $ruletarget"
			lappend reason newrule
			set status built
		}
	}

	# 4. Compare previous '-do' commands with current commands
	if {$status eq "uptodate" && [llength $t(do)]} {
		if {![dict exists $tmakecache(cmd) $ruletarget]} {
			# If there are no dependencies, changed commands don't cause a rebuild by themselves
			# XXX: Should there be a special flag for this sort of rule?
			if {[llength $t(depends)]} {
				dputs b "No cached commands for $ruletarget, so forcing rebuild"
				lappend reason nocache
				set status built
			}
		} else {
			set do [subst-do $ruletarget $vardict $t(do)]
			set prevdo [dict get $tmakecache(cmd) $ruletarget]
			if {$do ne $prevdo} {
				dputs {b B} "Commands for $ruletarget have changed, so forcing rebuild"
				if {[debug-is-set B]} {
					puts "=== old ==="
					foreach d $prevdo {
						show-rule-commands $d
					}
					puts "=== new ==="
					foreach d $do {
						show-rule-commands $d
					}
					puts "-----------"
				}
				lappend reason commands
				set status built
			} else {
				dputs-n "Commands for $ruletarget are unchanged"
			}
		}
	}

	# 5. Check any cached 'exec' entries to see if external dependencies have changed
	if {$status eq "uptodate" && $tmake(checkexternalcmds)} {
		if {[dict exists $tmakecache(exec) $ruletarget]} {
			set execinfo [dict get $tmakecache(exec) $ruletarget]
			foreach {exec info} $execinfo {
				set s [stat-cmd-in-path $exec]
				if {$s ne $info} {
					dputs b "External command '$exec' for $ruletarget has changed, so forcing rebuild"
					set status built
					lappend reason extcmd
					break
				}
			}
		}
	}

	if {$status eq "uptodate" && $tmake(force) && !$tmake(ignoreforce)} {
		dputs b "Rebuilding $target because of --force"
		lappend reason force
		set status built
	}

	if {$t(chdir)} {
		# Note that -chdir uses the *first* target to determine the directory
		set tmake(chdir) [file-normalize [file-build [file dirname [lindex $ruletarget 0]]]]
	} else {
		set tmake(chdir) $tmake(topsrcdir)
	}

	if {$status eq "built" && [llength $t(do)]} {
		dputs g "[join $tmake(current) { --> }] ($reason)" 0

		set tmake(sync) 1

		dputs b "Building [join [lreverse $tmake(current)] { <= }] [make-source-location $ruletarget "with rule @"]"
		lassign [run-do $vardict $t(msg)] rc msg opts
		if {$rc != 0} {
			build-error [error-stacktrace $msg $opts(-errorinfo)]
		}

		if {[debug-is-set r]} {
			dputs r "Rule for $ruletarget"
			show-rule $ruletarget
		}

		if {$tmake(norun)} {
			if {$tmake(norun) == 1} {
				foreach do [subst-do $ruletarget $vardict $t(do)] {
					show-rule-commands $do
				}
			}
			set rc 0
		} else {
			if {$notifytarget eq ""} {
				set tmake(sync) 1
				if {$tmake(maxjobs) > 1} {
					dputs j "$ruletarget: notifytarget is empty, so building synchronously"
				}
			} else {
				set tmake(sync) 0
			}

			# Create all the target directories as required
			set dirlist {}
			foreach i $ruletarget {
				set targetdir [file-build [file dirname $i]]
				if {![file isdir $targetdir]} {
					lappend dirlist $targetdir
				}
			}
			if {[llength $dirlist]} {
				dputs m "mkdir [join $dirlist]"
				file mkdir {*}$dirlist
			}

			enter-new-dir $tmake(chdir)

			# If necessary, chdir now
			if {$t(chdir)} {
				dputs m "cd $tmake(chdir)"
				cd $tmake(chdir)
			}

			# Stash info for this rule that can be used in target-post-build either
			# immediately, or when the background job finishes
			global tmakeprecache

			set tmakeprecache($ruletarget) [dict create rule $t target $target dyndeps $dyndeps vardict $vardict]

			# Set these in case the job needs to be forked into the background
			set tmake(currentnotifytarget) $notifytarget
			set tmake(currentruletarget) $ruletarget
			set tmake(jobpid) -1
			set tmake(warningmsgs) {}

			# Check the 'slow' flag of the target to see if we should fork
			if {$t(slow)} {
				fork-job-if-required
			}
			if {$tmake(jobpid) <= 0} {
				# child process or sync, so run the jobs
				foreach do $t(do) {
					set oldenv [env-save]
					lassign [run-do $vardict $do] rc msg opts
					env-restore $oldenv
					if {$tmake(jobpid) > 0} {
						# run has forked and this is the parent
						break
					}
					if {$rc} {
						if {$t(nofail) && [info return $rc] eq "error"} {
							user-notice cyan "\[ignored\] $msg"
							set rc 0
						} else {
							break
						}
					}
				}
			}

			# Always restore the current dir afterwards
			cd $tmake(topsrcdir)

			if {$tmake(jobpid) > 0} {
				set status running
			} else {
				# Now the child is done
				if {[check-signal 1]} {
					# Caught a signal
					dputs j "Got signal while building $ruletarget"
					if {$tmake(jobpid) == 0} {
						exit 2
					}
					pputs ""
					tmake-exit 2 "*** Build cancelled"
				}
				if {$tmake(jobpid) == 0} {
					if {$rc} {
						dputs j "Job [pid] ($ruletarget) failed with rc=$rc, msg=$msg, opts=$opts"
						# Must output the failure here since it's the only place we have the strack trace
						dputs b "BUILD ERROR: $msg"
						if {[exists opts(-errorinfo)]} {
							puts stderr [colerr lred [error-stacktrace $msg $opts(-errorinfo)]]
						} elseif {$msg ne ""} {
							puts stderr [colerr lred $msg]
						}
						exit 1
					} else {
						dputs j "Job [pid] ($ruletarget) succeeded"
						exit 0
					}
				}
				if {$rc} {
					set status failed
				} else {
					set status built
				}
			}
			set tmake(sync) 1
		}

		if {!$tmake(norun)} {
			if {$status ne "running"} {
				target-post-build $ruletarget $rc $msg $opts
			}
		}

		if {($tmake(quickstop) || $t(fatal)) && $tmake(exitcode)} {
			tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
		}
	}

	if {$status eq "uptodate"} {
		# If --warnings is set, show any cached warnings
		if {$tmake(showwarnings)} {
			if {[dict exists $tmakecache(warnings) $ruletarget]} {
				set warnings [dict get $tmakecache(warnings) $ruletarget]
				if {[llength $warnings]} {
					enter-new-dir $tmake(chdir)

					# In verbose mode, the 'run' cmdline won't be shown.
					# The best we can do is output the complete cached command
					if {$tmake(verbose)} {
						foreach do [dict get $tmakecache(cmd) $ruletarget] {
							show-rule-commands $do
						}
					}
					run-do $vardict $t(msg)
					foreach msg $warnings {
						pputs grey $msg
					}
				}
			}
		}
	}

	#puts "status changed for $ruletarget from $oldstatus => $status ($reason)"
	set-rule-status $ruletarget $status

	set tmake(current) $oldcurrent
	return $status
}

# ==================================================================
# Dynamic dependencies
# ==================================================================

proc header-scan-regexp {suffix regex filename} {
	if {![file exists $filename]} {
		set filename [file-build $filename]
		if {![file exists $filename]} {
			# Might be a target which failed to build. This will be handled later
			dputs-D "header-scan-regexp $filename => <does not exist>"
			return {}
		}
	}
	set f [open $filename]
	set headers {}
	set n 0
	set d 0
	while {[gets $f buf] >= 0} {
		incr n
		if {[regexp $regex $buf -> name]} {
			append name $suffix
			lappend headers $name
		}
	}
	close $f
	dputs-D "header-scan-regexp $filename => $headers"
	return $headers
}

# Returns a list of {type path-to-filename mtime}
# where type is "target" or "source"
#
# If the $path/$filename is neither a target nor source, the empty list is returned
proc find-file-on-path {filename path} {
	set f [file-join $path $filename]

	set result {}
	if {[is-target? $f]} {
		dputs-D "$f is a target, so building first"
		# Even if it fails to build, it is needed
		set status [build-sync $f]
		if {$status in {built uptodate}} {
			# with tmake -n, the file may not have actually been built
			set filepath [file-build $f]
			if {[file exists $filepath]} {
				set result [list target $f [file-mtime $filepath]]
			} else {
				set result [list target $f 0]
			}
		} else {
			dputs-D "failed to build $f"
			if {$::tmake(quickstop)} {
				tmake-exit 1 "Error: Failed to build $f"
			} else {
				build-error "Error: Failed to build $f"
			}
		}
	} else {
		if {[file exists $f]} {
			set result [list source $f [file-real-mtime $f]]
		}
	}
	#puts "find-file-on-path $filename + $path ($f) => $result "
	return $result
}

# Returns a list of {type path mtime ...}
# where type is "target" or "source" and the path is:
#
# target -  $path-to-filename
# source -  $path-to-filename
#
# Note that the current directory (.) is special.
# We return both the first match along $paths and any match on [file dirname $filename]
# (Unless they are the same)
#
proc find-file {filename paths} {
	#puts "find-file filename=$filename, paths=$paths"

	# First check the per-run cache
	set cachekey "$filename $paths"
	if {[dict exists $::tmake(depfindcache) $cachekey]} {
		#puts "=> (cached) [dict get $::tmake(depfindcache) $cachekey]"
		return [dict get $::tmake(depfindcache) $cachekey]
	}

	set result {}
	set filedir [file dirname $filename]
	set seendot 0

	# First search the given paths
	foreach p $paths {
		if {$p eq $filedir} {
			incr seendot
		}
		lappend result {*}[find-file-on-path $filename $p]
		if {[llength $result]} {
			break
		}
	}

	# If we didn't search $filedir, do it now
	if {!$seendot} {
		lappend result {*}[find-file-on-path $filename $filedir]
	}

	if {[llength $result] == 0} {
		dputs-D "Not a file and not a target, $filename"
	}
	if {[debug-is-set D] && [llength $result] > 3} {
		dputs-D "Note: Found multiple locations for $filename: [join $result]"
	}
	#puts "find-file filename=$filename, paths=$paths => $result"
	# Cache this result
	dict set ::tmake(depfindcache) $cachekey $result

	#puts "=> [dict get $::tmake(depfindcache) $cachekey]"

	return $result
}

# XXX: This could be done better
#
proc header-scan-regexp-recursive {incpaths suffix regex filename} {
	global tmake tmakecache

	if {[is-target? $filename]} {
		set filepath [file-build $filename]
	} else {
		set filepath $filename
	}
	if {![file exists $filepath]} {
		dputs-D "header-scan-regexp-recursive, $filepath does not exist"
		return {}
	}
	set cachekey "$incpaths $suffix $regex $filename"

	dputs-D "Scanning $filename for headers: incpaths=$incpaths"
	# Can we get the result from the cache?
	set stamp [list [file mtime $filepath] $incpaths $suffix $regex]
	if {[dict exists $tmakecache(headerscan) $filename]} {
		lassign [dict get $tmakecache(headerscan) $filename] cache_stamp headers cachedresults
		if {$cache_stamp eq $stamp} {
			# Need to verify that find-file returns the same result as last time
			#puts "---- $filename ----"
			#parray cachedresults
			dputs-D "verifying up-to-data cached results for $filename"
			set ok 1
			foreach {cfile ctypepath} $cachedresults {
				set typepath [find-file $cfile $incpaths]
				if {$typepath ne $ctypepath} {
					dputs-d "previously $cfile resolved to {$ctypepath}, but now resolves to {$typepath} -  forcing rescan"

					# XXX: Previously we discarded any cached, orphan targets here, but
					# that is not necessary since the normal orphan cleaning does it
					if 0 {
						foreach {ctype cpath cmtime} $ctypepath {
							if {$ctype eq "target" && ![is-target? $cpath]} {
								set orphanpath [file-build $cpath]
								if {[file exists $orphanpath]} {
									dputs-d "discarding orphan $cpath"
									delete-orphan-files $orphanpath
								}
							}
						}
					}

					set ok 0
					break
				}
			}
			if {$ok} {
				# Can reuse the cache
				dputs-d "header-scan-regexp $filename (cached) => $headers"
				return $headers
			} else {
				dputs-d "cache is out-of-date for $filename - rescanning"
			}
		}
		# Stale
		dict unset tmakecache(headerscan) $filename
	}

	# Recursively scan files
	unset -nocomplain deps results
	set deps {}
	set results {}
	set scanned($filename) 1
	set toscan [header-scan-regexp $suffix $regex $filepath]
	while {[llength $toscan]} {
		set newscan {}
		foreach d $toscan {
			if {![info exists scanned($d)]} {
				set scanned($d) 1
				set findfiles [find-file $d $incpaths]
				set results($d) $findfiles
				foreach {type deppath mtime} $findfiles {
					set deps($deppath) 1
					lappend newscan {*}[header-scan-regexp $suffix $regex $deppath]
				}
			}
		}
		set toscan $newscan
	}

	#puts "---- $filename ----"
	#parray results
	# memoize the result
	set headers [dict keys $deps]
	dict set tmakecache(headerscan) $filename [list $stamp $headers $results]
	#dputs d results=$results
	mark-cache-dirty "New header scan"
	return $headers
}

# These are overridden by the colour module
proc colout {colour string} {
	return $string
}

proc colerr {colour string} {
	return $string
}

# Embedded modules are inserted below here
##-- CUT HERE --##

# ==================================================================
# ENTRY POINT
# ==================================================================

set rc [catch -signal {
	set rc [catch {callmake $argv} msg opts]
	if {$rc} {
		if {$rc == 1 && [exists -command error-stacktrace]} {
			user-notice lred [error-stacktrace $msg $opts(-errorinfo)]
		} elseif {$msg ne ""} {
			user-notice lred $msg
		}
		set tmake(exitcode) 1
	}

	# We do this even on error
	if {$tmake(numtargets) || $tmake(showtime) || $tmake(verbose)} {
		set elapsed [expr {([clock millis] - $tmake(start)) / 1000.0}]
		if {!$tmake(quiet)} {
			pputs cyan "Built $tmake(numtargets) of [num-nonphony-targets] target(s) in [format %.2f $elapsed] seconds"
		}
	}
	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "late"} {
		fake-an-error
	}
	if {$tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}
} msg opts]

switch [info returncodes $rc] {
	"signal" {
		# This must be SIGPIPE since we catch/ignore other errors
		set tmake(exitcode) 1
	}
	"error" {
		stderr puts $msg
	}
}

tmake-exit $tmake(exitcode)
