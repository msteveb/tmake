#!/usr/bin/env jimsh
# vim:set syntax=tcl:

# ==================================================================
# Initialiation
# ==================================================================

set tmake(debug) 0
set tmake(verbose) 0
set tmake(norun) 0
set tmake(current) {}
set tmake(targets) {}
set tmake(clean) {clean {} distclean {} uninstall {}}
set tmake(install) {}
set tmake(installbin) {}
set tmake(installdirs) {}
set tmake(numtargets) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(modules) {}

# ==================================================================
# Argument Processing
# ==================================================================

proc make {argv} {
	global tmake
	#puts "make $argv"
	#parray ::env

	# 'misc' is needed before we can do anything, so set a temporary libdir
	# in case this is the development version
	set tmake(dir) [file dirname $::argv0]
	set tmake(libdir) $tmake(dir)/lib

	use compat
	set tmake(start) [clock-millis]

	use getopt config

	# Parse the user options
	set targets {}
	foreach a $argv {
		if {[regexp {([^=]*)=(.*)} $a -> n v]} {
			if {$n eq "V"} {
				set tmake(verbose) $v
			} elseif {$n eq "D"} {
				set tmake(debug) $v
			} elseif {$n eq "P"} {
				set tmake(showrules) 1
			} elseif {$n eq "N"} {
				incr tmake(norun)
			} elseif {$n eq "T"} {
				incr tmake(showtime)
			} elseif {$n eq "Q"} {
				incr tmake(quickstop)
			} else {
				define $n $v
			}
		} elseif {[string match -* $a]} {
			switch -glob -- $a {
				--debug - -d {
					set tmake(debug) 1
				}
				--verbose - -v {
					set tmake(verbose) 1
				}
				--dry-run - --just-print - -n {
					set tmake(norun) 1
				}
				--tim* - -t {
					incr tmake(showtime)
				}
				-q - --quickstop {
					incr tmake(quickstop)
				}
				-p - --print* {
					incr tmake(showrules)
				}
				-C* {
					# XXX: Should be "-C dir" but that is waiting for getopt
					cd [string range $a 2 end]
				}
				default {
					# Ignore unknown options
					#error "Unknown option $a"
				}
			}
		} else {
			lappend targets $a
		}
	}

	#parray tmake

	use rulebase

	# Loaded in the global scope 
	if {[file exists build.spec]} {
		uplevel #0 source build.spec
	} else {
		user-error "No build.spec in the current directory"
	}

	# Now build the targets

	if {[llength $targets] == 0} {
		set targets all
	}

	if {$tmake(showrules)} {
		show-all-rules
	}

	build $targets
}

# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	foreach m $args {
		if {[dict exists $::tmake(modules) $m]} {
			continue
		}
		dict set ::tmake(modules) $m 1

		set source $::tmake(libdir)/${m}.tcl
		if {![file exists $source]} {
			dev-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		#lappend ::automf(makefiledeps) $source
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {msg} {
	puts stderr "Error: $msg"
	puts stderr "Try: 'tmake --help' for options"
	exit 1
}

# @user-notice msg
#
# Output the given message to stderr.
#
proc user-notice {msg} {
	puts stderr $msg
}

# Incorrect usage in the build.spec file. Identify the location.
proc dev-error {msg} {
	puts stderr [error-location $msg]
	exit 1
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		puts $msg
	}
}

# Output a message to stdout if --debug is set.
#
proc dputs {msg} {
	if {$::tmake(debug)} {
		puts [dbg-msg-indent]$msg
	}
}

proc dbg-msg-indent {} {
	string repeat "  " [llength $::tmake(current)]
}

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	set lines [split $do \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set t [get-target-rule $target]
		set flags {}
		set lines {}
		foreach n [lsort [dict keys $t]] {
			set v [dict get $t $n]
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				phony {
					if {$v} {
						lappend flags $n
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vn"
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n='$v'"
					}
				}
			}
		}
		if {[llength $flags]} {
			append target " \[$flags\]"
		}
		puts "$target: $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		show-rule-commands $t(do)
	} else {
		puts "No rule to make $target"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(targets)]] {
		puts "-------------------------------------------"
		show-rule $i
		puts ""
	}
}

# ==================================================================
# Variable Handling
# ==================================================================

# Set a variable to the given value
# 
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	upvar #0 $name n
	set n [join $args]
}

# Set a variable to the given value
# unless it is already set to a non-empty value.
#
proc define? {name args} {
	upvar #0 $name n
	if {![info exists n] || $n eq ""} {
		set n [join $args]
	}
}

# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	upvar #0 $name n
	append-with-space ::$name [join $args]
}

# If the given var is not set or is "", sets it to $value
# Otherise appends $value with a space separator (or $space)
#
proc append-with-space {varname value {space " "}} {
	upvar $varname n
	if {[info exists n] && $n ne ""} {
		append n $space $value
	} else {
		set n $value
	}
}

# Takes a list and returns a new list with $suf appended
# to each element
# 
# suffix .c a b c => a.c b.c c.c
#
proc suffix {suf args} {
	set result {}
	lmap p [join $args] {
		lappend result $p$suf
	}
	return $result
}

# Takes a list and returns a new list with $pre prepended
# to each element
# 
# suffix jim- a.c b.c => jim-a.c jim-b.c
#
proc prefix {pre args} {
	set result {}
	lmap p [join $args] {
		lappend result $pre$p
	}
	return $result
}

# Takes a list of filenames and returns a new list with
# the extension of each filename changed to $ext
# 
# change-ext .c a.o b.o c => a.c b.c c.c
#
proc change-ext {ext args} {
	set result {}
	lmap p [join $args] {
		lappend result [file rootname $p]$ext
	}
	return $result
}

# Merges target variables.
# These are stored in dictionaries, where $dict1 is the current vars
# and the new vars $dict2 need to be merged.
# Where there is no overlap, the dictionaries are simply merged.
# Where a var exists in both, the values are combined with a space separator.
proc merge-vars {dict1 dict2} {
	if {[dict size $dict2]} {
		if {[dict size $dict1] == 0} {
			return $dict2
		}
		foreach {n v} $dict2 {
			append-with-space dict1($n) $v
		}
	}
	return $dict1
}

# Appends the given arguments to the given key in the dictionary
proc dict-lappend {dictname key args} {
	upvar $dictname d
	set list [dict get $d $key]
	lappend list {*}$args
	dict set d $key $list
}

# ==================================================================
# Rule Handling
# ==================================================================

proc is-target? {target} {
	dict exists $::tmake(targets) $target
}

proc get-target-rule {target} {
	dict get $::tmake(targets) $target
}

proc set-target-rule {target dict} {
	dict set ::tmake(targets) $target $dict
}

proc show-this-rule {} {
	#dputs [info level -1]
}

proc get-clean {type} {
	dict get $::tmake(clean) $type
}

proc add-clean {type args} {
	dict-lappend ::tmake(clean) $type {*}$args
}

# Adds a file to be installed
proc add-install-file {dest src {bin 0}} {
	# Add the directory to the list of directories to be created
	dict set ::tmake(installdirs) [file dirname $dest] 1
	if {[dict exists $::tmake(install) $dest]} {
		user-notice "Warning: Duplicate install rule for $dest"
	}
	dict set ::tmake(install) $dest $src
	dict set ::tmake(installbin) $dest $bin
	# This file also needs to be uninstalled
	add-clean uninstall $dest
}

# Returns the list of directories where files will be installed
#
proc get-installdirs {} {
	prefix $::DESTDIR [lsort [dict keys $::tmake(installdirs)]]
}

# Look down the stack frame for the first location
# which is in a *.spec file and return it.
# Returns "unknown" if not known.
#
proc find-rule-source {} {
	foreach i [range [info level]] {
		lassign [info frame $i] proc file line
		if {[string match *.spec $file]} {
			return $file:$line
		}
	}
	return unknown
}

# This is the only way to create a rule
#
# Parses the arguments and adds them to the rule base
#
proc target {target args} {
	array set info [parse-target-rule $target $args]

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	if {[is-target? $target]} {
		# There is already a rule for this target, so attempt
		# to merge the two rules

		array set orig [get-target-rule $target]

		if {$info(do) ne "" && $orig(do) ne ""} {
			dev-error "$target already has '-do' @$orig(source)"
		}
		lappend info(depends) {*}$orig(depends)
		lappend info(inputs) {*}$orig(inputs)
		lappend info(clean) {*}$orig(clean)
		incr info(phony) $orig(phony)
		append-with-space info(onfail) $orig(onfail) \n
		append-with-space orig(do) $info(add-do) \n

		if {$info(source) eq "unknown"} {
			set info(source) $orig(source)
		} elseif {$orig(source) ne "unknown"} {
			lappend info(source) {*}$orig(source)
		}

		# Need to append to any vars which exist
		set info(vars) [merge-vars $orig(vars) $info(vars)]

		# Whichever rule has '-do' also specifies '-inputs' and '-msg'
		if {$info(do) eq ""} {
			set info(do) $orig(do)
			set info(inputs) $orig(inputs)
			set info(msg) $orig(msg)
		}
	}

	# Now create/update the rule
	set-target-rule $target [array get info]
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-target-rule {target arglist} {
	set info(source) [find-rule-source]
	set info(result) 0
	set info(building) 0
	set info(building) 0
	set info(target) $target
	set info(phony) 0
	set info(add-do) {}
	set info(vars) {}

	set -inputs {}
	set -depends {}
	set -clean {}
	set -do {}
	set -onfail {}
	set -msg {}
	set -vars {}

	set skip 0
	set add 0

	foreach a $arglist {
		if {$a eq "-phony"} {
			incr info(phony)
			continue
		}
		if {$a eq "-add"} {
			incr add
			continue
		}
		if {$skip == 0 && [string match -* $a]} {
			if {![info exists $a]} {
				error "Unknown option to target: $a"
			}
			set current $a
			if {$a eq "-vars"} {
				incr skip 2
			}
		} else {
			if {$skip} {
				incr skip -1
			}
			lappend $current $a
		}
	}

	if {[llength ${-vars}] % 2} {
		dev-error "Rule for $target has an odd number of parameters to '-vars'"
	}
	if {[llength ${-do}] > 1} {
		dev-error "Rule for $target has more than one '-do' parameter"
	}
	if {[llength ${-msg}] > 1} {
		dev-error "Rule for $target has more than one '-msg' parameter"
	}
	if {$add} {
		if {![llength ${-do}]} {
			dev-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) [lindex ${-do} 0]
		set -do ""
	}

	set info(inputs) [join ${-inputs}]
	set info(depends) [join ${-depends}]
	set info(clean) ${-clean}
	set info(onfail) ${-onfail}
	set info(vars) ${-vars}
	set info(do) [lindex ${-do} 0]
	set info(msg) [lindex ${-msg} 0]

	if {$info(do) eq "" && [llength $info(inputs)]} {
		dev-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {$info(do) eq "" && $info(msg) ne ""} {
		dev-error "Rule for $target has '-msg' but no '-do'"
	}
	array get info
}

# ==================================================================
# Dependency Engine
# ==================================================================

proc needbuild? {target source} {
	set result [get-target-result $target]
	if {$result} {
		return $result
	}
	if {[file exists $target]} {
		if {[file exists $source]} {
			if {[file mtime $target] >= [file mtime $source]} {
				dputs "$target is newer than $source, so not forcing rebuild"
				return 0
			}
		}
		dputs "$target is older than $source, so forcing rebuild"
		return 1
	} else {
		dputs "$target does not exist, so forcing build"
		return 1
	}
}

# Sets target-local variables. e.g. $inputs, $depends and $target
proc set-target-vars {info} {
	foreach {n v} $info(vars) {
		set ::$n $v
	}
	foreach n {target depends inputs} {
		set ::$n $info($n)
	}
}
proc clear-target-vars {info} {
	foreach n [dict keys $info(vars)] {
		set ::$n ""
	}
}

proc get-target-result {target} {
	if {![is-target? $target]} {
		return -1
	}
	dict get $::tmake(targets) $target result
}

proc set-target-result {target result} {
	if {[get-target-result $target] == 0} {
		dict set ::tmake(targets) $target result $result
	}
}

proc note {args} {
	if {$::tmake(verbose) == 0} {
		puts [join $args]
	}
}

proc run {args} {
	vputs [string trim [join $args]]
	try {
		exec >@stdout {*}[join $args]
	} on error msg {
		puts stderr \n\t[join $args]\n
		puts stderr $msg\n
		return -code break
	}
}

proc build {target} {
	global tmake
	set current $tmake(current)
	lappend current $target
	if {![is-target? $target]} {
		if {[file exists $target]} {
			dputs "$target is not a target, but exists"
			return 0
		}
		dputs "$target is not a target and does not exist"
		return -1
	}
	set t [get-target-rule $target]
	if {$t(result) < 0} {
		#dputs "$target has previously failed to build"
		return -1
	} elseif {$t(result) > 0} {
		#dputs "$target has previously been built"
		return 1
	}
	if {$t(building)} {
		puts stderr "Recursive definition for [join [lreverse $current] { <= }] @[join $t(source) {, }]"
		exit 1
	}
	dict set tmake(targets) $target building 1

	if {$t(phony)} {
		dputs "$target is phony, so rebuilding"
		set result 1
	} elseif {![file exists $target]} {
		dputs "$target doesn't exist, so rebuilding"
		set result 1
	} else {
		dputs "$target exists, so checking dependencies"
		set result 0
	}

	set oldcurrent $tmake(current)
	set tmake(current) $current

	# First make sure dependencies are up to date
	foreach i $t(depends) {
		#puts "Building $i"
		#dumptarget $i
		set rc [build $i]
		if {$rc < 0} {
			if {[get-target-result $target] >= 0} {
				puts stderr "Don't know how to build $i: [join [lreverse $current] { <= }] @[join $t(source) {, }]"
			}
			#dumptarget $target
			#show-reason $current
			set result -1
			if {$tmake(quickstop)} {
				break
			}
		} elseif {$result == 0} {
			if {$rc > 0} {
				dputs "Rebuilding $target because $i was built"
				set result 1
			} elseif {[needbuild? $target $i]} {
				set result 1
			}
		}
	}
	if {$result > 0 && $t(do) ne ""} {
		#puts "Running rules for $target"
		dputs "Building [join [lreverse $current] { <= }] with rule @[join $t(source) {, }]"
		try {
			set-target-vars $t
			uplevel #0 $t(msg)
			if {$tmake(norun)} {
				try {
					set do [uplevel #0 [list subst $t(do)]]
				} on error msg {
					# The rule probably refers to a command or variable which
					# doesn't exist, to show it without the subst
					set do $t(do)
				}
				show-rule-commands $do
				parray t
			} else {
				uplevel #0 $t(do)
				incr tmake(numtargets)
			}
		} on {error break} {msg opts} {
			file delete $target {*}$t(clean)
			try {
				uplevel #0 $t(onfail)
				if {[info returncode $opts(-code)] eq "error"} {
					puts stderr [errorInfo $msg]
				}
			} on error {fmsg fopts} {
				puts stderr [errorInfo $fmsg]
			}
			set result -1
		} finally {
			clear-target-vars $t
		}
	}

	# For each target, mark it as made (> 0) or unmakeable(< 0)
	if {$result != 0} {
		#puts "Marking target result=$result for $current"
		foreach t $current {
			set-target-result $t $result
		}
	}
	set tmake(current) $oldcurrent
	dict set tmake(targets) $target building 0
	return $result
}

# ==================================================================
# ENTRY POINT
# ==================================================================

if {[info exists env(MAKEFLAGS)]} {
	# Running under make
	set argv [list {*}"-$env(MAKEFLAGS)" {*}$argv]
}

if {[catch {make $argv} msg opts]} {
	set errmsg [errorInfo $msg]
	puts stderr [regsub {Runtime Error: } $errmsg ""]
	exit 1
}

if {$tmake(numtargets) || $tmake(showtime)} {
	puts "Built $tmake(numtargets) target(s) in [format %.2f $(([clock-millis] - $tmake(start)) / 1000.0)] seconds"
}
