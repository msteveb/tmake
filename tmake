#!/usr/bin/env jimsh
# Copyright (c) 2011-2016 WorkWare Systems http://www.workware.net.au/
# All rights reserved
# vim:se syntax=tcl:

# ==================================================================
# Initialiation
# ==================================================================

set tmake(version) {0.7.7 (4-Aug-2019)}
set tmake(cacheversion) 4

# Turn on debugging as early as possible
set tmake(debug) $("--debug" in $argv)

set tmake(debugtypes) {d 0 n 0 r 0 b 0 t 0 c 0 g 0 G 0 h 0 p 0 m 0 l 0 D 0 C 0 T 0 B 0 v 0 x 0 j 0}
set tmake(debughelp) {
	* "Enable all debug"
	? "Display help for debug types"
	d "Dynamic dependencies"
	D "Dynamic dependencies (detailed)"
	n "Reasons for targets NOT built"
	b "Reasons for targets BUILT"
	B "Reasons for targets BUILT - changed commands or targets"
	r "Display rules when triggered"
	g "Depencency graph for each target"
	G "List goals (targets) as they are attempted"
	h "Show hashing"
	p "Print rules while parsing"
	m "Miscellaneous (locating and parsing of files)"
	l "Locating sources and targets"
	c "Configuration expressions via ifconfig"
	C "Cache handling"
	T "Timing (add --delta for delta times)"
	v "Variable definition"
	j "Parallel (job-based) builds"
}
set tmake(verbose) 0
set tmake(showdelta) 0
set tmake(norun) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(exitcode) 0
set tmake(autosubdirs) 1
set tmake(checkexternalcmds) 0
set tmake(deferred) {}
set tmake(projfiles) {}
set tmake(defines) {}
set tmake(fixedvars) {}
set tmake(installed) 0
set tmake(cleaning) 0
set tmake(quiet) 0
set tmake(ignoreforce) 0
set tmake(force) 0
set tmake(usepager) 1
set tmake(showcache) 0
set tmake(showvars) 0
set tmake(showaliases) 0
set tmake(showwarnings) 0
set tmake(usehashes) 0
set tmake(cachecleanup) 0
set tmake(depfindcache) {}
set tmake(addtargets) {}
set tmake(varloc) {}
set tmake(emptycache) {
	file {} cmd {} deps {} target {} headerscan {} warnings {}
	exec {} version 0 writecache 0 srchash {} dephash {} usehashes 0
	updatecount 0
}

set tmake(commands-overview) {}
set tmake(commands) {}
set tmake(cli-options) {}
# Template for a target. flags have values of 0, while nonflags have {}
set tmake(emptytarget) {
	alias {} chdir 0 depends {} do {} dyndep {} fatal 0 finally {}
	getvars {} hash 0 inputs {} msg {} nocache 0 nofail 0
	nofork 0 onerror {} phony 0 rootok 0 slow 0 symlink 0 vars {}
}

# The known clean targets
set tmake(clean-targets) {clean distclean clean-orphans}

set tmakecache $tmake(emptycache)
set tmakeprecache {}
set tmakemodules {}

set tmake(defaulttarget) all
set tmake(loadedprojectspec) 0
set tmake(current) {}
set tmake(rules) {}
set tmake(ruledefaultopts) {}
set tmake(aliases) {}
set tmake(rulestatus) {}
set tmake(targetstatus) {}
set tmake(targets) {}
set tmake(parsedone) 0
set tmake(numtargets) 0
set tmake(subdirs) {}
set tmake(prefix) ""
set tmake(localdir) .
set tmake(warningmsgs) {}
set tmake(running) {}
set tmake(pending) {}
set tmake(jobpid) -1
set tmake(resetstatus) 0

# ==================================================================
# Argument Processing
# ==================================================================

proc make-parse-options {argv} {
	global tmake
	#puts "make-parse-options [list $argv]"

	use argparse

	# Do we need to remove anything from cli-options
	# e.g. -C?
	set tmake(cli-options) $argv

	argparse argv {
		--configure {
			# Just want to run configure with the remaining args
			set tmake(configure) 1
			break
		}
		--showcache {
			incr tmake(showcache)
		}
		{--find --find=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 0
		}
		{--findall --findall=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 1
		}
		{--jobs=*} {
			define! MAXJOBS [argparam $arg]
		}
		--delta {
			incr tmake(showdelta)
		}
		--build=* {
			set tmake(build) [argparam $arg]
		}
		--force {
			incr tmake(force)
		}
		--showvars {
			set tmake(showvars) 1
		}
		--showvars=* {
			set tmake(showvars) 2
		}
		--hash {
			incr tmake(usehashes)
		}
		--cacheclean* {
			incr tmake(cachecleanup)
		}
		--showaliases {
			incr tmake(showaliases)
		}
		--warnings {
			incr tmake(showwarnings)
		}
		--rulebase {
			set rulebase [get-rulebase]
			if {[llength $rulebase] > 1} {
				puts [lindex $rulebase 1]
			} else {
				puts [readfile [lindex $rulebase 0]]
			}
			exit 0
		}
		--rules {
			user-notice colwarn "Warning: Use --commands rather than the deprecated --rules"
			set tmake(listcommands) *
		}
		--commands {
			set tmake(listcommands) *
		}
		{--commands=*} {
			set tmake(listcommands) [argparam $arg]
		}
		{--targets --targets=all} {
			set tmake(listtargets) [argparam $arg]
		}
		--debug {
			# Enable full stack traces as well as -dg
			set tmake(debug) 1
			dict set tmake(debugtypes) g 1
		}
		-d* {
			if {$arg eq "-d?"} {
				puts "Debugging can be enabled with -d..."
				puts "The debugging categories are as follows:\n"

				foreach {n desc} $tmake(debughelp) {
					puts "\t$n\t$desc"
				}
				exit 0
			}
			if {$arg eq "-d*"} {
				foreach i [dict keys $tmake(debugtypes)] {
					dict set tmake(debugtypes) $i 1
				}
				lappend tmake(cli-options) $arg
			} else {
				foreach i [split [string range $arg 2 end] {}] {
					dict set tmake(debugtypes) $i 1
				}
			}
		}
		{--install=* --install} {
			use install
			tmake_install [argparam $arg]
		}
		{--verbose -v} {
			incr tmake(verbose)
		}
		--col* {
			set tmake(colout) 1
			set tmake(colerr) 1
		}
		--nocol* {
			set tmake(colout) 0
			set tmake(colerr) 0
		}
		--showcol* {
			load-tmakerc
			use colour
			show-colours
			exit 0
		}
		--version {
			use help
			pputs [show-version]
			exit 0
		}
		{--help -h} {
			use help
			show-help $tmake(cli-options)
			exit 0
		}
		--ref {
			use help
			show-reference
			exit 0
		}
		--nopager {
			set tmake(usepager) 0
		}
		--genie {
			use genie
			tmake-genie $tmake(cli-options)
			exit 0
		}
		{--dry-run --just-print -n} {
			set tmake(norun) 1
		}
		{-N -nn} {
			set tmake(norun) 2
		}
		{--tim* -t} {
			incr tmake(showtime)
		}
		{-q --quickstop} {
			incr tmake(quickstop)
		}
		{-Q --quiet} {
			incr tmake(quiet)
		}
		{-p --print*} {
			incr tmake(showrules)
		}
		-C {
			set arg [argnext argv]
			# This will fail with a fatal error if not a dir
			enter-new-dir [file-normalize $arg]
			cd $arg
		}
		-- {
			break
		}
		--* {
			user-error "Unknown option $arg"
		}
		*=* {
			if {[regexp {^([^=]*)=(.*)} $arg -> n v]} {
				# ABC=DEF
				define! $n $v
			}
		}
	}
	return $argv
}

proc callmake {__argv} {
	# This stack frame is designed specifically to hold 'define' variables
	return [make $__argv]
}

proc make {argv} {
	global tmake

	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "early"} {
		fake-an-error
	}

	# 'compat' is needed before we can do anything, so set a temporary $tmake(dir)
	if {!$tmake(installed)} {
		set argv0 $::argv0
		while {[file type $argv0] eq "link"} {
			set argv0 [file readlink $argv0]
		}
		set tmake(dir) [file dirname $argv0]
		use compat
	}

	use colour util fileutil

	# Default colour aliases. We use the col prefix
	# to make it easier to find these in the code
	colalias colwarn purple
	colalias coldebugtime purple
	colalias colrulename purple
	colalias colruleargs yellow
	colalias coldebug yellow
	colalias colenterdir green
	colalias colerror lred
	colalias colnote cyan
	colalias colrunwarn grey
	colalias colstatus lyellow

	set tmake(exe) [file-normalize $::argv0]
	set tmake(dir) [file dirname $tmake(exe)]
	set tmake(start) [clock millis]
	set tmake(hashtime) 0
	set tmake(prevtime) $tmake(start)
	set tmake(initialdir) [pwd]
	set tmake(lastchdir) $tmake(initialdir)
	set tmake(isroot) [is-uid-root]

	# Parse the options and return the list of targets to build

	# XXX Need to do this first to find -C, but
	# tmake.opt and TMAKEFLAGS should really be done first
	# so that command line options can override them
	set tmake(cmdline) [make-parse-options $argv]

	# Need to find the project top
	set tmake(topsrcdir) [find-project-top]
	if {$tmake(topsrcdir) eq ""} {
		user-error "Failed to find project.spec in any parent directory."
	}
	if {[file exists $tmake(topsrcdir)/tmake.opt]} {
		dputs m "tmake.opt exists, so loading command line options"
		make-parse-options [readfile $tmake(topsrcdir)/tmake.opt]
	}
	set TMAKEFLAGS [env TMAKEFLAGS ""]
	if {$TMAKEFLAGS ne ""} {
		dputs m "TMAKEFLAGS is set, so parsing"
		make-parse-options $TMAKEFLAGS
	}

	# We want disabled debugging to be as fast as possible
	# These are called very frequently
	foreach i {n G d D} {
		if {[debug-is-set $i]} {
			alias dputs-$i dputs $i
		} else {
			# proc with null body is specially optimised
			proc dputs-$i {args} {}
		}
	}

	# Find the current dir relative to topsrcdir
	set tmake(subdir) [relative-path [pwd] $tmake(topsrcdir)]

	# Builds run from topsrcdir
	cd $tmake(topsrcdir)

	# Full path
	set tmake(topsrcdir) [pwd]

	load-tmakerc

	# By default, the build directory is 'objdir', but this
	# can be changed with --build, either on the command line or from tmake.opt
	# XXX: Currently tmake.opt overrides the command line because it it parsed later.
	if {![info exists tmake(build)]} {
		dputs m "Setting --build=objdir"
		set tmake(build) objdir
	} else {
		dputs m "Got --build=$tmake(build)"
	}

	# Create the build dir now
	file-mkdir -rooterr $tmake(build)

	set tmake(topbuilddir) [file-normalize $tmake(build)]

	# Make these available in the environment for the benefit of generator programs and scripts
	# which want to be able to find things
	setenv TOPSRCDIR $tmake(topsrcdir)
	setenv TOPBUILDDIR $tmake(topbuilddir)
	setenv BUILDDIR $tmake(build)

	define TOPSRCDIR $tmake(topsrcdir)
	define TOPBUILDDIR $tmake(topbuilddir)
	define BUILDDIR $tmake(build)

	if {$tmake(showcache)} {
		show-cache
		exit 0
	}

	flush stdout

	set tmake(prefix) ""

	if {[exists tmake(configure)]} {
		dputs m "--configure options, so taking over targets"
		# Put the command line in CONFIGURE_OPTS
		# and build configure
		define! CONFIGURE_OPTS $tmake(cmdline)
		set tmake(cmdline) configure
	}

	use getopt config

	# Core implementation simply removes files
	# Project or rulebase can override this
	alias delete-orphan-files file delete

	set rulebase [get-rulebase]

	lassign [invoke-spec-file {*}$rulebase] rc msg opts
	dputs T "Parsed [lindex $rulebase 0]"

	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed rulebase"

	rulebase-invoke init

	dputs T "Initialised rulebase"

	# Save the global state in case we need to reload
	# At this stage it includes defaults, options and the rulebase

	set tmake_save $tmake

	load-build-description 1

	dputs T "Parsing phase complete"
	set tmake(parsedone) 1

	if {$tmake(usehashes)} {
		if {[init-md5sum]} {
			dputs h "Using hashes for file comparison"
		} else {
			set tmake(usehashes) 0
			user-notice colwarn "Warning: no md5sum command - hashing is not available"
		}
	}

	if {$tmake(cachecleanup)} {
		clean-cache
		tmake-exit 0
	}

	if {$tmake(showrules)} {
		show-all-rules
		tmake-exit 0
	}
	if {$tmake(showvars)} {
		show-all-defines $tmake(showvars)
		tmake-exit 0
	}
	if {$tmake(showaliases)} {
		show-all-aliases
		tmake-exit 0
	}
	if {[info exists tmake(listtargets)]} {
		show-all-targets $tmake(listtargets)
		tmake-exit 0
	}
	if {[info exists tmake(listcommands)]} {
		show-matching-commands $tmake(listcommands)
		tmake-exit 0
	}
	if {[info exists tmake(findtarget)]} {
		show-find-results $tmake(findtarget) $tmake(findall)
		tmake-exit 0
	}

	# Targets are relative to the local dir, $tmake(subdir),
	# unless prefixed with / in which case they are global.
	if {[llength $tmake(cmdline)]} {
		foreach arg $tmake(cmdline) {
			if {[regexp {//(.*)} $arg -> realtarget] || [regexp {^/(.*)} $arg -> realtarget]} {
				lappend targets $realtarget
			} else {
				lappend targets [file-join $tmake(subdir) $arg]
			}
		}
	} else {
		lappend targets [file-join $tmake(subdir) $tmake(defaulttarget)]
	}

	# Finally we can begin building the specified targets.
	# Build each target, resetting the status and possibly reloading every time
	while {[llength $targets] && $tmake(exitcode) == 0} {
		set targets [lassign $targets target]

		set tmake(addtargets) {}

		if {$target in $tmake(clean-targets)} {
			set tmake(cleaning) 1
		} else {
			# Try to build all Load files
			# If any files specified to Load are targets,
			# build them before anything else
			# Note that these targets ignore --force
			set reload 0
			set tmake(ignoreforce) 1
			foreach {t nocare} $tmake(projfiles) {
				if {$nocare && ![is-target? $t]} {
					dputs-n "Load --nocare $t, not a target"
					continue
				}
				dputs {b T} "Building Load target $t"
				set status [build-sync $t]
				if {$status eq "failed"} {
					if {$tmake(exitcode) == 0} {
						build-fatal-error "Error: Failed to build $t"
					}
					break
				}
				if {$status eq "built"} {
					dputs m "$t has changed, reloading..."
					set reload 1
				}
			}
			set tmake(ignoreforce) 0

			if {$reload} {
				# Restore the state
				set tmake $tmake_save
				tmake-reset-defines

				# reinitialise the rulebase
				rulebase-invoke init

				dputs T "Reinitialised rulebase"

				load-build-description 0

				dputs T "Reparsing phase complete"
			}

			# Discard orphans before building any non-cleaning target
			do-delete-orphans [get-orphan-targets]
		}

		dputs {b T} "Building target $target"

		set status [build-sync $target]
		if {$status eq "failed"} {
			if {$tmake(exitcode) == 0} {
				if {[is-target? $target]} {
					build-error "Error: Failed to build $target"
				} else {
					build-error "Error: Don't know how to build $target"
				}
			}
			if {$tmake(quickstop)} {
				wait-for-background-jobs
				tmake-exit $tmake(exitcode)
			}
			break
		}

		if {$tmake(cleaning) || $tmake(resetstatus)} {
			# Reset the status of every rule to "unknown" after cleaning or if reset-target-status was called
			set tmake(cleaning) 0
			set tmake(resetstatus) 0
			foreach ruletarget [dict keys $tmake(rules)] {
				set-rule-status $ruletarget unknown
			}
		}

		# Add any new targets to the target list
		# These are added before current targets, so
		set addtargets {}
		foreach new $tmake(addtargets) {
			if {$new ni $targets && $new ni $addtargets} {
				dputs m "$target has added new build target $new"
				lappend addtargets $new
			}
		}
		set targets [list {*}$addtargets {*}$targets]
	}
}

proc load-tmakerc {} {
	set tmakerc [getenv HOME]/.tmakerc
	if {[file exists $tmakerc]} {
		dputs m "Loading $tmakerc"
		source $tmakerc
	}
}

proc rulebase-invoke {cmd} {
	dputs m "No rulebase-invoke, ignoring $cmd"
}

proc get-rulebase {} {
	global tmake
	if {[file exists rulebase.spec]} {
		return rulebase.spec
	} elseif {$tmake(installed)} {
		return [list rulebase.default $tmake(defaultrulebase)]
	} else {
		return [list $tmake(dir)/rulebase.default]
	}
}

# @add-build-targets target ...
#
# May be called from a -do script to dynamically add build targets
# to the list of targets to be built.
proc add-build-targets {args} {
	global tmake
	lappend tmake(addtargets) {*}$args
}

# @reset-target-status
#
# May be called from a -do script if files have been manually changed (e.g. in a phony rule)
# reset-target-status indicates that any new targets added with add-build-targets
# should have their build status set to unknown
proc reset-target-status {} {
	global tmake
	set tmake(resetstatus) 1
}

proc add-project-file {filename nocare} {
	global tmake
	lappend tmake(projfiles) $filename $nocare
}

# @add-clean-targets target...
#
# Adds the targets to list of those considered to be "cleaning" targets.
# i.e. Those that don't need to force projfiles to be loaded
proc add-clean-targets {args} {
	global tmake
	lappend tmake(clean-targets) {*}$args
}

# @set-default-target target
#
# Sets the default target, when tmake is invoked with no options.
# The default is 'all'
proc set-default-target {target} {
	global tmake
	set tmake(defaulttarget) $target
}

proc load-cache {} {
	global tmake tmakecache

	set dirty 1
	set clear 1
	if {![file exists $tmake(topbuilddir)/.makecache]} {
		dputs C ".makecache missing, starting with empty cache"
		set dirty 0
	} else {
		try {
			lassign [time {source $tmake(topbuilddir)/.makecache}] us
			dputs C "Loaded cache, .makecache in [expr {($us + 500) / 1000}]ms"
			if {$tmakecache(version) != $tmake(cacheversion)} {
				user-notice colnote ".makecache is out-of-date -- ignoring"
			} else {
				set clear 0
				set dirty 0
			}
		} on error msg {
			dputs C ".makecache failed to load, starting with empty cache"
		}
	}
	if {$clear} {
		set tmakecache $tmake(emptycache)
		# But overwrite the cache next time around
		set tmakecache(writecache) $dirty
	}
}

proc clean-cache {} {
	global tmakecache

	set count 0
	# go through headerscan and srchash and discard any entries that don't correspond to files
	# that exist (or targets for headerscan)
	foreach file [dict keys $tmakecache(srchash)] {
		if {![file exists $file]} {
			incr count
			dict unset tmakecache(srchash) $file
		}
	}
	foreach file [dict keys $tmakecache(headerscan)] {
		if {![file exists $file] && ![is-target? $file]} {
			incr count
			dict unset tmakecache(headerscan) $file
		}
	}
	if {$count} {
		note Removing $count old entries from cache
		mark-cache-dirty "clean cache"
	}
}

proc mark-cache-dirty {msg} {
	global tmakecache
	if {$tmakecache(writecache) == 0} {
		dputs C "$msg, marking cache dirty"
		set tmakecache(writecache) 1
	}
}

proc write-cache {} {
	global tmake tmakecache
	if {$tmakecache(writecache)} {
		# This should never happend because it is hard to make any changes that require
		# the cache to be updated if only install rules are -rootok
		# Writing an existing file as root is fine
		if {$tmake(isroot) && ![file exists $tmake(topbuilddir)/.makecache]} {
			# Don't call build-fatal-error here since that calls tmake-exit which calls build-fatal-error
			puts stderr [colerr colerror "Error: Refusing to create .makecache when running as root"]
			exit 1
		}
		set tmakecache(version) $tmake(cacheversion)
		unset tmakecache(writecache)
		incr tmakecache(updatecount)
		file-mkdir -rootskip $tmake(topbuilddir)
		lassign [time {
			set f [open $tmake(topbuilddir)/.makecache w]
			foreach i [dict keys $tmakecache] {
				puts $f [list set tmakecache($i) $tmakecache($i)]
			}
			close $f
		}] us
		dputs C "Wrote cache, .makecache in [expr {($us + 500) / 1000}]ms"
	} else {
		dputs C "Cache unchanged, not writing"
	}
}

proc load-build-description {loadcache} {
	global tmake tmakecache

	lassign [invoke-spec-file project.spec] rc msg opts

	# ifconfig returns code 20 to skip some or all of the file
	if {[info return $rc] ni {ok return 20}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed project.spec"

	# Note that these are global, not per-directory, so fetch the values now
	set tmake(maxjobs) [get-define MAXJOBS [get-num-cpus]]
	if {![exists -command os.fork]} {
		# No os.fork, so we can't do parallel builds
		set tmake(maxjobs) 1
	}
	dputs m "Setting maxjobs=$tmake(maxjobs)"
	set tmake(sepjobio) [get-define SEPJOBIO 1]

	# Loaded in the global scope

	foreach i $tmake(deferred) {
		uplevel #0 $i
	}

	# Now load the cache if it exists and it isn't the second time through
	if {$loadcache} {
		load-cache

		if {!$tmake(checkexternalcmds) && [dict size $tmakecache(exec)]} {
			# If disabled, discard any previously cached external command info
			dict set tmakecache exec {}
			mark-cache-dirty "external cmd cache discarded"
		}
	}

	set tmake(loadedprojectspec) 1

	process-build-spec-file . 1

	dputs m "Found [num-nonphony-targets] target(s)"


	unset tmake(prefix)
	unset tmake(localdir)

	# Now validate that there is no non-phony target which depends on a phony target
	foreach ruletarget [dict keys $::tmake(rules)] {
		if {![get-rule-attr $ruletarget phony]} {
			foreach dep [get-rule-attr $ruletarget depends] {
				if {[is-target? $dep]} {
					if {[dict get [get-target-rule $dep] phony]} {
						user-notice colwarn "Non phony target $ruletarget [make-source-location $ruletarget @] depends on phony $dep"
						tmake-exit 1
					}
				}
			}
		}
	}
}

proc is-cleaning? {} {
	return $::tmake(cleaning)
}

# ==================================================================
# .spec file processing
# ==================================================================

# Returns "" if project top not found
proc find-project-top {} {
	set topdir [pwd]
	while {![file exists $topdir/project.spec]} {
		set parent [file dirname $topdir]
		if {$topdir eq $parent} {
			dputs m "Project top not found"
			return ""
		}
		set topdir $parent
	}
	dputs m "Project top found at $topdir"
	return $topdir
}

proc local-prefix {} {
	if {![exists ::tmake(prefix)]} {
		error "local-prefix invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(prefix)
}

proc local-src-prefix {} {
	return $::tmake(topsrcdir)/$::tmake(prefix)
}

proc local-dir {} {
	if {![exists ::tmake(localdir)]} {
		error "local-dir invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(localdir)
}

proc top-src-dir {} {
	return $::tmake(topsrcdir)
}

proc make-local {args} {
	set result [lmap p $args {
		if {[string match <* $p]} {
			# no need to add prefix to aliases
			string cat $p
		} elseif {[string match /* $p]} {
			# project-root relative file
			string range $p 1 end
		} else {
			# local file
			string cat [local-prefix] $p
		}
	}]
	#puts "make-local $args => $result"
	return $result
}

proc make-local-dirs {args} {
	lmap dir $args {
		file-join [local-dir] $dir
	}
}

# Reverses make-local
proc make-unlocal {args} {
	set striplen [string length [local-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

# Reverses make-local-src
proc make-unlocal-src {args} {
	set striplen [string length [local-src-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

proc make-prefix {dir} {
	if {$dir eq "."} {
		return ""
	} else {
		return $dir/
	}
}

proc make-local-src {args} {
	prefix [local-src-prefix] $args
}

# @invoke-spec-file filename ?script?
#
# Returns a list of rc msg opts, as returned from run-do
proc invoke-spec-file {filename args} {
	global tmake

	if {$filename eq ""} {
		set cmd [lindex $args 0]
	} else {
		lappend tmake(specfiles) $filename

		# If given, the argument is the contents of the file
		if {[llength $args]} {
			set cmd [info-source [lindex $args 0] $filename 1]
		} else {
			set cmd [list source $filename]
		}
	}

	# Spec files are loaded at frame level #1, in the scope of run-do
	# 'define' relies on this
	set result [uplevel #0 [list run-do {} $cmd]]

	if {[info return [lindex $result 0]] ni {ok return 20}} {
		# If there is an error, ensure the 'Entering directory' message
		# is shown first
		enter-new-dir $tmake(topsrcdir)
	}

	if {[check-signal]} {
		tmake-exit 1
	}
	return $result
}

# @AutoSubDirs on|off
#
# If enabled (it is enabled by default), subdirectories containing
# build.spec files are automatically entered.
#
# If not enabled, SubDirs must be used to specifically select project subdirs.
proc AutoSubDirs {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(autosubdirs) 1
		}
		off {
			set ::tmake(autosubdirs) 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

# @SubDirs dir ...
#
# If AutoSubDirs is set to off, SubDirs may be used to identify which directories
# are entered.
#
# Can be used in any directory, but directory names are relative to the project top.
proc SubDirs {args} {
	foreach dir $args {
		if {![file exists $dir/build.spec]} {
			parse-error "Subdirs: No $dir/build.spec found"
		}
	}
	lappend ::tmake(subdirs) {*}$args
}

proc get-onoff-flag {onoff} {
	switch -- $onoff {
		on {
			return 1
		}
		off {
			return 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

# @CheckExternalCommands on|off
#
# default=off
#
# If enabled, external commands run with 'run' are checked
# (by path, mtime and size), and if the command changes, the corresponding target is rebuilt.
#
# Note that 'distclean' should be run if enabling this in an already-built project
proc CheckExternalCommands {onoff} {
	set ::tmake(checkexternalcmds) [get-onoff-flag $onoff]
}

# @UseHashes on|off
#
# default=off
#
# If enabled, uses hash-based file comparison rather than time-based.
#
# Note: Using --hash on the command line overrides this setting.
#
proc UseHashes {onoff} {
	# This means that UseHashes off is overridden by --hash
	if {[get-onoff-flag $onoff]} {
		incr ::tmake(usehashes)
	}
}

proc file-build {path} {
	if {[string match <* $path]} {
		return $path
	}
	#puts "file-build $path: $::tmake(build) + $path => [file-join $::tmake(build) $path]"
	return [file-join $::tmake(build) $path]
}

proc file-build-list {paths} {
	lmap p $paths { file-build $p }
}

proc build-prefix {} {
	make-prefix $::tmake(build)
}

proc build-dir {} {
	return $::tmake(build)
}

# If $srcdir is a dir from the top of the source tree,
# (defaults to [local-dir])
# return a relative path to $buildpath from the build tree.
#
proc file-build-relative {buildpath {srcdir {}}} {
	if {$srcdir eq ""} {
		set srcdir [local-dir]
	}
	if {$srcdir eq $buildpath} {
		return .
	}
	set build [file join $::tmake(topbuilddir) $buildpath]
	set src [file join $::tmake(topsrcdir) $srcdir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file-mkdir -rootskip [file dirname $src]
	relative-path $build $src
}

# If $builddir is a dir from the top of the build tree,
# (defaults to [local-dir])
# return a relative path to $srcpath from the build tree.
#
proc file-src-relative {srcpath {builddir {}}} {
	if {$builddir eq ""} {
		set builddir [local-dir]
	}
	set there [file join $::tmake(topsrcdir) $srcpath]
	set here [file join $::tmake(topbuilddir) $builddir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file-mkdir -rootskip [file dirname $here]
	relative-path $there $here
}

# Restore all defines as local variables in stack frame #1
proc tmake-reset-defines {} {
	uplevel #1 {
		unset {*}[info vars]
		dict with ::tmake(defines) {}
	}
}

# @Scope { commands }
#
# XXX
proc Scope {{dir ""} script} {
	global tmake
	# Save all defines
	set defines $tmake(defines)
	if {$dir ne ""} {
		set oldlocaldir $tmake(localdir)
		set oldprefix $tmake(prefix)
		set tmake(localdir) $dir
		set tmake(prefix) [make-prefix $dir]
	}

	set result [uplevel 1 $script]
	set tmake(defines) $defines
	# Now need to reset/restore all the variables at frame #1
	if {$dir ne ""} {
		set tmake(localdir) $oldlocaldir
		set tmake(prefix) $oldprefix
	}
	tmake-reset-defines
	return $result
}


# Read in the given spec file in the given directory (relative to topdir)
# Returns 1 if OK, or 0 if subdirs should be skipped
proc process-build-spec-file {dir {optional 0}} {
	global tmake
	dputs m "process-build-spec $dir"
	set ignore 0

	set path [file-join $dir build.spec]

	if {![file exists $path]} {
		# The top level build.spec is optional
		if {!$optional} {
			user-error "$path does not exist"
		}
		incr ignore
	}

	Scope $dir {
		rulebase-invoke prolog
		if {$ignore} {
			set rc 0
		} else {
			lassign [invoke-spec-file $path] rc msg opts

			dputs T "Parsed [local-prefix]build.spec"
		}
		rulebase-invoke epilog
	}


	if {$rc == 20} {
		dputs m "Skipping $path"
		return
	}
	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	# Now subdirectories

	# Find the explicitly set subdirs
	set subdirs $tmake(subdirs)
	set tmake(subdirs) {}

	# Normally we search for dirs containing build.spec
	if {$tmake(autosubdirs)} {
		foreach d [readdir $dir] {
			if {[file exists $dir/$d/build.spec] && $d ni $subdirs} {
				lappend subdirs [file-join $dir $d]
			}
		}
	}

	# Now process subdirs
	foreach d $subdirs {
		process-build-spec-file $d
	}
}

# @VirtualSubDir dir { ... build.spec rules ... }
#
# XXX
proc VirtualSubDir {dir code} {
	Scope $dir {
		rulebase-invoke prolog
		invoke-spec-file {} $code
		rulebase-invoke epilog
	}
}

proc do-delete-orphans {orphans} {
	if {[llength $orphans]} {
		delete-orphan-files {*}[file-build-list $orphans]
		note Clean removing [llength $orphans] orphan target(s)
		dputs C $orphans
		discard-orphan-targets
	}
}

# Returns a list of all files which were once a target but are no longer
proc get-orphan-targets {} {
	global tmakecache

	set result {}
	foreach i [dict keys $tmakecache(file)] {
		if {![is-target? $i]} {
			lappend result $i
		}
	}
	return $result
}

proc discard-orphan-targets {} {
	global tmake tmakecache
	set discard 0

	foreach i [get-orphan-targets] {
		#puts "Discarding orphan file $i"
		dict unset tmakecache(file) $i
		set discard 1
	}

	# Also discard the build commands, targets and dependencies
	foreach i [dict keys $tmakecache(cmd)] {
		if {![is-rule? $i]} {
			#puts "Discarding orphan rule $i"
			dict unset tmakecache(cmd) $i
			dict unset tmakecache(dephash) $i
			set discard 1
			foreach j $i {
				#puts "Discarding orphan target and deps $j"
				dict unset tmakecache(target) $j
				dict unset tmakecache(deps) $j
				dict unset tmakecache(exec) $j
				dict unset tmakecache(file) $j
				dict unset tmakecache(warnings) $j
				dict unset tmakecache(headerscan) $j
			}
		}
	}
	if {$discard} {
		mark-cache-dirty "discarded orphan targets"
	}
}

# Like file mkdir except if the directory doesn't exist
# and the current user is root, the option indicates what should happen.
#
## -rootskip  do nothing
## -rooterr   fatal error

proc file-mkdir {option name} {
	if {![is-uid-root] || [file isdir $name]} {
		tailcall file mkdir $name
	}
	if {$option eq "-rootskip"} {
		return
	} elseif {$option eq "-rooterr"} {
		build-fatal-error "Error: Refusing to create directory $name when running as root"
	} else {
		error "got file-mkdir $option $name, option should be -rootskip or -rooterr"
	}
}


# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	if {$::tmake(installed)} {
		return
	}
	foreach m $args {
		if {[dict exists $::tmakemodules $m]} {
			continue
		}
		dict set ::tmakemodules $m 1

		set source $::tmake(dir)/lib/${m}.tcl
		if {![file exists $source]} {
			parse-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		if {[info procs init-$m] ne {}} {
			init-$m
		}
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error ?colour? msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {{col colerror} msg} {
	puts stderr [colerr $col "Error: $msg"]
	puts stderr "Try: 'tmake --help' for options"
	tmake-exit 1
}

# @build-error ?colour? msg
#
# Indicate that something failed to build and set exitcode=1
proc build-error {{col colerror} msg} {
	if {$msg eq ""} {
		set msg "-- no message --"
	}
	dputs b "BUILD ERROR: $msg"
	puts stderr [colerr $col $msg]
	stderr flush
	set ::tmake(exitcode) 1
}

# @build-fatal-error msg
#
# Indicate that something failed to build and exit with exitcode=1
proc build-fatal-error {msg} {
	dputs b "BUILD FATAL ERROR: $msg"
	puts stderr [colerr colerror $msg]
	stderr flush
	tmake-exit 1
}


# @user-notice ?colour? msg
#
# Output the given message to stderr, possibly with the given colour.
#
proc user-notice {{col {}} msg} {
	if {$col eq {}} {
		puts stderr $msg
	} else {
		puts stderr [colerr $col $msg]
	}
}

# Incorrect usage in the build.spec file. Identify the location.
proc parse-error {msg} {
	global tmake
	# Message may contain a source reference relative to the top source dir
	enter-new-dir $tmake(topsrcdir)

	user-notice colerror [error-location "Error: $msg"]
	tmake-exit 1
}

proc parse-warning {msg} {
	user-notice colwarn [warning-location "Warning: $msg"]
}

proc wait-for-background-jobs {} {
	global tmake
	if {$tmake(jobpid)} {
		while {[wait-for-one-job] != 0} {
			dputs j "Waiting for background jobs to finish"
		}
	}
}

proc tmake-exit {code {msg {}}} {
	global tmake

	if {$tmake(jobpid) == 0} {
		exit $code
	}

	wait-for-background-jobs
	if {$msg ne ""} {
		user-notice colerror $msg
	}

	if 0 {
		# Kill off any running jobs
		foreach pid [dict keys $tmake(running)] {
			dputs j "[pid] Killing background child $pid"
			catch {kill $pid}
		}

		wait-for-background-jobs
	}

	# Write the cache before exiting
	write-cache

	dputs T Done
	exit $code
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		pputs colnote $msg
	}
}

proc pputs {{col {}} msg} {
	if {$col eq {}} {
		puts $msg
	} else {
		puts [colout $col $msg]
	}
	flush stdout
}

# Returns 1 if any of the debug types is set
proc debug-is-set {types} {
	foreach t $types {
		if {[dict get $::tmake(debugtypes) $t]} {
			return 1
		}
	}
	return 0
}

# Output a message to stdout if --debug is set.
#
proc dputs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		pputs "[colout coldebugtime [dbg-msg-indent $indent]] \[$types\] [colout coldebug $msg]"
	}
}

proc dputs-null {args} {}

# Like dputs, but msg needs to be expanded with subst
# This is used for messages which may be expensive to evaluate
proc dputxs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		dputs $types [uplevel 1 [list subst $msg]]
	}
}

proc dbg-msg-indent {{autoindent 1}} {
	global tmake

	set now [clock millis]
	if {$tmake(showdelta)} {
		set time [expr {$now - $tmake(prevtime)}]
		set tmake(prevtime) $now
	} else {
		set time [expr {$now - $tmake(start)}]
	}
	if {$autoindent && [debug-is-set G]} {
		set indent [string repeat "    " [llength $::tmake(current)]]
	} else {
		set indent {}
	}
	return [format %5dms $time]$indent
}

# ==================================================================
# Show rules, targets, aliases, etc.
# ==================================================================

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	# Note that we don't want to lose source info for $do, so
	# go to special effort to make a copy first
	set docmd [string cat $do ""]
	set lines [split $docmd \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set ruletarget [get-rule-target $target]
	} else {
		set ruletarget $target
	}
	if {[is-rule? $ruletarget]} {
		global tmakecache
		set t [get-rule $ruletarget]
		set flags {}
		set lines {}
		puts [pad "-- $ruletarget " 60 -]--
		foreach n [lsort [dict keys $t]] {
			set v $t($n)
			set type [target-option-type $n]
			if {$type eq "flag"} {
				if {$v} {
					lappend flags $n
				}
				continue
			}
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vv"
					}
				}
				onerror - finally {
					if {$v ne ""} {
						lappend lines "$n={[join [split [string trim $v] \n] {;}]}"
					}
				}
				alias {
					if {$v ne ""} {
						lappend lines "$n=$v"
					}
				}
				dyndep {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
					# Should we always show cached dyndeps?
					if {[dict exists $tmakecache(deps) $ruletarget]} {
						set dyndeps [lsort [dict get $tmakecache(deps) $ruletarget]]
						foreach dep $dyndeps {
							lappend lines "       $dep"
						}
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
				}
			}
		}
		if {[llength $flags]} {
			set flags " \[$flags\]"
		}
		puts "$t(target)$flags: $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		foreach do $t(do) {
			show-rule-commands $do
		}

	} else {
		puts "No rule for $ruletarget"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(rules)]] {
		show-rule $i
		puts ""
	}
}

proc show-cache {} {
	global tmake

	if {![file exists $tmake(topbuilddir)/.makecache]} {
		user-notice colwarn "No .makecache"
		return
	}
	set tmakecache $tmake(emptycache)
	source $tmake(topbuilddir)/.makecache

	# Files
	pputs colstatus ".makecache updated $tmakecache(updatecount) times\n"
	pputs colnote "File timestamp"
	puts "-------------------------------------"

	foreach i [lsort [dict keys $tmakecache(file)]] {
		lassign [dict get $tmakecache(file) $i] mtime
		set mtimestr [show-mtime $mtime]
		puts [format "%35s  %s" $i $mtimestr]
	}
	puts ""

	if {[dict size $tmakecache(srchash)]} {
		pputs colnote "Source Hash (mtime hash)"
		puts "---------------------------------------------"
		foreach i [lsort [dict keys $tmakecache(srchash)]] {
			lassign [dict get $tmakecache(srchash) $i] mtime hash
			puts [format "%35s  %s %s" $i [show-mtime $mtime] $hash]
		}
		puts ""
	}

	pputs colnote "Commands used to build targets and warnings"
	puts "-------------------------------------------"
	# Commands
	foreach i [lsort [dict keys $tmakecache(cmd)]] {
		puts $i:
		foreach do [dict get $tmakecache(cmd) $i] {
			show-rule-commands $do
		}
		if {[dict exists $tmakecache(warnings) $i]} {
			set warnings [dict get $tmakecache(warnings) $i]
			if {[llength $warnings]} {
				foreach msg $warnings {
					pputs colrunwarn $msg
				}
			}
		}
		puts ""
	}
}

proc show-all-targets {detailed} {
	set shown 0
	foreach i [lsort [dict keys $::tmake(targets)]] {
		if {$detailed eq ""} {
			if {![dict get [get-target-rule $i] phony]} {
				incr shown
				puts $i
			}
		} else {
			puts "$i @[make-source-location $i]"
		}
	}
	if {$shown == 0 && $detailed eq ""} {
		puts "Note: All targets are phony. Use --targets=all to show all targets"
	}
}

proc show-matching-commands {pattern} {
	global tmake

	if {$pattern eq "*"} {
		foreach info $tmake(commands-overview) {
			lassign $info loc helptext
			set lines [split [string trim $helptext] \n]
			set lines [string trim [join $lines \n]]
			pputs $lines
			pputs [string repeat - 60]
		}
	}

	set commands $tmake(commands)
	set cmds [dict keys $commands $pattern]
	if {[llength $cmds] == 0} {
		pputs colnote "No commands matched $pattern, showing commands matching ${pattern}*"
		set cmds [dict keys $commands ${pattern}*]
	}
	foreach cmd [lsort $cmds] {
		lassign $commands($cmd) loc helptext
		if {[string match *\t* $helptext]} {
			set helptext [string map [list \t <tab>] $helptext]
			pputs colnote "Warning: help text for rule $cmd contains tabs"
		}
		set otherlines [lassign [split [string trim $helptext] \n] firstline]
		set otherlines [string trim [join $otherlines \n]]
		regexp {^([^ ]*) +(.*)$} $firstline -> cmdname cmdargs
		pputs "\n[colout colrulename $cmdname] [colout colruleargs $cmdargs]"
		pputs \n$otherlines
		#puts [string repeat - 60]
	}
}

proc show-find-results {findtarget findall} {
	global tmake
	if {!$findall} {
		# Prefer a local exact match
		foreach try [list [file-join $tmake(subdir) $findtarget] $findtarget] {
			if {[is-target? $try]} {
				dputs r "find: Found exact match for $try"
				show-rule $try
				# Are there any non-exact matches?
				set count 0
				foreach target [dict keys $tmake(targets)] {
					if {[string match *$findtarget* $target]} {
						incr count
					}
				}
				if {$count > 1} {
					incr count -1
					pputs colnote "Note: $count non-exact matches also exist, use --findall to show them"
				}
				tmake-exit 0
			}
		}
	}
	dputs r "find: Showing all targets that match *$findtarget*"
	foreach target [lsort [dict keys $tmake(targets)]] {
		if {[string match *$findtarget* $target]} {
			show-rule $target
			pputs ""
		}
	}
}

proc num-nonphony-targets {} {
	set n 0
	foreach i [dict keys $::tmake(targets)] {
		if {![dict get [get-target-rule $i] phony]} {
			incr n
		}
	}
	return $n
}

# ==================================================================
# Variable Handling
# ==================================================================

# Internal implementation of define-related commands
proc define-var {name value src addsrc force} {
	global tmake
	if {[dict exists $tmake(fixedvars) $name] && !$force} {
		dputs v "define $name => not overwriting fixed value"
		return
	}
	# Normally we try to take source info from the value, but if there is none,
	# use source info from the name
	if {$src eq "" || [lindex $src 0] eq ""} {
		set src [info source $name]
	}
	if {!$addsrc} {
		dict set tmake(varloc) $name {}
	}
	dict set tmake(varloc) $name $src 1
	dict set tmake(defines) $name $value
	# Ensure that the value is visibile the current spec file
	uplevel #1 [list set $name $value]
}

# Internal command. If $list is empty, returns 1 (e.g. for "define ABC")
# otherwise returns the joined list, but preserving source information.
proc define-get-value {list} {
	if {[llength $list]} {
		set src [info source [lindex $list 0]]
		set value [join $list]
		list $value $src
	} else {
		list 1 ""
	}
}

# @define name arg ...
#
# Set a variable to the given value, unless it was defined with define!
#
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	set valueinfo [define-get-value $args]
	define-var $name {*}$valueinfo 0 0
	dputs v "define $name [join $args]"
}

# @define! name arg ...
#
# Like 'define', but marks the variable as fixed. It won't be overwritten by 'define'.
# Should be reserved for variables set directly by the user from the commandline,
# possibly indirectly
proc define! {name args} {
	dict set ::tmake(fixedvars) $name 1
	set valueinfo [define-get-value $args]
	define-var $name {*}$valueinfo 0 1
	dputs v "define! $name [join $args]"
}

# @define? name arg ...
#
# Like 'define', but only sets the variable if it is undefined
# or set to an empty value.
# Note that before setting the variable, a check is first made
# to see if the corresponding environment variable is set.
# If it is, that value is used in preference.
#
proc define? {name args} {
	if {[get-define $name] eq ""} {
		# Not set. Is it set in the environment?
		set value [getenv $name ""]
		if {$value ne ""} {
			dputs v "define (env) $name $value"
			set valueinfo [list $value {}]
		} else {
			set valueinfo [define-get-value $args]
		}
		define-var $name {*}$valueinfo 0 0
	}
	dputs v "define? $name [join $args]"
}

# @define-append name arg ...
#
# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	lassign [define-get-value $args] newvalue src
	set value [get-define $name]
	if {$value eq ""} {
		set appendsrc 0
	} else {
		set appendsrc 1
	}
	append-with-space value $newvalue
	define-var $name $value $src $appendsrc 0
	dputs v "define-append $name [join $args]"
}
# @define-list-append value ...
#
# Like define-append, but the variable is treated as a Tcl list
# and duplicate values are not appended.
#
# This may not be suitable for command lines, e.g. -I abc -I def
# where the -I would be omitted
#
proc define-list-append {name args} {
	lassign [define-get-value $args] newvalue src
	set value [get-define $name]
	if {$value eq ""} {
		set appendsrc 0
	} else {
		set appendsrc 1
	}
	# Avoid duplicates
	foreach arg $args {
		if {$arg ni $value} {
			append-with-space value $arg
		}
	}
	define-var $name $value $src $appendsrc 0
	dputs v "$name += [join $args] => $value"
}

# @get-define name ?default?
#
# Returns the current value of the given defined variable, or $default
# if not set. If not specified, $default is ""
#
proc get-define {name {default ""}} {
	if {$::tmake(parsedone)} {
		build-fatal-error "get-define $name called during build phase"
	}
	if {[dict exists $::tmake(defines) $name]} {
		#dputs v "get-define $name => [dict get $::tmake(defines) $name]"
		dict get $::tmake(defines) $name
	} else {
		#dputs v "get-define $name => default ($default)"
		return $default
	}
}

proc get-all-defines {} {
	return $::tmake(defines)
}

# Returns a list of all the locations that contributed
# to the definition of the given define.
# Each element of the list is of the form path:line
# Returns an empty list of no source information is available
proc get-define-locs {name} {
	set locs {}
	if {[dict exists $::tmake(varloc) $name]} {
		foreach loc [dict keys [dict get $::tmake(varloc) $name]] {
			if {[lindex $loc 0] ne ""} {
				lappend locs [join $loc :]
			}
		}
	}
	lsort $locs
}

proc show-all-defines {what} {
	set d [get-all-defines]
	foreach k [lsort [dict keys $d]] {
		set val [dict get $d $k]
		if {$what == 2} {
			puts -nonewline [colout colnote $k=$val]
			set locs [get-define-locs $k]
			if {[llength $locs]} {
				puts -nonewline " [join $locs ", "]"
			}
			puts ""
		} else {
			puts "$k=$val"
		}
	}
}

proc show-all-aliases {} {
	set d $::tmake(aliases)
	foreach k [lsort [dict keys $d]] {
		puts "$k=[dict get $d $k]"
	}
}

proc define-exists {name} {
	dict exists $::tmake(defines) $name
}


# ==================================================================
# Rule Handling
# ==================================================================

# If $target is an alias, return the aliased target
# Otherwise return $target
proc map-alias {target} {
	if {[dict exists $::tmake(aliases) $target]} {
		set target [dict get $::tmake(aliases) $target]
	}
	return $target
}

# Returns 1 if the target is an individual target
proc is-target? {target} {
	dict exists $::tmake(targets) [map-alias $target]
}

# Returns 1 if the target is a rule target
proc is-rule? {ruletarget} {
	dict exists $::tmake(rules) $ruletarget
}

# Converts a target to the rule target
proc get-rule-target {target} {
	dict get $::tmake(targets) [map-alias $target]
}

# Returns the rule for an individual target
proc get-target-rule {target} {
	dict get $::tmake(rules) [dict get $::tmake(targets) [map-alias $target]]
}

# Returns the rule for a rule target
proc get-rule {ruletarget} {
	dict get $::tmake(rules) $ruletarget
}

# Returns the single attribute for the given rule target
proc get-rule-attr {ruletarget attr} {
	dict get $::tmake(rules) $ruletarget $attr
}

# Like get-rule, but temporarily zaps the current rule.
# Makes it faster when updating the rule
proc take-rule {ruletarget} {
	set rule [dict get $::tmake(rules) $ruletarget]
	dict set ::tmake(rules) $ruletarget {}
	return $rule
}

proc update-rule {ruledict} {
	set ruletarget [dict get $ruledict target]
	if {![is-rule? $ruletarget]} {
		# Haven't seen this rule before so individual target pointers
		foreach t $ruletarget {
			if {[dict exists $::tmake(targets) $t]} {
				parse-error "Rule for $t was already specified [make-source-location $t @]"
			}
			dict set ::tmake(targets) $t $ruletarget
		}
		set-rule-status $ruletarget unknown
	}
	set alias [dict get $ruledict alias]
	if {$alias ne ""} {
		dict set ::tmake(aliases) $alias [lindex $ruletarget 0]
	}

	dict set ::tmake(rules) $ruletarget $ruledict
}

proc set-rule-status {ruletarget status} {
	dict set ::tmake(rulestatus) $ruletarget $status
}

proc get-rule-status {ruletarget} {
	dict get $::tmake(rulestatus) $ruletarget
}

proc show-this-rule {args} {
	if {[debug-is-set p]} {
		global tmake
		set extra ""
		set where "[find-source-location] "
		if {$where eq "unknown "} {
			set where ""
		}
		# We wan't to include any default options
		set ruleargs [lassign [info level -1] rule]
		if {[dict exists $tmake(ruledefaultopts) $rule]} {
			set ruleargs [list \[[dict get $tmake(ruledefaultopts) $rule]\] {*}$ruleargs]
		}
		lappend ruleargs {*}$args
		dputs p "$where$rule [join $ruleargs]" 0
	}
}

proc make-source-location {ruletarget {prefix {}} {suffix {}}} {
	if {[is-rule? $ruletarget]} {
		set source [get-rule-attr $ruletarget source]
	} else {
		set source [dict get [get-target-rule $ruletarget] source]
	}

	if {$source eq "unknown"} {
		return ""
	}
	return $prefix[join $source ", "]$suffix
}

# Defines a high level command.
proc rule {cmdname arglist {helptext {}} body} {
	global tmake
	if {[dict exists $tmake(commands) $cmdname]} {
		lassign [dict get $tmake(commands) $cmdname] loc help
		parse-error "Command $cmdname already defined @$loc"
	}
	if {$helptext eq ""} {
		user-notice colrulename "[join [info source $cmdname] :]:Warning: rule $cmdname has no help"
	}
	dict set tmake(commands) $cmdname [list [info source $cmdname] $helptext]
	proc $cmdname $arglist $body
}

# Should be called as the very first command in a rule that supports default option setting.
# Prepends any options given with set-default-opts
#
#
proc add-default-opts {&arglist} {
	global tmake
	set rule [lindex [info level -1] 0]
	if {[dict exists $tmake(ruledefaultopts) $rule]} {
		# Prepend any default options to the arglist
		set arglist [list {*}[dict get $tmake(ruledefaultopts) $rule] {*}$arglist]
	}
}

# Sets default options, to be prepended to the given rule
proc set-default-opts {rule options} {
	dict set ::tmake(ruledefaultopts) $rule $options
}

proc rule-overview {text} {
	global tmake
	lappend tmake(commands-overview) [list [info source $text] $text]
}

proc add-deferred-action {action} {
	global tmake
	lappend tmake(deferred) $action
}

# Returns flag, string or none
proc target-option-type {opt} {
	if {[dict exists $::tmake(emptytarget) $opt]} {
		if {[dict get $::tmake(emptytarget) $opt] eq "0"} {
			return flag
		}
		return string
	}
	return none
}

# Create a target dependency
#
# Parses the arguments and adds them to the rule base
#
proc target {ruletarget args} {
	global tmake
	# If the rule aready exists, we are updating
	if {[is-rule? $ruletarget]} {
		# Use take-rule here for efficiency
		set orig [take-rule $ruletarget]
	} elseif {[is-target? $ruletarget]} {
		# Can't update a rule via the invidual target
		set source [dict get [get-target-rule $ruletarget] source]
		parse-error "A multiple-target rule for $ruletarget was already specified at $source"
	}

	set info [parse-rule $ruletarget $args]

	#dputs p "target $ruletarget @ $info(source)"

	#show-this-rule

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	# Cache the prefix with the rule, also
	set info(local) [local-dir]

	if {![info exists orig]} {
		# Now create/update the rule
		update-rule $info
		return $ruletarget
	} else {
		set identical 1
		foreach i [dict keys $tmake(emptytarget)] {
			# XXX: Are there some fields we should not compare?
			if {$info($i) ne $orig($i)} {
				set identical 0
				break
			}
		}
		if {$identical} {
			parse-warning "$ruletarget duplicate rule ignored at  $orig(source)"
			update-rule $orig
			return $ruletarget
		}
	}

	# There is already a rule for this target, so attempt
	# to merge the two rules
	# Note: We generally want the new values to come after the existing values, so
	# merge the new data into orig

	if {[llength $info(do)] && [llength $orig(do)]} {
		#parse-error "$ruletarget already has '-do' at $orig(source)"
		if {$info(do) ne $orig(do)} {
			parse-warning "$ruletarget already has '-do' at $orig(source)"
		}
		set info(do) {}
	}
	if {$info(dyndep) ne "" && $orig(dyndep) ne ""} {
		if {$info(dyndep) eq $orig(dyndep)} {
			set info(dyndep) ""
		} else {
			parse-error "$ruletarget already has '-dyndep' at $orig(source)"
		}
	}
	lappend orig(depends) {*}$info(depends)
	lappend orig(inputs) {*}$info(inputs)
	foreach i [dict keys $tmake(emptytarget)] {
		if {[target-option-type $i] eq "flag"} {
			incr orig($i) $info($i)
		}
	}
	append-with-space orig(onerror) $info(onerror) \n
	append-with-space orig(finally) $info(finally) \n
	# Only one of these will be non-blank
	lappend orig(do) {*}$info(add-do)
	append-with-space orig(dyndep) $info(dyndep) \n

	if {$info(source) eq "unknown" || $info(source) in $orig(source)} {
		# Nothing to do
	} elseif {$info(source) ne "unknown"} {
		lappend orig(source) $info(source)
	}

	# Need to append to any vars which exist
	set orig(vars) [merge-vars $orig(vars) $info(vars)]

	# Whichever rule has '-do' also specifies '-inputs' and '-msg'
	if {[llength $orig(do)] == 0} {
		set orig(do) $info(do)
		set orig(inputs) $info(inputs)
		set orig(msg) $info(msg)
	}
	update-rule $orig

	# Return the rule target for composability
	return $ruletarget
}

# Adds the list elements to the target-specific variable.
#
# This a much faster equivalent of:
#
#     target $ruletarget -vars $varname {*}$list
#
proc target-add-var {ruletarget varname list} {
	# The rule must already exist
	if {![is-rule? $ruletarget]} {
		parse-error "$ruletarget is not a rule target"
	}
	# Note that if we do this blindly, we will duplicate the dict
	# Instead, get the current value. Replace it.
	# lappend.
	# Update it
	set vars [dict get $::tmake(rules) $ruletarget vars $varname]
	dict set ::tmake(rules) $ruletarget vars $varname {}
	lappend vars {*}$list
	dict set ::tmake(rules) $ruletarget vars $varname $vars
}

proc parse-rule-args {arglist} {
	set info {}

	set opt {}
	set skip 1
	set n 0
	foreach arg $arglist {
		if {($n % $skip == 0) && [string match -* $arg]} {
			# Remove the leading dash
			set opt [string range $arg 1 end]
			if {![exists info($opt)]} {
				set info($opt) {}
			}
			set n 0
			set skip 1
			if {$opt eq "vars"} {
				set skip 2
			}
			continue
		}
		if {$opt eq ""} {
			parse-error "Missing option: $arglist"
		}
		lappend info($opt) $arg
		incr n
	}
	return $info
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-rule {target arglist} {
	global tmake
	set info $tmake(emptytarget)

	# Note that we prefer build.spec over project.spec and rulebase.spec when
	# finding the source of a rule
	foreach pattern {build.spec *.spec *.default} {
		set info(source) [find-source-location $pattern]
		if {$info(source) ne "unknown"} {
			break
		}
	}
	set info(target) $target

	# split the arglist into a dictionary
	set arginfo [parse-rule-args $arglist]

	# And check/post-process the options
	set add 0
	foreach {opt optargs} $arginfo {
		# Special -add option
		if {$opt eq "add"} {
			incr add
			continue
		}
		set type [target-option-type $opt]

		if {$type eq "none"} {
			parse-error "Rule for $target has unknown option: -$opt"
		}
		if {$type eq "flag"} {
			if {[llength $optargs]} {
				parse-error "Rule for $target has non-option parameters after -$opt: $optargs"
			}
			set info($opt) 1
			continue
		}
		switch -exact -- $opt {
			inputs - depends {
				set info($opt) [join $optargs]
			}
			msg {
				# last one wins
				set info($opt) [lindex $optargs end]
			}
			do - dyndep - onerror - finally - alias {
				if {[llength $optargs] > 1} {
					parse-error "Rule for $target has more than one '-$opt' parameter"
				}
				if {$opt eq "do"} {
					set info($opt) $optargs
				} else {
					set info($opt) [lindex $optargs 0]
				}
			}
			vars {
				if {[llength $optargs] % 2} {
					parse-error "Rule for $target has an odd number of parameters to '-vars'"
				}
				# Need to use lappend here so that they are combined with getvars
				lappend info($opt) {*}$optargs
			}
			getvars {
				foreach v $optargs {
					if {![define-exists $v]} {
						parse-error "Rule for $target has -getvars for non-existent variable: $v"
					}
					lappend info(vars) $v [get-define $v]
				}
			}
		}
	}

	if {$add} {
		if {![llength $info(do)]} {
			parse-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) $info(do)
		set info(do) {}
	} else {
		set info(add-do) {}
	}

	if {[llength $info(do)] == 0 && [llength $info(inputs)]} {
		parse-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {[llength $info(do)] == 0 && $info(msg) ne ""} {
		parse-error "Rule for $target has '-msg' but no '-do'"
	}

	return $info
}

# ==================================================================
# Dependency Engine
# ==================================================================

# Returns the "hash" of the given file, that must exist.
#
# If hashing is disabled, simply returns file-mtime
#
# If hashing is enabled, first checks file-mtime, and if
# there is a srchash entry in the cache that matches, return the hash
# from the cache. Otherwise calculate the hash, store it in the
# cache and return it.
#
proc get-file-hash {file} {
	set mtime [file-mtime $file]
	if {!$::tmake(usehashes)} {
		return $mtime
	}

	global tmakecache tmake

	# Does it exists in the source hash cache with the same mtime?
	if {[dict exists $tmakecache srchash $file]} {
		lassign [dict get $tmakecache srchash $file] cachedmtime cachedhash
		if {$mtime == $cachedmtime} {
			return $cachedhash
		}
	}

	# Not in the source hash cache, or mtime has changed, so recalculate
	lassign [time {
		set hash md5:[md5sum $file]
	}] us
	incr tmake(hashtime) $us
	dputs h "md5sum $file => $hash"
	dict set tmakecache srchash $file [list $mtime $hash]
	mark-cache-dirty "source hash updated"

	return $hash
}

# The file may be a source, target symlink, target with -hash set
# or regular target
# Calculates the file hash as follows:
# source               - get-file-hash $file
# target is symlink    - link:[readlink [file-build $file]]
# target with -hash    - get-file-hash of [file-build $file]
# target               - file-mtime of [file-build $file]
#
proc calc-file-hash {file} {
	if {[is-target? $file]} {
		set realfile [file-build [map-alias $file]]
		set type [file-type $realfile]
		if {$type eq "link"} {
			# symlinks aways hash to the link contents
			return link:[file readlink $realfile]
		}
		if {[dict get [get-target-rule $file] hash]} {
			return [get-file-hash $realfile]
		} elseif {$::tmake(norun) && $type eq "none"} {
			return 0
		} else {
			return [file-mtime $realfile]
		}
	}

	# Otherwise it is source, so use the source hash (possibly from cache)
	return [get-file-hash $file]
}

# Calculates the hash of each file in the list
# (in sorted order) and returns the list
proc calc-deplist-hash {list} {
	set calchashlist {}
	foreach dep [lsort $list] {
		lappend calchashlist $dep [calc-file-hash $dep]
	}
	return $calchashlist
}


# Both $targets and $depends are lists of files which must exist
# Calculate the hash of all files in $depends
# If this matches the saved hash, 0 is returned.
# Otherwise:
# - save/update the calculated hash in dephash
# - append the details of the mismatch to 'reason' 
# - the ruletarget is out of date so 1 is returned.
#
proc needbuild? {ruletarget depends &reason} {
	global tmake tmakecache
	if {![dict exists $tmakecache dephash $ruletarget]} {
		set savedhash {}
	} else {
		set savedhash [dict get $tmakecache dephash $ruletarget]
	}
	set calchash [calc-deplist-hash $depends]
	if {$calchash eq $savedhash} {
		dputs n "Deps for $ruletarget are unchanged, not building"
		return 0
	}
	if {$savedhash eq ""} {
		dputs b "No saved hash for $ruletarget"
		lappend reason no-hash
	} else {
		dputs b "Deps for $ruletarget have changed, so rebuild"
		dputs B "old hash: $savedhash"
		dputs B "new hash: $calchash"
		# Give a meaninful reason
		if {[debug-is-set g]} {
			foreach {sfile shash} $savedhash {cfile chash} $calchash {
				if {$sfile ne $cfile} {
					lappend reason newdeps
					break
				} elseif {$shash ne $chash} {
					lappend reason changed $sfile
					break
				}
			}
		} else {
			lappend reason changed
		}
	}
	# Save the newly calculated hash
	dict set tmakecache dephash $ruletarget $calchash
	mark-cache-dirty "target hash updated"
	return 1
}

proc locate-files {files} {
	set result {}
	foreach f $files {
		if {[is-target? $f]} {
			#puts "$f is a target => [file-build $f]"
			# If the target is a full path, keep it
			lappend result [file-build $f]
		} else {
			#puts "$f is not a target"
			lappend result $f
		}
	}
	#puts "locate-files $files => $result"
	return $result
}

# Returns a dictionary with the bound and rule-specific variables
proc make-var-dict {info} {
	set vardict [dict get $info vars]
	dict set vardict target [file-build-list [dict get $info target]]
	dict set vardict targetname [dict get $info target]
	dict set vardict local [dict get $info local]
	dict set vardict build [file-build [dict get $info local]]
	dict set vardict depends [locate-files [dict get $info depends]]
	dict set vardict inputs [locate-files [dict get $info inputs]]
	#parray vardict
	return $vardict
}

proc add-warning-msg {msg} {
	lappend ::tmake(warningmsgs) $msg
}

proc note {type args} {
	if {$::tmake(verbose) != 1} {
		pputs "    [pad $type 12] [join $args]"
	}
}

# @tmake-require-version <version-needed>
#
# Checks the current version of tmake against that required.
# A fatal error is generated if the current version is less than that needed.
#
proc tmake-require-version {needversion} {
	use util

	global tmake
	set haveversion [lindex $tmake(version) 0]
	if {[compare-versions $haveversion $needversion] < 0} {
		build-fatal-error "tmake $needversion required, but this is $tmake(version)"
	}
}

proc fork-job-if-required {} {
	global tmake

	if {$tmake(maxjobs) > 1 && $tmake(sync) == 0 && $tmake(jobpid) == -1} {
		wait-for-job-slots
		set pid [add-new-job $tmake(currentruletarget) $tmake(currentnotifytarget) $tmake(chdir)]
		set tmake(jobpid) $pid
	}
	return $tmake(jobpid)
}

# Searches for the command '$cmd' in the path and returns a string that combines:
# - fullpath (or - if not found)
# - mtime
# - size
# Thus is the external command changes, the returned key will change.
proc stat-cmd-in-path {cmd} {
	# Dummy stat
	set stat {mtime 0 size 0 cmdpath -}
	# At this point, before forking, determine if we need to cache the external
	# command as a dependency
	foreach path [split-path] {
		set cmdpath [file join $path $cmd]
		if {[file-isexec $cmdpath]} {
			# Found in the path
			file stat $cmdpath stat
			set stat(cmdpath) $cmdpath
			break
		}
	}
	return $stat(cmdpath),$stat(mtime),$stat(size)
}

proc run {args} {
	global tmake tmakecache

	set cmdline [join $args]
	set cmd [lindex $cmdline 0]
	#puts "run: do we need to convert $cmd to a path from [pwd]?"
	# Is cmd a file in the current dir?
	if {![string match */* $cmd] && [file isfile $cmd]} {
		set cmdline ./$cmdline
	} elseif {$tmake(checkexternalcmds)} {
		# Update the cache with the details of this command
		dict set tmakecache exec $tmake(currentruletarget) $cmd [stat-cmd-in-path $cmd]
	}

	vputs [string trim $cmdline]

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		add-warning-msg $msg
		pputs colrunwarn $msg
	}
	if {$rc} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		if {$msg ne ""} {
			build-error "$msg\n"
		}
		return -code break
	}
	# XXX: What to do on signal?
}

proc run-tmake {args} {
	global tmake

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	set cmdline [list tmake {*}$tmake(cli-options) {*}$args]

	dputs m $cmdline
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		pputs colrunwarn $msg
	}
	if {$rc == 1} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		build-error "$msg\n"
		return -code break
	}
}

proc calc-dyndeps {vardict target} {
	set t [get-rule $target]
	#puts "=============="
	#parray t

	set dyndeps {}
	if {$t(dyndep) ne ""} {
		# Note that we only look at $inputs when scanning for dyndeps, not $depends
		# XXX: Is this correct?
		foreach i $t(inputs) {
			lassign [run-do $vardict [concat $t(dyndep) $i]] rc result opts
			if {$rc == 0} {
				lappend dyndeps {*}$result
			} else {
				return -code $rc {*}$opts $result
			}
		}
		dputs-d "Dynamic dependencies for $target: $dyndeps"
	}
	return $dyndeps
}

proc file-mtime-if-exists {file {symlink 0}} {
	#puts -nonewline "file-mtime-if-exists $file $symlink => "
	if {$symlink} {
		if {[catch {file readlink $file}]} {
			#puts "0 (not a symlink)"
			return 0
		}
		#puts "[file-lmtime $file]"
		return [file-lmtime $file]
	}
	if {[file exists $file]} {
		#puts "[file-mtime $file]"
		return [file-mtime $file]
	}
	#puts "0 (noexist)"
	return 0
}

proc file-exists-all {list missingname} {
	upvar $missingname missing
	foreach f $list {
		if {[is-target? $f]} {
			set symlink [dict get [get-target-rule $f] symlink]
			set mtime [file-mtime-if-exists [file-build $f] $symlink]
		} else {
			set mtime [file-mtime-if-exists $f]
		}
		if {$mtime == 0} {
			set missing $f
			return 0
		}
	}
	return 1
}

# Run variable [subst] on the given '-do' scripts (a list of -do commabds)
# This is used to determine if the commands have changed for the target.
proc subst-do {__target __vardict __do_list} {
	# Create local vars based on $::tmake(defines) and $__vardict
	# to be used in subst
	dict with ::tmake(defines) {}
	dict with __vardict {}

	# Return a list of substituted '-do' scripts
	lmap __each_do $__do_list {
		# Force __each_do to be copied so that we don't lose source info in the original
		set __each_do [string cat $__each_do ""]
		set source [info source $__each_do]
		# Note: It is an error if the subst fails
		if {[catch {subst -nob -noc $__each_do} __result __opts]} {
			# subst failed -- most likely because a variable was referenced that didn't exist.
			tmake-exit 1 "[join $source :]:Error: $__result while building $__target"
		}
		set __result
	}
}

# Set up the defines and local vars and evaluate the script
# Returns a list of {ret msg opts stacktrace} from catch
#
proc run-do {__vardict __script} {
	if {$__script eq {}} {
		# Optimisation
		return [list 0 {} {}]
	}
	dict with ::tmake(defines) {}
	dict with __vardict {}
	set result [list [catch $__script msg opts] $msg $opts]
	#puts "run-do returned $result"
	return $result
}

proc enter-new-dir {dirname} {
	global tmake
	if {$tmake(lastchdir) ne $dirname} {
		# emulate make for vim quickerr
		pputs colenterdir "tmake: Entering directory `$dirname'"
		set tmake(lastchdir) $dirname
	}
}

proc wait-for-one-job {} {
	global tmake
	while {[dict size $tmake(running)]} {
		lassign [wait -1] status pid code
		if {$pid <= 0} {
			#user-notice colwarn "Warning: No child processes, but tmake(running) is not empty"
			break
		}
		if {[dict exists $tmake(running) $pid]} {
			set job [dict get $tmake(running) $pid]
			dict unset tmake(running) $pid

			lassign $job ruletarget notifytarget chdir outfile errfile
			dputs j "Job $pid building $ruletarget has finished with $status\($code), needed by $notifytarget"
			if {$status eq "CHILDSTATUS" && $code == 0} {
				set rc 0
			} else {
				set rc 1
			}

			# If job I/O was captured in separate files, display it now
			if {$outfile ne ""} {
				set stdmsg [readfile $outfile]
				if {$stdmsg ne ""} {
					# Remove any trailing newlines
					set stdmsg [string trimright $stdmsg \n]
					add-warning-msg $stdmsg
					enter-new-dir $chdir
					pputs colrunwarn $stdmsg
				}
				file delete $outfile
			}
			if {$errfile ne ""} {
				set errmsg [readfile $errfile]
				if {$errmsg ne ""} {
					set stdmsg [string trimright $errmsg \n]
					enter-new-dir $chdir
					if {$rc} {
						build-error $errmsg
					} else {
						pputs colerror $errmsg
					}
				}
				file delete $errfile
			}

			# Set the status, update the cache, delete any files on error, etc.
			target-post-build $ruletarget $rc

			if {$rc == 0} {
				dict incr tmake(pending) $notifytarget -1
				if {[dict get $tmake(pending) $notifytarget] == 0} {
					if {[get-rule-status $notifytarget] eq "waiting"} {
						dputs j "Status of $notifytarget changed from waiting => unknown"
						set-rule-status $notifytarget unknown
					}
				}
			} else {
				dputs j "Status of $notifytarget set to failed"
				set-rule-status $notifytarget failed

				if {$tmake(quickstop)} {
					tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
				}
			}
			return 1
		}
		dputs j "Ignoring unknown pid $pid"
	}
	dputs j "All jobs have finished"
	return 0
}

proc wait-for-job-slots {} {
	global tmake

	while {[dict size $tmake(running)] >= $tmake(maxjobs)} {
		dputs j "Waiting for a job slot to be available"
		wait-for-one-job
	}
}

proc add-new-job {ruletarget notifytarget chdir} {
	global tmake
	if {$tmake(sepjobio)} {
		# Capture job I/O to temporary files so that it doesn't interleave
		set fout [open [file tempfile] w]
		set ferr [open [file tempfile] w]
	} else {
		set fout ""
		set ferr ""
	}
	set pid [os.fork]
	if {$pid == 0} {
		# Turn off debugging in the child unless --debug is set to avoid confusion
		if {!$tmake(debug)} {
			foreach t [dict keys $tmake(debugtypes)] {
				dict set tmake(debugtypes) $t 0
			}
		}
		# And turn off colour output
		set tmake(colout) 0
		set tmake(colerr) 0
	}
	if {$pid > 0} {
		dputs j "Adding job $pid for $ruletarget"
		# Insert the job in the slot
		set-rule-status $ruletarget running
		if {$tmake(sepjobio)} {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir [$fout filename] [$ferr filename]]
			$fout close
			$ferr close
		} else {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir "" ""]
		}
		dict incr tmake(pending) $notifytarget
	} elseif {$tmake(sepjobio)} {
		# This is the child. Redirect stdout and stderr to temporary files.
		rename stdout ""
		rename $fout stdout
		rename stderr ""
		rename $ferr stderr
	}
	return $pid
}

# Runs [build $target] until it either fails or succeeds
proc build-sync {target} {
	while 1 {
		set status [build $target]
		if {$status in {waiting running}} {
			dputs j "Waiting for $target to complete..."
			wait-for-one-job
			continue
		}
		return $status
	}
}

proc target-post-build {ruletarget rc {msg {}} {opts {}}} {
	global tmake tmakeprecache tmakecache

	# Pick up the info from the precache

	set info $tmakeprecache($ruletarget)

	set t $info(rule)
	set target $info(target)
	set dyndeps $info(dyndeps)
	set vardict $info(vardict)

	set status built

	# These needs to be run from topsrcdir
	set savepwd [pwd]
	cd $tmake(topsrcdir)

	# Did the rule make the targets?
	if {$rc == 0 && !$t(phony) && ![is-cleaning?]} {
		foreach f $ruletarget {
			set mtime [file-mtime-if-exists [file-build $f] $t(symlink)]
			if {$mtime == 0} {
				# XXX: Should onerror run here if --quickstop is set?
				# XXX: Should the cache still be updated?
				build-error "[make-source-location $ruletarget "" ": "]Error: Rule for $target failed to build target(s) $f ([file-build $f])"
				# Use break to indicate that we have already output the message
				set rc 3
			} elseif {!$t(nocache)} {
				# Record the time that this target was created.
				# This is used exclusively to remove orphan targets
				#puts "Set cachetime of $f=[show-mtime $mtime]"
				dict set tmakecache(file) $f $mtime
				# Remember the rule which built this target
				dict set tmakecache(target) $f $ruletarget
			}
		}

		# Save the commands in the command cache and the list of dyndeps
		# and any warning messages
		dict set tmakecache(cmd) $ruletarget [subst-do $ruletarget $vardict $t(do)]
		dict set tmakecache(deps) $ruletarget [lsort $dyndeps]
		dict set tmakecache(warnings) $ruletarget $tmake(warningmsgs)
		mark-cache-dirty "Targets built"
	}

	if {$rc == 0} {
		if {!$t(phony)} {
			incr tmake(numtargets)
		}
	} else {
		# On failure, delete the target(s)
		file delete {*}[file-build-list $ruletarget]
		dputs b "build failed so deleting [file-build-list $ruletarget]"

		# It's probably not necessary to do this since we just deleted the files,
		# but it's probably better than leaving 
		dputs h "target $ruletarget failed, so resetting dephash"
		dict set tmakecache dephash $ruletarget failed
		mark-cache-dirty "dephash updated on failed build"

		# Try to run onerror
		lassign [run-do $vardict $t(onerror)] frc fmsg fopts
		if {$frc} {
			# Hmmm. Is the stack trace going to be useful if this is a background job?
			# We really want the subprocess to collect that as part of its error output
			build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		} elseif {$rc == 1} {
			if {$msg ne ""} {
				# failed background task will supply it's own error message
				build-error [error-stacktrace $msg $opts(-errorinfo)]
			}
		}
		set status failed
	}

	lassign [run-do $vardict $t(finally)] frc fmsg fopts
	if {$frc} {
		build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		set status failed
	}

	set-rule-status $ruletarget $status

	# No longer need this
	unset tmakeprecache($ruletarget)

	# Reset warnings
	set tmake(warningmsgs) {}

	cd $savepwd
}

proc build-deps {target ruletarget status depends phony &reason} {
	global tmake

	set count {
		failed 0
		waiting 0
		running 0
		built 0
		uptodate 0
	}

	foreach dep $depends {
		set ret [build $dep $ruletarget]

		if {[check-signal]} {
			tmake-exit 2 "*** Build cancelled"
		}

		incr count($ret)

		switch $ret {
			failed {
				if {$tmake(exitcode) == 0} {
					build-error "[make-source-location $ruletarget]:Error: Don't know how to build $dep: [join [lreverse $tmake(current)] { <= }]"
				}
				if {$tmake(quickstop)} {
					tmake-exit 1 "*** Error: Targets failed to build"
				}
			}
			built {
				lappend reason depend $dep
			}
		}
	}

	if {$count(running) || $count(waiting)} {
		dputs j "$target has $($count(running) + $count(waiting)) outstanding jobs - waiting"
		return waiting
	}
	if {$count(failed)} {
		dputs b "$target has failed dependencies - failed"
		return failed
	}

	if {!$phony && $tmake(norun) && $count(built)} {
		# If running tmake -n, we can't rely on the actual target to be updated
		# We need to assume that the target needs updating
		dputs b "$target has built dependencies (-n) - built"
		return built
	}

	# Note that previously we returned "built" if a dependency was "built"
	# but there is no need to do this. This allows commands to run but leave targets unchanged.

	#dputs n "$target dependencies are all uptodate - $status"
	return $status
}


# ==================================================================
# build
#
# This is the workhorse of tmake.
# If possible, it builds $target, including any required dependencies
# Returns the target status (also stored as targetstatus):
#          uptodate    if nothing to do,
#          failed      if unable to be built
#          built       if built
#          waiting     if waiting for dependencies to build
#          running     if job is running in the background
# ==================================================================

proc build {target {notifytarget {}}} {
	global tmake tmakecache
	if {![is-target? $target]} {
		# Cache the result here, mostly to avoid excess messages
		if {[dict exists $tmake(targetstatus) $target]} {
			set ret [dict get $tmake(targetstatus) $target]
		} else {
			dputs-G "build $target"
			if {[file exists $target]} {
				dputs-n "$target is not a target, but exists"
				set ret uptodate
			} else {
				dputs b "$target is not a target and does not exist"
				set ret failed
			}
			dict set tmake(targetstatus) $target $ret
		}
		return $ret
	}

	set ruletarget [get-rule-target $target]
	set oldstatus [get-rule-status $ruletarget]

	switch $oldstatus {
		running {
			dputs j "$ruletarget is still running"
			return running
		}
		uptodate {
			return uptodate
		}
		built {
			#dputs b "$target has previously been built"
			return built
		}
		checking {
			set current [list {*}$tmake(current) $target]
			build-fatal-error "[make-source-location $ruletarget]:Error: Recursive definition for [join [lreverse $current] { <= }]"
		}
		failed {
			dputs b "$target has previously failed to build"
			return failed
		}
		unknown - waiting {
			dputs-G "build $target"
		}
		default {
			error "Bad status: $oldstatus"
		}
	}

	# Set the status now to detect recursive dependencies
	set-rule-status $ruletarget checking
	set oldcurrent $tmake(current)
	lappend tmake(current) $target

	set t [get-rule $ruletarget]

	set reason {}
	if {$t(phony)} {
		dputs b "$target is phony, so rebuilding"
		lappend reason phony
		set status built
	} elseif {![file-exists-all $ruletarget missing]} {
		dputs b "$missing doesn't exist, so rebuilding"
		lappend reason noexist
		set status built
	} else {
		#dputs b "$ruletarget exists, so checking dependencies"
		set status uptodate
	}

	# Here is the plan to build $target
	# 1. Run 'build' for each static dependency
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 2. Calculate any dynamic dependencies for $target and run 'build' for each one
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 3. If nothing was built ($result is uptodate), check each static+dynamic dependency for time
	#    - If needbuild? returns 1, the target needs to be built
	# 4. If build not forced, check substituted '-do' against any cached value
	#    - If cached commands exists and they are different, the target needs to be built
	# 5. If build not forced, check any cached 'exec' entries to see if external dependencies have changed
	#    - If so, the target needs to be built

	set vardict [make-var-dict $t]

	# 1. First build static dependencies
	set depends $t(depends)
	set status [build-deps $target $ruletarget $status $t(depends) $t(phony) reason]
	if {$status in {uptodate built}} {
		# 2. Build dynamic dependencies
		# Note: Only targets or existing files are returned by calc-dyndeps.
		set dyndeps [calc-dyndeps $vardict $ruletarget]
		lappend depends {*}$dyndeps
		set status [build-deps $target $ruletarget $status $dyndeps $t(phony) reason]
	}

	if {$status eq "uptodate" && !$t(phony) && [llength $t(do)]} {
		# If the list of dependencies has changed, the target needs to be built

		if {![dict exists $tmakecache(deps) $ruletarget]} {
			# XXX why are we checking llength $t(depends) here?
			if {[llength $t(depends)]} {
				dputs b "No previous dyndeps for $ruletarget"
				set status built
				lappend reason nocache
			}
		} elseif {[lsort $dyndeps] ne [dict get $tmakecache(deps) $ruletarget]} {
			dputs b "dyndeps for $ruletarget have changed, so forcing build"
			if {[debug-is-set d] && [debug-is-set b]} {
				set olddeps [dict get $tmakecache(deps) $ruletarget]
				puts "=== old ==="
				puts [join [lsort $olddeps] \n]
				puts "=== new ==="
				puts [join [lsort $dyndeps] \n]
				puts "-----------"
			}
			set status built
			lappend reason dyndeps
		}
	}

	if {$tmake(quickstop) && $tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}

	if {$status eq "uptodate" && ([llength $depends] || $tmake(usehashes))} {
		# 3.  Target exists but no dependencies were built so check time/hash dependencies
		#     Note that we can't do this mtime check with no dependencies, but we can do a hash check
		if {[needbuild? $ruletarget $depends reason]} {
			set status built
		}
	} elseif {!$t(phony) && $status in {built uptodate}} {
		# If a target is determined to be uptodate or built without
		# checking dependencies, it won't have it's hash updated in the cache.
		# So do it now. Could wait until it has succeeded, but that could be
		# some time away if the job is run in the background
		set calchash [calc-deplist-hash $depends]
		dputs h "updating hash for $ruletarget (status=$status): $calchash"
		dict set tmakecache dephash $ruletarget $calchash
		mark-cache-dirty "target hash updated"
	}

	# If this target belongs to a different rule than previously...
	if {$status eq "uptodate" && [llength $t(do)] && [dict exists $tmakecache(target) $target]} {
		if {$ruletarget ne [dict get $tmakecache(target) $target]} {
			dputs b "Target $target is built by a different rule"
			dputs B "Was [dict get $tmakecache(target) $target] but is now $ruletarget"
			lappend reason newrule
			set status built
		}
	}

	# This is done now so that (e.g.) vardicts(inputs) is consistent between the build commands
	# check and the build step
	if {$t(chdir)} {
		# Note that -chdir uses the *first* target to determine the directory
		set tmake(chdir) [file-normalize [file-build [file dirname [lindex $ruletarget 0]]]]
		# And we want $inputs, $depends and $target to refer to filenames relative
		# to tmake(chdir), so update these variables to take the chdir into account
		foreach var {inputs depends target} {
			set vardict($var) [lmap p $vardict($var) {
				relative-path [file-join $tmake(topsrcdir) $p] $tmake(chdir)
			}]
		}
	} else {
		set tmake(chdir) $tmake(topsrcdir)
	}

	# 4. Compare previous '-do' commands with current commands
	if {$status eq "uptodate" && [llength $t(do)]} {
		if {![dict exists $tmakecache(cmd) $ruletarget]} {
			# XXX: Do we need a special flag that doesn't rebuild if no dependencies?
			# For now always rebuild
			if {1 || [llength $t(depends)]} {
				dputs b "No cached commands for $ruletarget, so forcing rebuild"
				lappend reason nocache
				set status built
			}
		} else {
			set do [subst-do $ruletarget $vardict $t(do)]
			set prevdo [dict get $tmakecache(cmd) $ruletarget]
			if {$do ne $prevdo} {
				dputs {b B} "Commands for $ruletarget have changed, so forcing rebuild"
				if {[debug-is-set B]} {
					puts "=== old ==="
					foreach d $prevdo {
						show-rule-commands $d
					}
					puts "=== new ==="
					foreach d $do {
						show-rule-commands $d
					}
					puts "-----------"
				}
				lappend reason commands
				set status built
			} else {
				dputs-n "Commands for $ruletarget are unchanged"
			}
		}
	}

	# 5. Check any cached 'exec' entries to see if external dependencies have changed
	if {$status eq "uptodate" && $tmake(checkexternalcmds)} {
		if {[dict exists $tmakecache(exec) $ruletarget]} {
			set execinfo [dict get $tmakecache(exec) $ruletarget]
			foreach {exec info} $execinfo {
				set s [stat-cmd-in-path $exec]
				if {$s ne $info} {
					dputs b "External command '$exec' for $ruletarget has changed, so forcing rebuild"
					set status built
					lappend reason extcmd
					break
				}
			}
		}
	}

	if {$status eq "uptodate" && $tmake(force) && !$tmake(ignoreforce)} {
		dputs b "Rebuilding $target because of --force"
		lappend reason force
		set status built
	}

	if {$status eq "built" && [llength $t(do)]} {
		if {!$t(rootok) && $tmake(isroot)} {
			dputs b "Running command for $target as root"
			dputs b $t(do)
			build-fatal-error "Error: [make-source-location $ruletarget] Refusing to run command for $target as root"
			set status failed
		}
	}

	if {$status eq "built" && [llength $t(do)]} {
		dputs g "[join $tmake(current) { --> }] ($reason)" 0

		set tmake(sync) 1

		dputs b "Building [join [lreverse $tmake(current)] { <= }] [make-source-location $ruletarget "with rule @"]"
		lassign [run-do $vardict $t(msg)] rc msg opts
		if {$rc != 0} {
			build-error [error-stacktrace $msg $opts(-errorinfo)]
		}

		if {[debug-is-set r]} {
			dputs r "Rule for $ruletarget"
			show-rule $ruletarget
		}

		if {$tmake(norun)} {
			if {$tmake(norun) == 1} {
				foreach do [subst-do $ruletarget $vardict $t(do)] {
					show-rule-commands $do
				}
			}
			set rc 0
		} else {
			if {$notifytarget eq ""} {
				set tmake(sync) 1
				if {$tmake(maxjobs) > 1} {
					dputs j "$ruletarget: notifytarget is empty, so building synchronously"
				}
			} else {
				set tmake(sync) 0
			}

			# Create all the target directories as required
			set dirlist {}
			foreach i $ruletarget {
				set targetdir [file-build [file dirname $i]]
				if {![file isdir $targetdir]} {
					lappend dirlist $targetdir
				}
			}
			if {[llength $dirlist]} {
				dputs m "mkdir [join $dirlist]"
				if {$t(rootok) || !$tmake(isroot)} {
					file mkdir {*}$dirlist
				}
			}

			enter-new-dir $tmake(chdir)

			# If necessary, chdir now
			if {$t(chdir)} {
				dputs m "cd $tmake(chdir)"
				cd $tmake(chdir)
			}

			# Stash info for this rule that can be used in target-post-build either
			# immediately, or when the background job finishes
			global tmakeprecache

			set tmakeprecache($ruletarget) [dict create rule $t target $target dyndeps $dyndeps vardict $vardict]

			# Set these in case the job needs to be forked into the background
			set tmake(currentnotifytarget) $notifytarget
			set tmake(currentruletarget) $ruletarget
			set tmake(jobpid) -1
			set tmake(warningmsgs) {}
			incr tmake(sync) $t(nofork)

			# Check the 'slow' flag of the target to see if we should fork
			if {$t(slow)} {
				fork-job-if-required
			}
			if {$tmake(jobpid) <= 0} {
				# child process or sync, so run the jobs
				foreach do $t(do) {
					set oldenv [env-save]
					if {!$t(rootok) && $tmake(isroot)} {
						build-fatal-error "Error: [make-source-location $ruletarget] Refusing to run command for $target as root"
					} else {
						lassign [run-do $vardict $do] rc msg opts
					}
					env-restore $oldenv
					if {$tmake(jobpid) > 0} {
						# run has forked and this is the parent
						break
					}
					if {$rc} {
						if {$t(nofail) && [info return $rc] eq "error"} {
							user-notice colnote "\[ignored\] $msg"
							set rc 0
						} else {
							break
						}
					}
				}
			}

			# Always restore the current dir afterwards
			cd $tmake(topsrcdir)

			incr tmake(sync) -$t(nofork)

			if {$tmake(jobpid) > 0} {
				set status running
			} else {
				# Now the child is done
				if {[check-signal 1]} {
					# Caught a signal
					dputs j "Got signal while building $ruletarget"
					if {$tmake(jobpid) == 0} {
						exit 2
					}
					pputs ""
					tmake-exit 2 "*** Build cancelled"
				}
				if {$tmake(jobpid) == 0} {
					if {$rc} {
						dputs j "Job [pid] ($ruletarget) failed with rc=$rc, msg=$msg, opts=$opts"
						# Must output the failure here since it's the only place we have the strack trace
						dputs b "BUILD ERROR: $msg"
						if {[exists opts(-errorinfo)]} {
							puts stderr [colerr colerror [error-stacktrace $msg $opts(-errorinfo)]]
						} elseif {$msg ne ""} {
							puts stderr [colerr colerror $msg]
						}
						exit 1
					} else {
						dputs j "Job [pid] ($ruletarget) succeeded"
						exit 0
					}
				}
				if {$rc} {
					set status failed
				} else {
					set status built
				}
			}
			set tmake(sync) 1
		}

		if {!$tmake(norun)} {
			if {$status ne "running"} {
				target-post-build $ruletarget $rc $msg $opts
			}
		}

		if {($tmake(quickstop) || $t(fatal)) && $tmake(exitcode)} {
			tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
		}
	}

	if {$status eq "uptodate"} {
		# If --warnings is set, show any cached warnings
		if {$tmake(showwarnings)} {
			if {[dict exists $tmakecache(warnings) $ruletarget]} {
				set warnings [dict get $tmakecache(warnings) $ruletarget]
				if {[llength $warnings]} {
					enter-new-dir $tmake(chdir)

					# In verbose mode, the 'run' cmdline won't be shown.
					# The best we can do is output the complete cached command
					if {$tmake(verbose)} {
						foreach do [dict get $tmakecache(cmd) $ruletarget] {
							show-rule-commands $do
						}
					}
					run-do $vardict $t(msg)
					foreach msg $warnings {
						pputs colrunwarn $msg
					}
				}
			}
		}
	}

	#puts "status changed for $ruletarget from $oldstatus => $status ($reason)"
	set-rule-status $ruletarget $status

	set tmake(current) $oldcurrent
	return $status
}

# ==================================================================
# Dynamic dependencies
# ==================================================================

proc header-scan-regexp {suffix regex filename} {
	if {![file exists $filename]} {
		set filename [file-build $filename]
		if {![file exists $filename]} {
			# Might be a target which failed to build. This will be handled later
			dputs-D "header-scan-regexp $filename => <does not exist>"
			return {}
		}
	}
	set f [open $filename]
	set headers {}
	set n 0
	set d 0
	while {[gets $f buf] >= 0} {
		incr n
		if {[regexp $regex $buf -> name]} {
			append name $suffix
			lappend headers $name
		}
	}
	close $f
	dputs-D "header-scan-regexp $filename => $headers"
	return $headers
}

# Returns a list of {type path-to-filename hash}
# where type is "target" or "source"
#
# If the $path/$filename is neither a target nor source, the empty list is returned
proc find-file-on-path {filename path} {
	set f [file-join $path $filename]

	set result {}
	if {[is-target? $f]} {
		dputs-D "$f is a target, so building first"
		# Even if it fails to build, it is needed
		set status [build-sync $f]
		if {$status in {built uptodate}} {
			# with tmake -n, the file may not have actually been built
			set filepath [file-build $f]
			set result [list target $f [calc-file-hash $f]]
		} else {
			dputs-D "failed to build $f"
			if {$::tmake(quickstop)} {
				tmake-exit 1 "Error: Failed to build $f"
			} else {
				build-error "Error: Failed to build $f"
			}
		}
	} else {
		if {[file exists $f]} {
			set result [list source $f [get-file-hash $f]]
		}
	}
	#dputs-D "find-file-on-path: file=$filename, path=$path ($f) => $result"
	return $result
}

# Returns a list of {type path hash}
# where type is "target" or "source".
#
# Note that the current directory (.) is special.
# We return both the first match along $paths and any match on [file dirname $filename]
# (Unless they are the same)
#
proc find-file {filename paths} {
	#puts "find-file filename=$filename, paths=$paths"

	# First check the per-run cache
	set cachekey "$filename $paths"
	if {[dict exists $::tmake(depfindcache) $cachekey]} {
		set result [dict get $::tmake(depfindcache) $cachekey]
		#puts "find-file (cached) filename=$filename, paths=$paths => $result"
		return $result
	}

	set result {}
	set filedir [file dirname $filename]
	set seendot 0

	# Add $filedir to the end of paths if not already there
	if {$filedir ni $paths} {
		lappend paths $filedir
	}

	set result {}
	# First search the given paths
	foreach p $paths {
		set result [find-file-on-path $filename $p]
		if {[llength $result]} {
			break
		}
	}

	#puts "find-file filename=$filename, paths=$paths => $result"

	if {[llength $result] == 0} {
		dputs-D "Not a file and not a target, $filename"
	}

	# Cache this result
	dict set ::tmake(depfindcache) $cachekey $result

	#puts "=> [dict get $::tmake(depfindcache) $cachekey]"

	return $result
}

# XXX: This could be done better
#
proc header-scan-regexp-recursive {incpaths suffix regex filename} {
	global tmake tmakecache

	if {[is-target? $filename]} {
		set filepath [file-build $filename]
	} else {
		set filepath $filename
	}
	if {![file exists $filepath]} {
		dputs-D "header-scan-regexp-recursive, $filepath does not exist"
		return {}
	}
	set cachekey "$incpaths $suffix $regex $filename"

	dputs-D "Scanning $filename for headers: incpaths=$incpaths"
	# Can we get the result from the cache?
	set stamp [list [calc-file-hash $filename] $incpaths $suffix $regex]
	if {[dict exists $tmakecache(headerscan) $filename]} {
		lassign [dict get $tmakecache(headerscan) $filename] cache_stamp headers cachedresults
		if {$cache_stamp eq $stamp} {
			# Need to verify that find-file returns the same result as last time
			dputs-D "verifying up-to-date cached results for $filename"
			set ok 1
			#cachedresults=test2.in {source subdir/test2.in 1560901841973445} test4.in {source subdir/test4.in 1560899705528444}
			foreach {cname cinfo} $cachedresults {
				set finfo [find-file $cname $incpaths]
				if {$cinfo ne $finfo} {
					dputs-d "$cname has changed from {$cinfo} => {$finfo} -- rescan"
					set ok 0
					break
				}
				dputs-D "ok, $cname still resolves to {$cinfo}"
			}
			if {$ok} {
				# Can reuse the cache
				dputs-d "header-scan-regexp $filename (cached) => $headers"
				return $headers
			} else {
				dputs-d "cache is out-of-date for $filename - rescanning"
			}
		}
		# Stale
		dict unset tmakecache(headerscan) $filename
	}

	# Recursively scan files
	unset -nocomplain deps results
	set deps {}
	set results {}
	set scanned($filename) 1
	set toscan [header-scan-regexp $suffix $regex $filepath]
	while {[llength $toscan]} {
		set newscan {}
		foreach d $toscan {
			if {![info exists scanned($d)]} {
				set scanned($d) 1
				set findfiles [find-file $d $incpaths]
				set results($d) $findfiles
				foreach {type deppath hash} $findfiles {
					set deps($deppath) 1
					lappend newscan {*}[header-scan-regexp $suffix $regex $deppath]
				}
			}
		}
		set toscan $newscan
	}

	#puts "---- $filename ----"
	#parray results
	# memoize the result
	set headers [dict keys $deps]
	dict set tmakecache(headerscan) $filename [list $stamp $headers $results]
	#dputs d results=$results
	mark-cache-dirty "New header scan"
	return $headers
}

# These are overridden by the colour module
proc colout {colour string} {
	return $string
}

proc colerr {colour string} {
	return $string
}

# Embedded modules are inserted below here
##-- CUT HERE --##

# ==================================================================
# ENTRY POINT
# ==================================================================

set rc [catch -signal {
	set rc [catch {callmake $argv} msg opts]
	if {$rc} {
		if {$rc == 1 && [exists -command error-stacktrace]} {
			user-notice colerror [error-stacktrace $msg $opts(-errorinfo)]
		} elseif {$msg ne ""} {
			user-notice colerror $msg
		}
		set tmake(exitcode) 1
	}

	# We do this even on error
	if {$tmake(numtargets) || $tmake(showtime) || $tmake(verbose)} {
		set elapsed [expr {([clock millis] - $tmake(start)) / 1000.0}]
		if {!$tmake(quiet)} {
			pputs colnote "Built $tmake(numtargets) of [num-nonphony-targets] target(s) in [format %.2f $elapsed] seconds"
		}
	}
	if {$tmake(usehashes)} {
		dputs T "Time spent hashing sources: [format %.3f $($tmake(hashtime) / 1e6)] seconds"
	}
	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "late"} {
		fake-an-error
	}
	if {$tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}
} msg opts]

switch [info returncodes $rc] {
	"signal" {
		# This must be SIGPIPE since we catch/ignore other errors
		set tmake(exitcode) 1
	}
	"error" {
		stderr puts $msg
	}
}

tmake-exit $tmake(exitcode)
