#!/bin/sh
# Copyright (c) 2011-2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved
# vim:se syntax=tcl:
# \
dir=`dirname "$0"`; exec "`$dir/find-tclsh`" "$0" "$@"

# ==================================================================
# Initialiation
# ==================================================================

set tmake(version) {0.2 (5-Mar-2012)}
set tmake(cacheversion) 3
set tmake(debug) 0

set tmake(debugtypes) {d 0 n 0 r 0 b 0 t 0 c 0 g 0 G 0 p 0 m 0 D 0 C 0 T 0 B 0 v 0 x 0}
set tmake(debughelp) {
	* "Enable all debug"
	? "Display help for debug types"
	d "Dynamic dependencies"
	D "Dynamic dependencies (detailed)"
	n "Reasons for targets NOT built"
	b "Reasons for targets BUILT"
	B "Reasons for targets BUILT - changed commands or targets"
	r "Display rules when triggered"
	t "Rules being replaced with 'target -replace'"
	g "Depencency graph for each target"
	G "List goals (targets) as they are attempted"
	p "Print rules while parsing"
	m "Miscellaneous (locating and parsing of files)"
	c "Configuration expressions via ifconfig"
	C "Cache handling"
	T "Timing"
	v "Variable definition"
}
set tmake(verbose) 0
set tmake(showdelta) 0
set tmake(norun) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(exitcode) 0
set tmake(modules) {}
set tmake(autosubdirs) 1
set tmake(deferred) {}
set tmake(projfiles) {}
set tmake(defines) {}
set tmake(fixedvars) {}
set tmake(installed) 0
set tmake(cleaning) 0
set tmake(quiet) 0
set tmake(init) 0
set tmake(showcache) 0
set tmake(depfindcache) {}
set tmake(addtargets) {}
set tmake(emptycache) {file {} cmd {} deps {} target {} headerscan {} version 0 writecache 0}

array set tmakecache $tmake(emptycache)

set tmake(defaulttarget) all
set tmake(loadedprojectspec) 0
set tmake(current) {}
set tmake(rules) {}
set tmake(aliases) {}
set tmake(rulestatus) {}
set tmake(targetstatus) {}
set tmake(targets) {}
set tmake(numtargets) 0
set tmake(subdirs) {}
set tmake(prefix) ""
set tmake(localdir) .
set tmake(localmakefile) Makefile

if {$tmake(debug)} {
	dict set tmake(debugtypes) A 1
}

# ==================================================================
# Argument Processing
# ==================================================================

proc make-parse-options {argv {type tmake}} {
	global tmake
	#puts "make-parse-options [list $argv] type=$type"

	foreach arg $argv {
		if {[info exists nextopt]} {
			switch -exact -- $nextopt {
				-C {
					# This will fail with a fatal error if not a dir
					cd $arg
				}
				default {
					error "Unexpected $nextarg"
				}
			}
			unset nextopt
			continue
		}
		if {[regexp {^(\w+)=(.*)} $arg -> n v]} {
			# Allow: make O=tmake-options
			if {$n eq "O" && $type ne "tmake"} {
				make-parse-options $v
				continue
			}
			define! $n $v
			continue
		}
		if {$type ne "tmake"} {
			continue
		}
		if {[regexp {^(-+[^=]*)(=)?(.*)?} $arg -> option equals value]} {
			if {$option eq "--mflags"} {
				# The only thing we care about from mflags is -n
				if {[string match *n* $value]} {
					set tmake(norun) 1
				}
				continue
			}
			if {$option eq "--bsdmakeflags"} {
				# Pick up variable definitions
				make-parse-options $value bsd
				continue
			}
			if {$option eq "--gnumakeflags"} {
				# Pick up variable definitions
				make-parse-options $value gnu
				continue
			}
			# Here we are parsing tmake options
			# XXX: There is no way to pass these through make
			if {$option eq "-d?"} {
				puts "Different debugging can be enabled with -d..."
				puts "The different debuggin categories are as follows:\n"

				foreach {n desc} $tmake(debughelp) {
					puts "\t$n\t$desc"
				}
				exit 0
			}
			if {$option eq "-d*"} {
				foreach i [dict keys $tmake(debugtypes)] {
					dict set tmake(debugtypes) $i 1
				}
				continue
			}
			switch -glob -- $option {
				--showcache {
					incr tmake(showcache)
				}
				--find {
					set tmake(findtarget) $value
				}
				--delta {
					incr tmake(showdelta)
				}
				--build {
					set tmake(build) $value
				}
				--targets {
					set tmake(listtargets) $value
				}
				--debug {
					# Equivalent to -dg
					set tmake(debug) 1
					dict set tmake(debugtypes) g 1
				}
				-d* {
					foreach i [split [string range $option 2 end] {}] {
						dict set tmake(debugtypes) $i 1
					}
					set tmake(debug) 1
				}
				--install {
					use install
					tmake_install autosetup
				}
				--verbose - -v {
					set tmake(verbose) 1
				}
				--init {
					set tmake(init) 1
				}
				--version {
					use help
					pputs [show-version]
					exit 0
				}
				--help - -h {
					use help
					show-help $argv
					exit 0
				}
				--genie {
					use genie
					tmake-genie $argv
					exit 0
				}
				--dry-run - --just-print - -n {
					set tmake(norun) 1
				}
				-N {
					set tmake(norun) 2
				}
				--tim* - -t {
					incr tmake(showtime)
				}
				-q - --quickstop {
					incr tmake(quickstop)
				}
				-Q - --quiet {
					incr tmake(quiet)
				}
				-p - --print* {
					incr tmake(showrules)
				}
				-C {
					set nextopt $arg
				}
				-- {
				}
				default {
					user-error "Unknown option $arg"
				}
			}
			continue
		}

		# Must be a target
		lappend tmake(cmdline) $arg
	}
	if {[info exists nextopt]} {
		user-error "$nextopt requires an argument"
	}
}

proc make {argv} {
	global tmake
	#puts "make '$argv'"
	#parray ::env

	# 'compat' is needed before we can do anything, so set a temporary $tmake(dir)
	if {!$tmake(installed)} {
		set tmake(dir) [file dirname $::argv0]
		use compat
	}

	use colour

	set tmake(exe) [file-normalize $::argv0]
	set tmake(dir) [file dirname $tmake(exe)]
	set tmake(start) [clock-millis]
	set tmake(prevtime) $tmake(start)
	set tmake(cmdline) {}
	set tmake(initialdir) [pwd]

	make-parse-options $argv

	# Need to find the project top
	set tmake(topsrcdir) [find-project-top]
	if {$tmake(topsrcdir) eq ""} {
		user-error "Failed to find project.spec in any parent directory."
	}
	make-parse-options [readfile $tmake(topsrcdir)/tmake.opt ""]

	# We want disabled debugging to be as fast as possible
	# These are called very frequently
	foreach i {n G d D} {
		if {[debug-is-set $i]} {
			alias dputs-$i dputs $i
		} else {
			# proc with null body is specially optimised
			proc dputs-$i {args} {}
		}
	}

	# Find the current dir relative to topsrcdir
	set tmake(subdir) [relative-path [pwd] $tmake(topsrcdir)]

	# Builds run from topsrcdir
	cd $tmake(topsrcdir)

	# Full path
	set tmake(topsrcdir) [pwd]

	# By default, the build directory is 'objdir', but this
	# can be changed with --build, either on the command line or from tmake.opt
	# XXX: Currently tmake.opt overrides the command line because it it parsed later.
	if {![info exists tmake(build)]} {
		dputs m "Setting --build=objdir"
		set tmake(build) objdir
	} else {
		dputs m "Got --build=$tmake(build)"
	}

	# Create the build dir now
	file mkdir $tmake(build)

	set tmake(topbuilddir) [file-normalize $tmake(build)]

	if {$tmake(topsrcdir) ne $tmake(initialdir)} {
		# emulate make for vim quickerr
		pputs [colout green "tmake: Entering directory `$tmake(topsrcdir)'"]
	}

	# Make these available in the environment for the benefit of generator programs and scripts
	# which want to be able to find things
	set ::env(TOPSRCDIR) $tmake(topsrcdir)
	set ::env(TOPBUILDDIR) $tmake(topbuilddir)

	define TOPSRCDIR $tmake(topsrcdir)
	define TOPBUILDDIR $tmake(topbuilddir)

	if {$tmake(showcache)} {
		show-cache
		exit 0
	}

	flush stdout

	set tmake(prefix) ""

	use getopt config

	# Core implementation simply removes files
	# Project or rulebase can override this
	alias delete-orphan-files file delete

	set rulebase rulebase.spec
	if {![file exists $rulebase]} {
		set rulebase $tmake(dir)/rulebase.default
	}
	lassign [invoke-spec-file $rulebase] rc msg opts
	if {$rc != 0 && $rc != 2} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed rulebase"

	# Save the global state in case we need to reload
	# At this stage it includes defaults, options and the rulebase

	set tmake_save [array get tmake]

	load-build-description 1

	dputs T "Parsing phase complete"

	if {$tmake(init)} {
		tmake-exit 0
	}
	if {$tmake(showrules)} {
		show-all-rules
		tmake-exit 0
	}
	if {[info exists tmake(listtargets)]} {
		show-all-targets $tmake(listtargets)
		tmake-exit 0
	}
	if {[info exists tmake(findtarget)]} {
		if {[is-target? $tmake(findtarget)]} {
			show-rule $tmake(findtarget)
			tmake-exit 0
		}
		foreach target [dict keys $tmake(targets)] {
			if {[string match *$tmake(findtarget)* $target]} {
				show-rule $target
				pputs ""
			}
		}
		tmake-exit 0
	}

	# Targets are relative to the local dir, $tmake(subdir),
	# unless prefixed with / in which case they are global.
	if {[llength $tmake(cmdline)]} {
		foreach arg $tmake(cmdline) {
			if {[regexp {//(.*)} $arg -> realtarget] || [regexp {^/(.*)} $arg -> realtarget]} {
				puts "$arg => $realtarget"
				lappend targets $realtarget
			} else {
				lappend targets [file-join $tmake(subdir) $arg]
			}
		}
	} else {
		lappend targets [file-join $tmake(subdir) $tmake(defaulttarget)]
	}

	# Build each target, resetting the status and possibly reloading every time
	while {[llength $targets] && $tmake(exitcode) == 0} {
		set targets [lassign $targets target]

		set tmake(addtargets) {}

		# Reset the status of every rule to "unknown"
		foreach ruletarget [dict keys $tmake(rules)] {
			set-rule-status $ruletarget unknown
		}

		# XXX: Rules should be marked -cleaning to identify those
		# which don't need to force projfiles to be loaded
		# target must be a single cleaning target
		if {$target in {clean distclean clean-orphans}} {
			set tmake(cleaning) 1
		} else {
			# Try to build all Load targets
			# If any files specified to Load are targets,
			# build them before anything else
			set reload 0
			foreach {t nocare} $tmake(projfiles) {
				if {$nocare && ![is-target? $t]} {
					dputs-n "Load --nocare $t, not a target"
					continue
				}
				set rc [build $t]
				if {$rc < 0} {
					if {$tmake(exitcode) == 0} {
						build-error "Error: Don't know how to build $t"
						tmake-exit 1
					}
					break
				}
				if {$rc > 0} {
					dputs m "$t has changed, reloading..."
					set reload 1
				}
			}

			if {$reload} {
				# Restore the state
				unset tmake
				array-set tmake $tmake_save

				load-build-description 0

				dputs T "Reparsing phase complete"
			}

			# Discard orphans before building any non-cleaning target
			set orphans [get-orphan-targets]
			if {[llength $orphans]} {
				delete-orphan-files {*}$orphans
				note Clean removing [llength $orphans] orphan target(s)
				dputs C $orphans
				discard-orphan-targets
			}
		}

		dputs {b T} "Building target $target"

		if {[build $target] < 0} {
			if {$tmake(exitcode) == 0} {
				build-error "Error: Don't know how to build $target"
			}
			break
		}

		# Add any new targets to the target list
		foreach new $tmake(addtargets) {
			if {$new ni $targets} {
				dputs m "$target has added new build target $new"
				set targets [linsert $targets 0 $new]
			}
		}
	}
}

proc add-build-targets {args} {
	lappend ::tmake(addtargets) {*}$args
}

proc load-cache {} {
	if {[file exists .makecache]} {
		global tmake tmakecache
		lassign [time {source .makecache}] us
		dputs C "Loaded cache, .makecache in [expr {($us + 500) / 1000}]ms"
		if {$tmakecache(version) != $tmake(cacheversion)} {
			user-notice ".makecache is out-of-date -- ignoring"
			array-set tmakecache $tmake(emptycache)
			# But overwrite the cache next time around
			set tmakecache(writecache) 1
		}
	} else {
		dputs C "Missing cache, starting with empty cache"
	}
}

proc mark-cache-dirty {msg} {
	global tmakecache
	if {$tmakecache(writecache) == 0} {
		dputs C "$msg, marking cache dirty"
		set tmakecache(writecache) 1
	}
}

proc write-cache {} {
	global tmake tmakecache
	if {$tmakecache(writecache)} {
		set tmakecache(version) $tmake(cacheversion)
		unset tmakecache(writecache)
		lassign [time {
			set f [open .makecache w]
			foreach i [array names tmakecache] {
				puts $f [list set tmakecache($i) $tmakecache($i)]
			}
			close $f
		}] us
		dputs C "Wrote cache, .makecache in [expr {($us + 500) / 1000}]ms"
	} else {
		dputs C "Cache unchanged, not writing"
	}
}

proc load-build-description {loadcache} {
	global tmake tmakecache

	lassign [invoke-spec-file project.spec] rc msg opts
	if {$rc == 20} {
		return
	}
	if {$rc != 0 && $rc != 2} {
		return -code $rc {*}$opts $msg 
	}

	dputs T "Parsed project.spec"

	# Loaded in the global scope 

	foreach i $tmake(deferred) {
		uplevel #0 $i
	}

	# Now load the cache if it exists and it isn't the second time through
	if {$loadcache} {
		load-cache
	}

	set tmake(loadedprojectspec) 1

	process-build-spec-file . 1

	# Now validate that there is no non-phony target which depends on a phony target
	foreach ruletarget [dict keys $::tmake(rules)] {
		if {![get-rule-attr $ruletarget phony]} {
			foreach dep [get-rule-attr $ruletarget depends] {
				if {[is-target? $dep]} {
					if {[dict get [get-target-rule $dep] phony]} {
						user-notice "Non phony target $ruletarget @[make-source-location $ruletarget] depends on phony $dep"
						tmake-exit 1
					}
				}
			}
		}
	}
}

proc is-cleaning? {} {
	return $::tmake(cleaning)
}

# ==================================================================
# .spec file processing
# ==================================================================

# Returns "" if project top not found
proc find-project-top {} {
	set topdir [pwd]
	while {![file exists $topdir/project.spec]} {
		set parent [file dirname $topdir]
		if {$topdir eq $parent} {
			dputs m "Project top not found"
			return ""
		}
		set topdir $parent
	}
	dputs m "Project top found at $topdir"
	return $topdir
}

proc local-prefix {} {
	return $::tmake(prefix)
}

proc local-src-prefix {} {
	if {$::tmake(topsrcdir) eq "."} {
		return $::tmake(prefix)
	} else {
		return $::tmake(topsrcdir)/$::tmake(prefix)
	}
}

proc local-dir {} {
	return $::tmake(localdir)
}

proc top-src-dir {} {
	return $::tmake(topsrcdir)
}

proc make-local {args} {
	prefix [local-prefix] $args
}

proc make-local-dirs {args} {
	lmap dir $args {
		file-join [local-dir] $dir
	}
}

# Reverses make-local
proc make-unlocal {args} {
	set striplen [string length [local-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

# Reverses make-local-src
proc make-unlocal-src {args} {
	set striplen [string length [local-src-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

proc make-prefix {dir} {
	if {$dir eq "."} {
		return ""
	} else {
		return $dir/
	}
}

proc make-local-src {args} {
	prefix [local-src-prefix] $args
}

proc invoke-spec-file {filename} {
	lappend ::tmake(specfiles) $filename
	# Spec files are loaded at frame level #1, in the scope of run-do
	# 'define' relies on this
	set result [uplevel #0 [list run-do {} [list source $filename]]]

	if {[check-signal]} {
		tmake-exit 1
	}
	return $result
}

proc AutoSubDirs {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(autosubdirs) 1
		}
		off {
			set ::tmake(autosubdirs) 0
		}
		default {
			dev-error "on or off expected"
		}
	}
}

proc SubDirs {args} {
	lappend ::tmake(subdirs) {*}$args
}

proc file-build {path} {
	file-join $::tmake(build) $path
}

proc build-prefix {} {
	make-prefix $::tmake(build)
}

proc build-dir {} {
	return $::tmake(build)
}

proc file-build-exists {path} {
	file exists [file-build $path]
}

# If $srcdir is a dir from the top of the source tree,
# (defaults to [local-dir])
# return a relative path to $buildpath from the build tree.
#
proc file-build-relative {buildpath {srcdir {}}} {
	if {$srcdir eq ""} {
		set srcdir [local-dir]
	}
	set build [file join $::tmake(topbuilddir) $buildpath]
	set src [file join $::tmake(topsrcdir) $srcdir]
	relative-path $build $src
}

# Read in the given spec file in the given directory (relative to topdir)
# Returns 1 if OK, or 0 if subdirs should be skipped
proc process-build-spec-file {dir {optional 0}} {
	global tmake
	dputs m "process-build-spec $dir"
	set ignore 0

	set tmake(localdir) $dir
	set tmake(prefix) [make-prefix $dir]

	set path [file-join $dir build.spec]

	if {![file exists $path]} {
		# The top level build.spec is optional
		if {!$optional} {
			user-error "$path does not exist"
		}
		incr ignore
	}

	set defines $tmake(defines)

	BuildSpecProlog
	if {$ignore} {
		set rc 0
	} else {
		lassign [invoke-spec-file $path] rc msg opts

		dputs T "Parsed [local-prefix]build.spec"
	}
	BuildSpecEpilog

	set tmake(defines) $defines


	if {$rc == 20} {
		dputs m "Skipping $path"
		return
	}
	if {$rc != 0 && $rc != 2} {
		return -code $rc {*}$opts $msg 
	}

	# Now subdirectories
	incr tmake(depth)

	# Find the explicitly set subdirs
	set subdirs $tmake(subdirs)
	set tmake(subdirs) {}

	# Normally we search for dirs containing build.spec
	if {$tmake(autosubdirs)} {
		foreach d [readdir $dir] {
			if {[file exists $dir/$d/build.spec] && $d ni $subdirs} {
				lappend subdirs [file-join $dir $d]
			}
		}
	}

	# Now process subdirs
	foreach d $subdirs {
		process-build-spec-file $d
	}
	incr tmake(depth) -1
}

# Returns a list of all files which were once a target but are no longer
proc get-orphan-targets {} {
	global tmakecache

	set result {}
	foreach i [dict keys $tmakecache(file)] {
		if {![is-target? $i]} {
			lappend result $i
		}
	}
	return $result
}

proc discard-orphan-targets {} {
	global tmake tmakecache
	set discard 0

	foreach i [dict keys $tmakecache(file)] {
		if {![is-target? $i]} {
			#puts "Discarding orphan file $i"
			dict unset tmakecache(file) $i
			set discard 1
		}
	}

	# Also discard the build commands, targets and dependencies
	foreach i [dict keys $tmakecache(cmd)] {
		if {![is-rule? $i]} {
			#puts "Discarding orphan rule $i"
			dict unset tmakecache(cmd) $i
			set discard 1
			foreach j $i {
				#puts "Discarding orphan target and deps $j"
				dict unset tmakecache(targets) $j
				dict unset tmakecache(deps) $j
			}
		}
	}
	if {$discard} {
		mark-cache-dirty "discarded orphan targets"
	}
}

# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	if {$::tmake(installed)} {
		return
	}
	foreach m $args {
		if {[dict exists $::tmake(modules) $m]} {
			continue
		}
		dict set ::tmake(modules) $m 1

		set source $::tmake(dir)/lib/${m}.tcl
		if {![file exists $source]} {
			dev-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		if {[info procs init-$m] ne {}} {
			init-$m
		}
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {msg} {
	puts stderr [colerr lred "Error: $msg"]
	puts stderr "Try: 'tmake --help' for options"
	tmake-exit 1
}

# @build-error msg
#
# Indicate that something failed to build and set exitcode=1
proc build-error {msg} {
	dputs b "BUILD ERROR: $msg"
	puts stderr [colerr lred $msg]
	set ::tmake(exitcode) 1
}
# @user-notice msg
#
# Output the given message to stderr.
#
proc user-notice {msg} {
	puts stderr $msg
}

# Incorrect usage in the build.spec file. Identify the location.
proc dev-error {msg} {
	puts stderr [colerr lred [error-location "Error: $msg"]]
	tmake-exit 1
}

proc tmake-exit {code} {
	# Write the cache before exiting
	write-cache
	dputs T Done
	exit $code
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		pputs [colout cyan $msg]
	}
}

proc pputs {msg} {
	puts $msg
	flush stdout
}

# Returns 1 if any of the debug types is set
proc debug-is-set {types} {
	foreach t $types {
		if {[dict get $::tmake(debugtypes) $t]} {
			return 1
		}
	}
	return 0
}

# Output a message to stdout if --debug is set.
#
proc dputs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		pputs "[colout purple [dbg-msg-indent $indent]] \[$types\] [colout yellow $msg]"
	}
}

proc dputs-null {args} {}

# Like dputs, but msg needs to be expanded with subst
# This is used for messages which may be expensive to evalue
proc dputxs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		dputs $types [uplevel 1 [list subst $msg]]
	}
}

proc dbg-msg-indent {{autoindent 1}} {
	global tmake

	set now [clock-millis]
	if {$tmake(showdelta)} {
		set time [expr {$now - $tmake(prevtime)}]
		set tmake(prevtime) $now
	} else {
		set time [expr {$now - $tmake(start)}]
	}
	if {$autoindent && [debug-is-set G]} {
		set indent [string repeat "    " [llength $::tmake(current)]]
	} else {
		set indent {}
	}
	return [format %5dms $time]$indent
}

proc pad {text width {char { }}} {
	if {[string length $text] >= $width} {
		return $text
	}
	return $text[string repeat $char [expr {$width - [string length $text]}]]
}

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	set lines [split $do \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set ruletarget [get-rule-target $target]
	} else {
		set ruletarget $target
	}
	if {[is-rule? $ruletarget]} {
		array-set t [get-rule $ruletarget]
		set flags {}
		set lines {}
		puts [pad "-- $ruletarget " 60 -]--
		foreach n [lsort [array names t]] {
			set v $t($n)
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				phony - nofail - chdir - nocache {
					if {$v} {
						lappend flags $n
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vv"
					}
				}
				onerror {
					if {$v ne ""} {
						lappend lines "$n={[join [split [string trim $v] \n] {;}]}"
					}
				}
				alias {
					if {$v ne ""} {
						lappend lines "$n=$v"
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
				}
			}
		}
		if {[llength $flags]} {
			append target " \[$flags\]"
		}
		puts "$t(target): $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		foreach do $t(do) {
			show-rule-commands $do
		}
	} else {
		puts "No rule for $ruletarget"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(rules)]] {
		show-rule $i
		puts ""
	}
}

proc show-cache {} {
	global tmake

	if {![file exists $tmake(topbuilddir)/.makecache]} {
		user-notice [colerr purple "No .makecache"]
		return
	}
	source $tmake(topbuilddir)/.makecache

	# Files
	puts "File times (V=virtual mtime, M=mtime)"
	puts "-------------------------------------"

	foreach i [lsort [dict keys $tmakecache(file)]] {
		lassign [dict get $tmakecache(file) $i] vmtime mtime
		if {$mtime == $vmtime} {
			set mtimestr "(same)"
		} else {
			set mtimestr [clock format $mtime -format "%H:%M:%S %d-%b-%Y"]
		}
		puts [format "%25s  V=%s  M=%s" $i [clock format $vmtime -format "%H:%M:%S %d-%b-%Y"] $mtimestr]
	}
	puts ""

	puts "Commands used to build targets"
	puts "------------------------------"
	# Commands
	foreach i [lsort [dict keys $tmakecache(cmd)]] {
		puts $i
		foreach do [dict get $tmakecache(cmd) $i] {
			show-rule-commands $do
			puts ""
		}
	}
}

proc show-all-targets {detailed} {
	foreach i [lsort [dict keys $::tmake(targets)]] {
		if {$detailed eq ""} {
			if {![dict get [get-target-rule $i] phony]} {
				puts $i
			}
		} else {
			puts "$i @[make-source-location $i]"
		}
	}
}

# ==================================================================
# Variable Handling
# ==================================================================

# Set a variable to the given value, unless it was defined with define!
# 
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	if {![dict exists $::tmake(fixedvars) $name]} {
		if {[llength $args]} {
			set value [join $args]
		} else {
			set value 1
		}
		#dputs v "define $name $value"
		dict set ::tmake(defines) $name $value
		# Ensure that the value is visibile the current spec file
		uplevel #1 [list set $name $value]
	}
}

proc define! {name args} {
	set value [join $args]
	#dputs v "define! $name $value"
	dict set ::tmake(fixedvars) $name 1
	dict set ::tmake(defines) $name $value
	uplevel #1 [list set $name $value]
}

# Set a variable to the given value
# unless it is already set to a non-empty value.
#
proc define? {name args} {
	global $name
	#puts "define? $name $args"
	if {[get-define $name] eq ""} {
		define $name {*}$args
	}
}

# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	#dputs v "define-append $name $args"
	set value [get-define $name]
	append-with-space value [join $args]
	define $name $value
}

proc get-define {name {default ""}} {
	#dputs v "get-define $name"
	if {[dict exists $::tmake(defines) $name]} {
		dict get $::tmake(defines) $name
	} else {
		return $default
	}
}

proc define-exists {name} {
	dict exists $::tmake(defines) $name
}

# If the given var is not set or is "", sets it to $value
# Otherise appends $value with a space separator (or $space)
#
proc append-with-space {varname value {space " "}} {
	upvar $varname n
	if {[info exists n] && $n ne ""} {
		append n $space $value
	} else {
		set n $value
	}
}

# Takes a list and returns a new list with $suf appended
# to each element
# 
# suffix .c a b c => a.c b.c c.c
#
proc suffix {suf args} {
	set result {}
	foreach p [join $args] {
		lappend result $p$suf
	}
	return $result
}

# Takes a list and returns a new list with $pre prepended
# to each element
# 
# suffix jim- a.c b.c => jim-a.c jim-b.c
#
proc prefix {pre args} {
	set result {}
	foreach p [join $args] {
		lappend result $pre$p
	}
	return $result
}

# Takes a list of filenames and returns a new list with
# the extension of each filename changed to $ext
# 
# change-ext .c a.o b.o c => a.c b.c c.c
#
proc change-ext {ext args} {
	set result {}
	foreach p [join $args] {
		lappend result [file rootname $p]$ext
	}
	return $result
}

# Merges target variables.
# These are stored in dictionaries, where $dict1 is the current vars
# and the new vars $dict2 need to be merged.
# Where there is no overlap, the dictionaries are simply merged.
# Where a var exists in both, the values are combined with a space separator.
proc merge-vars {dict1 dict2} {
	if {[dict size $dict2]} {
		if {[dict size $dict1] == 0} {
			return $dict2
		}
		array-set d1 $dict1
		foreach {n v} $dict2 {
			append-with-space d1($n) $v
		}
		return [array get d1]
	}
	return $dict1
}

# ==================================================================
# File Utilities
# ==================================================================

# @readfile filename ?default=""?
#
# Return the contents of the file, without the trailing newline.
# If the doesn't exist or can't be read, returns $default.
#
proc readfile {filename {default_value ""}} {
	set result $default_value
	catch {
		set f [open $filename]
		set result [read -nonewline $f]
		close $f
	}
	return $result
}

# @writefile filename value
#
# Creates the given file containing $value.
# Does not add an extra newline.
#
proc writefile {filename value} {
	file mkdir [file dirname $filename]
	set f [open $filename w]
	puts -nonewline $f $value
	close $f
}

# ==================================================================
# Rule Handling
# ==================================================================

# If $target is an alias, return the aliased target
# Otherwise return $target
proc map-alias {target} {
	if {[dict exists $::tmake(aliases) $target]} {
		set target [dict get $::tmake(aliases) $target]
	}
	return $target
}

# Returns 1 if the target is an individual target
proc is-target? {target} {
	dict exists $::tmake(targets) [map-alias $target]
}

# Returns 1 if the target is a rule target
proc is-rule? {ruletarget} {
	dict exists $::tmake(rules) $ruletarget
}

# Converts a target to the rule target
proc get-rule-target {target} {
	dict get $::tmake(targets) [map-alias $target]
}

# Returns the rule for an individual target
proc get-target-rule {target} {
	dict get $::tmake(rules) [dict get $::tmake(targets) [map-alias $target]]
}

# Returns the rule for a rule target
proc get-rule {ruletarget} {
	dict get $::tmake(rules) $ruletarget
}

# Returns the single attribute for the given rule target
proc get-rule-attr {ruletarget attr} {
	dict get $::tmake(rules) $ruletarget $attr
}

# Like get-rule, but temporarily zaps the current rule.
# Makes it faster when updating the rule
proc take-rule {ruletarget} {
	set rule [dict get $::tmake(rules) $ruletarget]
	dict set ::tmake(rules) $ruletarget {}
	return $rule
}

proc update-rule {ruledict} {
	set ruletarget [dict get $ruledict target]
	if {![is-rule? $ruletarget]} {
		# Haven't seen this rule before so individual target pointers
		foreach t $ruletarget {
			if {[dict exists $::tmake(targets) $t]} {
				dev-error "Rule for $t was already specified at [make-source-location $t]"
			}
			dict set ::tmake(targets) $t $ruletarget
		}
		set-rule-status $ruletarget unknown
	}
	set alias [dict get $ruledict alias]
	if {$alias ne ""} {
		dict set ::tmake(aliases) $alias [lindex $ruletarget 0]
	}

	dict set ::tmake(rules) $ruletarget $ruledict
}

proc set-rule-status {ruletarget status} {
	dict set ::tmake(rulestatus) $ruletarget $status
}

proc get-rule-status {ruletarget} {
	dict get $::tmake(rulestatus) $ruletarget
}

proc show-this-rule {} {
	if {[debug-is-set p]} {
		set where "[find-source-location] "
		if {$where eq "unknown "} {
			set where ""
		}
		dputs p "$where[info level -1]" 0
	}
}

proc make-source-location {ruletarget {prefix {}} {suffix {}}} {
	if {[is-rule? $ruletarget]} {
		set source [get-rule-attr $ruletarget source]
	} else {
		set source [dict get [get-target-rule $ruletarget] source]
	}

	if {$source eq "unknown"} {
		return ""
	}
	return $prefix[join $source ", "]$suffix
}

# This is the only way to create a rule
#
# Parses the arguments and adds them to the rule base
#
proc target {ruletarget args} {
	# If the rule aready exists, we are updating
	if {[is-rule? $ruletarget]} {
		# Use take-rule here for efficiency
		array-set orig [take-rule $ruletarget]
	} elseif {[is-target? $ruletarget]} {
		# Can't update a rule via the invidual target
		set source [dict get [get-target-rule $ruletarget] source]
		dev-error "Multiple-target rule for $ruletarget was already specified at [make-source-location $source @]"
	}

	array-set info [parse-rule $ruletarget $args]

	#dputs p "target $ruletarget @ $info(source)"

	#show-this-rule

	set replace $info(replace)
	unset info(replace)

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	if {$replace} {
		if {[info exists orig]} {
			dputs t "Replacing existing rule for $ruletarget @$orig(source)"
			unset orig
		} else {
			dputs t "Rule for $ruletarget with -replace but not existing target @$info(source)"
		}
	}
	# Cache the prefix with the rule, also
	set info(local) [local-dir]

	if {![info exists orig]} {
		# Now create/update the rule
		update-rule [array get info]
		return
	}

	# There is already a rule for this target, so attempt
	# to merge the two rules
	# Note: We generally want the new values to come after the existing values, so
	# merge the new data into orig

	if {[llength $info(do)] && [llength $orig(do)]} {
		#dev-error "$ruletarget already has '-do' @$orig(source)"
		user-notice [colerr purple [warning-location "Warning: $ruletarget already has '-do' @$orig(source)"]]
		set info(do) {}
	}
	if {$info(dyndep) ne "" && $orig(dyndep) ne ""} {
		dev-error "$ruletarget already has '-dyndep' @$orig(source)"
	}
	lappend orig(depends) {*}$info(depends)
	lappend orig(inputs) {*}$info(inputs)
	lappend orig(clean) {*}$info(clean)
	incr orig(phony) $info(phony)
	incr orig(nofail) $info(nofail)
	incr orig(chdir) $info(chdir)
	incr orig(nocache) $info(nocache)
	append-with-space orig(onerror) $info(onerror) \n
	# Only one of these will be non-blank
	lappend orig(do) {*}$info(add-do)
	append-with-space orig(dyndep) $info(dyndep) \n

	if {$info(source) eq "unknown" || $info(source) in $orig(source)} {
		# Nothing to do
	} elseif {$info(source) ne "unknown"} {
		lappend orig(source) $info(source)
	}

	# Need to append to any vars which exist
	set orig(vars) [merge-vars $orig(vars) $info(vars)]

	# Whichever rule has '-do' also specifies '-inputs' and '-msg'
	if {[llength $orig(do)] == 0} {
		set orig(do) $info(do)
		set orig(inputs) $info(inputs)
		set orig(msg) $info(msg)
	}
	update-rule [array get orig]
}

# Adds the list elements to the target-specific variable.
#
# This a much faster equivalent of:
#
#     target $ruletarget -vars $varname {*}$list
#
proc target-add-var {ruletarget varname list} {
	# The rule must already exist
	if {![is-rule? $ruletarget]} {
		dev-error "$ruletarget is not a rule target"
	}
	# Note that if we do this blindly, we will duplicate the dict
	# Instead, get the current value. Replace it.
	# lappend.
	# Update it
	set vars [dict get $::tmake(rules) $ruletarget vars $varname]
	dict set ::tmake(rules) $ruletarget vars $varname {}
	lappend vars {*}$list
	dict set ::tmake(rules) $ruletarget vars $varname $vars
}

proc parse-rule-args {arglistname optname} {
	upvar $arglistname arglist
	upvar $optname opt
	set arglist [lassign $arglist opt]

	if {![string match -* $opt]} {
		dev-error "Unexpected parameter for rule: $opt"
	}
	set opt [string range $opt 1 end]
	if {$opt eq "vars"} {
		set incr 2
	} else {
		set incr 1
	}

	for {set i 0} {$i < [llength $arglist]} {incr i $incr} {
		if {[string match -* [lindex $arglist $i]]} {
			incr i -1
			break
		}
	}
	set optlist [lrange $arglist 0 $i]
	incr i
	set arglist [lrange $arglist $i end]
	return $optlist
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-rule {target arglist} {
	array-set info {
		inputs {} depends {} clean {} do {} onerror {} msg {} vars {} dyndep {} add-do {} alias {}
		replace 0 add 0 nofail 0 phony 0 chdir 0 nocache 0
	}

	set info(source) [find-source-location *build.spec]
	if {$info(source) eq "unknown"} {
		set info(source) [find-source-location *.spec]
		if {$info(source) eq "unknown"} {
			set info(source) [find-source-location *.default]
		}
	}
	set info(target) $target

	# Parse an option followed by multiple non-options
	while {[llength $arglist]} {
		set optargs [parse-rule-args arglist opt]
		switch -exact -- $opt {
			phony - nofail - replace - add - chdir - nocache {
				if {[llength $optargs]} {
					dev-error "Rule for $target has non-option parameters after -$opt: $optargs"
				}
				set info($opt) 1
			}
			inputs - depends {
				lappend info($opt) {*}[join $optargs]
			}
			clean {
				set info($opt) $optargs
			}
			do - msg - dyndep - onerror - alias {
				if {[llength $optargs] > 1} {
					dev-error "Rule for $target has more than one '-$opt' parameter"
				}
				if {$opt eq "do"} {
					set info($opt) $optargs
				} else {
					set info($opt) [lindex $optargs 0]
				}
			}
			vars {
				if {[llength $optargs] % 2} {
					dev-error "Rule for $target has an odd number of parameters to '-vars'"
				}
				lappend info($opt) {*}$optargs
			}
			getvars {
				foreach v $optargs {
					if {![define-exists $v]} {
						dev-error "Rule for $target has -getvars for non-existent variable: $v"
					}
					lappend info(vars) $v [get-define $v]
				}
			}
			default {
				dev-error "Rule for $target has unknown option: -$opt"
			}
		}
	}

	if {$info(add) && $info(replace)} {
		dev-error "Rule for $target has both '-add' and '-replace'"
	}
	if {$info(add)} {
		if {![llength $info(do)]} {
			dev-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) $info(do)
		set info(do) {}
	}
	unset info(add)

	if {[llength $info(do)] == 0 && [llength $info(inputs)]} {
		dev-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {[llength $info(do)] == 0 && $info(msg) ne ""} {
		dev-error "Rule for $target has '-msg' but no '-do'"
	}

	array get info
}

# ==================================================================
# Dependency Engine
# ==================================================================

proc file-real-mtime {filename} {
	if {[is-target? $filename]} {
		file mtime [file-build [map-alias $filename]]
	} else {
		file mtime $filename
	}
}

proc file-virtual-mtime {filename} {
	global tmakecache

	set mtime [file-real-mtime $filename]
	if {[dict exists $tmakecache(file) $filename]} {
		lassign [dict get $tmakecache(file) $filename] vmtime omtime
		# If the actual mtime is different from the saved mtime, we
		# ignore the cached (virtual) mtime.
		if {$omtime == $mtime} {
			# The cache is up to date, so use the virtual mtime
			set mtime $vmtime
		}
	}
	return $mtime
}

proc find-oldest-time {list name} {
	upvar $name oldestname
	lassign $list oldestname
	set oldesttime [file-virtual-mtime $oldestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-virtual-mtime $file]
			if {$t < $oldesttime} {
				set oldesttime $t
				set oldestname $file
			}
		}
	}
	#puts "find-oldest-time: $oldestname $oldesttime ($list)"
	return $oldesttime
}

proc find-newest-time {list name} {
	upvar $name newestname
	lassign $list newestname
	set newesttime [file-real-mtime $newestname]

	if {[llength $list] > 1} {
		foreach file $list {
			set t [file-real-mtime $file]
			if {$t > $newesttime} {
				set newesttime $t
				set newestname $file
			}
		}
	}
	#puts "find-newest-time: $newestname $newesttime ($list)"
	return $newesttime
}

# Both $targets and $depends are lists of files which must exist
# If any file is $targets is older than any file in $depends, the
# targets are out of date and 1 is returned. In this case the 
# variable named $depname is set to the name of the newest
# file in $depends
# Otherwise 0 is returned.
#
proc needbuild? {targets depends depname} {
	upvar $depname newest_depends
	set depends_time [find-newest-time $depends newest_depends]
	#puts "newest depends: [clock format $depends_time] $newest_depends"
	set targets_time [find-oldest-time $targets oldest_target]
	#puts "oldest targets: [clock format $targets_time] $oldest_target"
	if {$targets_time < $depends_time} {
		dputs b "$oldest_target is older than $newest_depends, so forcing rebuild"
		return 1
	}
	dputs-n "$targets is newer than $depends, so not forcing rebuild"
	return 0
}

proc locate-files {files} {
	set result {}
	foreach f $files {
		if {[is-target? $f]} {
			#puts "$f is a target => [file-build $f]"
			lappend result [file-build $f]
		} else {
			#puts "$f is not a target"
			lappend result $f
		}
	}
	return $result
}

proc set-global {name value} {
	if {[info exists ::$name] && [set ::$name] eq $value} {
		return
	}
	#dputs v "! $name=$value"
	set ::$name $value
}

# Returns a dictionary with the bound and rule-specific variables
proc make-var-dict {info} {
	set vardict [dict get $info vars]
	dict set vardict target [prefix [build-prefix] [dict get $info target]]
	dict set vardict local [dict get $info local]
	dict set vardict build [file-build [dict get $info local]]
	dict set vardict depends [locate-files [dict get $info depends]]
	dict set vardict inputs [locate-files [dict get $info inputs]]
	#parray vardict
	return $vardict
}

proc set-target-result {target result} {
	set ruletarget [get-real-target $target]
	if {[dict get $::tmake(rules) $ruletarget result] == 0} {
		dict set ::tmake(rules) $ruletarget result $result
	}
}

proc note {type args} {
	if {$::tmake(verbose) == 0} {
		pputs "    [pad $type 12] [join $args]"
	}
}

proc run {args} {
	set cmdline [join $args]
	set cmd [lindex $cmdline 0]
	#puts "run: do we need to convert $cmd to a path from [pwd]?"
	# Is cmd a file in the current dir?
	if {![string match */* $cmd] && [file isfile $cmd]} {
		set cmdline ./$cmdline
	}
	vputs [string trim $cmdline]
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		puts [colout grey $msg]
	}
	if {$rc == 1} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		build-error "$msg\n"
		return -code break
	}
	# XXX: What to do on signal?
}

proc calc-dyndeps {vardict target} {
	array-set t [get-rule $target]
	#puts "=============="
	#parray t

	set dyndeps {}
	if {$t(dyndep) ne ""} {
		foreach i $t(depends) {
			lassign [run-do $vardict [concat $t(dyndep) $i]] rc result opts
			if {$rc == 0} {
				lappend dyndeps {*}$result
			} else {
				return -code $rc {*}$opts $result
			}
		}
		dputs-d "Dynamic dependencies for $target: $dyndeps"
	}
	return $dyndeps
}

proc file-exists-all {list missingname} {
	set prefix [build-prefix]
	foreach f $list {
		if {![file exists $prefix$f]} {
			upvar $missingname missing
			set missing $f
			return 0
		}
	}
	return 1
}

# Unfortunately subst doesn't respect braces, so it is possible
# for subst to fail on something which isn't supposed to be interepreted
# by Tcl. So subst, and if that fails, return the script unchanged.
proc subst-do {__vardict __script} {
	# No substitution required?
	if {[string first {$} $__script] < 0} {
		return $__script
	}
	# Create local vars based on $::tmake(defines) and $__vardict
	# Could use 'dict with $dict {}' here, but this is slow for Jim Tcl
	foreach __n [dict keys $::tmake(defines)] {
		set $__n [dict get $::tmake(defines) $__n]
	}
	foreach __n [dict keys $__vardict] {
		set $__n [dict get $__vardict $__n]
	}
	# Note: It is an error if the subst fails
	return [subst -nob -noc $__script]
}

proc run-do {__vardict __script} {
	# Create local vars based on $::tmake(defines) and $__vardict
	# Could use 'dict with $dict {}' here, but this is slow for Jim Tcl
	foreach __n [dict keys $::tmake(defines)] {
		set $__n [dict get $::tmake(defines) $__n]
	}
	foreach __n [dict keys $__vardict] {
		set $__n [dict get $__vardict $__n]
	}
	unset __vardict __n
	list [catch $__script msg opts] $msg $opts
}

# ==================================================================
# build
#
# This is the workhorse of tmake.
# If possible, it builds $target, including and required dependencies
# Returns  0 if nothing to do,
#         -1 if unabled to be built
#          1 if built
# ==================================================================

proc build {target} {
	global tmake tmakecache
	if {![is-target? $target]} {
		# Cache the result here, mostly to avoid excess messages
		if {[dict exists $tmake(targetstatus) $target]} {
			set ret [dict get $tmake(targetstatus) $target]
		} else {
			dputs-G "build $target"
			if {[file exists $target]} {
				dputs-n "$target is not a target, but exists"
				set ret 0
			} else {
				dputs b "$target is not a target and does not exist"
				set ret -1
			}
			dict set tmake(targetstatus) $target $ret
		}
		return $ret
	}

	set ruletarget [get-rule-target $target]
	set status [get-rule-status $ruletarget]
	switch $status {
		uptodate {
			return 0
		}
		built {
			#dputs b "$target has previously been built"
			return 1
		}
		checking {
			set current [list {*}$tmake(current) $target]
			dev-error "Recursive definition for [join [lreverse $current] { <= }] [make-source-location $ruletarget @]"
		}
		failed {
			dputs b "$target has previously failed to build"
			return -1
		}
		unknown {
			dputs-G "build $target"
		}
		default {
			error "Bad status: $status"
		}
	}

	# Set the status now to detect recursive dependencies
	set-rule-status $ruletarget checking
	set oldcurrent $tmake(current)
	lappend tmake(current) $target

	array-set t [get-rule $ruletarget]

	set reason {}
	if {$t(phony)} {
		dputs b "$target is phony, so rebuilding"
		lappend reason phony
		set result 1
	} elseif {![file-exists-all $ruletarget missing]} {
		dputs b "$missing doesn't exist, so rebuilding"
		lappend reason noexist
		set result 1
	} else {
		#dputs b "$ruletarget exists, so checking dependencies"
		set result 0
	}

	# Here is the plan to build $target
	# 1. Run 'build' for each static dependency
	#    - If 'build' returns -1 (fails) and --quickstop is specified, we are done
	#    - If 'build' returns 1, the target needs to be built
	# 2. Calculate any dynamic dependencies for $target and run 'build' for each one
	#    - If 'build' returns -1 (fails) and --quickstop is specified, we are done
	#    - If 'build' returns 1, the target needs to be built
	# 3. If nothing was built ($result is 0), check each static+dynamic dependency for time
	#    - If needbuild? returns 1, the target needs to be built
	# 4. If build not forced, check substituted '-do' against any cached value
	#    - If cached commands exists and they are different, the target needs to be built

	# First check dynamic dependencies
	set depends $t(depends)

	# 1. Static dependencies
	foreach i $depends {
		# XXX: Recursive call to build here
		set rc [build $i]
		if {$rc < 0} {
			if {$tmake(exitcode) == 0} {
				build-error "[make-source-location $ruletarget "" ": "]Error: Don't know how to build $i: [join [lreverse $tmake(current)] { <= }]"
			}
			set result -1
			if {$tmake(quickstop)} {
				break
			}
		} elseif {$rc > 0} {
			lappend reason depend $i
			if {$result == 0} {
				dputs b "Rebuilding $target because $i was built"
				set result 1
			}
		}
	}

	set vardict [make-var-dict [array get t]]

	if {$result >= 0} {
		# 2. Dynamic dependencies. Only targets or existing files are returned by calc-dyndeps.
		# Need to set target vars before doing this

		set dyndeps [calc-dyndeps $vardict $ruletarget]

		# Even before we do anything else, if the list of dependencies has changed,
		# the target needs to be built
		if {$result == 0 && [llength $t(do)]} {
			if {$t(phony)} {
				# Phony target isn't going to get rebuild regardless
			} elseif {![dict exists $tmakecache(deps) $ruletarget]} {
				if {[llength $t(depends)]} {
					dputs b "No previous dyndeps for $ruletarget"
					set result 1
					lappend reason nocache
				}
			} elseif {[lsort $dyndeps] ne [dict get $tmakecache(deps) $ruletarget]} {
				dputs b "dyndeps for $ruletarget have changed, so forcing build"
				set result 1
				lappend reason dyndeps
			}
		}

		foreach i $dyndeps {
			lappend depends $i

			if {[check-signal]} {
				set result -1
				break
			}

			# XXX: Recursive call to build here
			set rc [build $i]
			if {$rc < 0} {
				if {$tmake(exitcode) == 0} {
					build-error "Error: Don't know how to build $i: [join [lreverse $tmake(current)] { <= }] [make-source-location $ruletarget @]"
				}
				set result -1
				if {$tmake(quickstop)} {
					break
				}
			} elseif {$rc > 0} {
				lappend reason depend $i
				if {$result == 0} {
					dputs b "Rebuilding $ruletarget because $i was built"
					set result 1
				}
			}
		}
	}

	if {$tmake(quickstop) && $tmake(exitcode)} {
		user-notice [colerr lred "*** Error: Targets failed to build"]
		tmake-exit $tmake(exitcode)
	}

	if {$result == 0 && [llength $depends]} {
		# 3.  Target exists but no dependencies were built so check time dependencies
		if {[needbuild? $ruletarget $depends depfile]} {
			lappend reason older $depfile
			set result 1
		}
	}

	# If this target belongs to a different rule than previously...
	if {$result == 0 && [llength $t(do)] && [dict exists $tmakecache(target) $target]} {
		if {$ruletarget ne [dict get $tmakecache(target) $target]} {
			dputs b "Target $target is built by a different rule"
			dputs B "Was [dict get $tmakecache(target) $target] but is now $ruletarget"
			lappend reason newrule
			set result 1
		}
	}

	# 4. Compare previous '-do' commands with current commands
	if {$result == 0 && [llength $t(do)]} {
		if {![dict exists $tmakecache(cmd) $ruletarget]} {
			# If there are no dependencies, changed commands don't cause a rebuild by themselves
			# XXX: Should there be a special flag for this sort of rule?
			if {[llength $t(depends)]} {
				dputs b "No cached commands for $ruletarget, so forcing rebuild"
				lappend reason nocache
				set result 1
			}
		} else {
			set do [subst-do $vardict $t(do)]
			set prevdo [dict get $tmakecache(cmd) $ruletarget]
			if {$do ne $prevdo} {
				dputs {b B} "Commands for $ruletarget have changed, so forcing rebuild"
				if {[debug-is-set B]} {
					puts "=== old ==="
					foreach d $prevdo {
						show-rule-commands $d
					}
					puts "=== new ==="
					foreach d $do {
						show-rule-commands $d
					}
					puts "-----------"
				}
				lappend reason commands
				set result 1
			} else {
				dputs-n "Commands for $ruletarget are unchanged"
			}
		}
	}

	if {$result > 0 && [llength $t(do)]} {
		dputs g "[join $tmake(current) { --> }] ($reason)" 0
	}

	if {$result > 0 && [llength $t(do)]} {
		#puts "Running rules for $ruletarget"
		dputs b "Building [join [lreverse $tmake(current)] { <= }] [make-source-location $ruletarget "with rule @"]"
		run-do $vardict $t(msg)

		if {[dict get $tmake(debugtypes) r]} {
			show-rule $ruletarget
		}
		if {$tmake(norun)} {
			foreach do $t(do) {
				if {$tmake(norun) == 1} {
					show-rule-commands [subst-do $vardict $do]
				}
			}
			set rc 0
		} else {
			# Create all the target directories as required
			# XXX: Probably should make this more efficient
			foreach i $ruletarget {
				set targetdir [file-build [file dirname $i]]
				dputs m "mkdir $targetdir"
				file mkdir $targetdir
			}
			foreach do $t(do) {
				if {$t(chdir)} {
					set targetdir [file-build [file dirname [lindex $ruletarget 0]]]
					dputs m "cd $targetdir"
					cd $targetdir
				}
				set oldenv [env-save]
				lassign [run-do $vardict $do] rc msg opts
				env-restore $oldenv
				# Always restore the current dir afterwards
				cd $tmake(topsrcdir)
				if {$rc} {
					# XXX: Check for signal?
					if {$t(nofail)} {
						user-notice [colerr cyan "\[ignored\] $msg"]
						set rc 0
					} else {
						break
					}
				}
			}
		}

		if {[check-signal 1]} {
			pputs ""
			set tmake(exitcode) 2
			set rc 5
		}

		# Always delete $t(clean) files after the rule has run
		if {[llength $t(clean)]} {
			dputs m "file delete $t(clean)"
			file delete {*}$t(clean)
		}

		# Did the rule make the targets?
		if {$rc == 0 && !$t(phony) && !$tmake(norun) && ![is-cleaning?]} {
			set now [clock seconds]
			foreach f $ruletarget {
				if {![file exists [file-build $f]]} {
					# XXX: Should onerror run here if --quickstop is set?
					# XXX: Should the cache still be updated?
					build-error "[make-source-location $ruletarget "" ": "]Error: Rule for $target failed to build target(s) $f ([file-build $f])"
					# Use break to indicate that we have already output the message
					set rc 3
				} elseif {!$t(nocache)} {
					# Record the time that this target was created, along with the real mtime
					dict set tmakecache(file) $f [list $now [file-real-mtime $f]]
					#puts "Set cachetime of $f [clock format $now] [clock format [file-real-mtime $f]]"
					# Remember the rule which built this target
					dict set tmakecache(target) $f $ruletarget
				}
			}
			# Save the commands in the command cache and the list of dyndeps
			dict set tmakecache(cmd) $ruletarget [subst-do $vardict $t(do)]
			dict set tmakecache(deps) $ruletarget [lsort $dyndeps]
			mark-cache-dirty "Targets built"
		}

		if {$rc == 0} {
			if {!$t(phony)} {
				incr tmake(numtargets)
			}
		} else {
			# On failure, delete the target(s)
			file delete {*}$ruletarget

			# Try to run onerror
			lassign [run-do $vardict $t(onerror)] frc fmsg fopts
			if {$frc} {
				build-error [error-stacktrace $fmsg]
			} elseif {$rc == 1} {
				build-error [error-stacktrace $msg]
			}
			set result -1
		}

		if {$rc == 5 || ($tmake(quickstop) && $tmake(exitcode))} {
			user-notice [colerr lred "*** Error: Targets failed to build"]
			tmake-exit $tmake(exitcode)
		}
	}

	set oldstatus $status
	if {$result < 0} {
		set status failed
	} elseif {$result > 0} {
		set status built
	} else {
		set status uptodate
	}
	#puts "status changed for $ruletarget from $oldstatus => $status ($result)"
	set-rule-status $ruletarget $status

	set tmake(current) $oldcurrent
	return $result
}

# ==================================================================
# Dynamic dependencies
# ==================================================================

proc header-scan-regexp {suffix regex filename} {
	if {![file exists $filename]} {
		set filename [file-build $filename]
		if {![file exists $filename]} {
			# Might be a target which failed to build. This will be handled later
			dputs-D "header-scan-regexp $filename => <does not exist>"
			return {}
		}
	}
	set f [open $filename]
	set headers {}
	set n 0
	set d 0
	while {[gets $f buf] >= 0} {
		incr n
		if {[regexp $regex $buf -> name]} {
			append name $suffix
			lappend headers $name
		}
	}
	close $f
	dputs-D "header-scan-regexp $filename => $headers"
	return $headers
}

# Returns a list of {type path-to-filename}
# where type is "target" or "source"
#
# If the $path/$filename is neither a target nor source, the empty list is returned
proc find-file-on-path {filename path} {
	set f [file-join $path $filename]

	#puts "find-file-on-path $filename + $path => $f"

	set result {}
	if {[is-target? $f]} {
		dputs-D "$f is a target, so building first"
		# Even if it fails to build, it is needed
		if {[build $f] >= 0} {
			set result [list target $f]
		}
	} else {
		if {[file exists $f]} {
			#puts "  => $f exists"
			set result [list source $f]
		} else {
			#puts "  => $f does not exist"
		}
	}
	return $result
}

# Returns a list of {type path ...}
# where type is "target" or "source" and the path is:
#
# target -  $path-to-filename
# source -  $path-to-filename
#
# Note that the current directory (.) is special.
# We return both the first match along $paths and any match on [file dirname $filename]
# (Unless they are the same)
#
proc find-file {filename paths} {
	#puts "find-file filename=$filename, paths=$paths"

	# First check the per-run cache
	set cachekey "$filename $paths"
	if {[dict exists $::tmake(depfindcache) $cachekey]} {
		#puts "=> (cached) [dict get $::tmake(depfindcache) $cachekey]"
		return [dict get $::tmake(depfindcache) $cachekey]
	}

	set result {}
	set filedir [file dirname $filename]
	set seendot 0

	# First search the given paths
	foreach p $paths {
		if {$p eq $filedir} {
			incr seendot
		}
		lappend result {*}[find-file-on-path $filename $p]
		if {[llength $result]} {
			break
		}
	}

	# If we didn't search $filedir, do it now
	if {!$seendot} {
		lappend result {*}[find-file-on-path $filename $filedir]
	}

	if {[llength $result] == 0} {
		dputs-D "Not a file and not a target, $filename"
	}
	if {[debug-is-set D] && [llength $result] > 2} {
		dputs-D "Note: Found multiple locations for $filename: [join $result]"
	}
	#puts "find-file filename=$filename, paths=$paths => $result"
	# Cache this result
	dict set ::tmake(depfindcache) $cachekey $result

	#puts "=> [dict get $::tmake(depfindcache) $cachekey]"

	return $result
}

# XXX: This could be done better
#
proc header-scan-regexp-recursive {incpaths suffix regex filename} {
	global tmake tmakecache

	if {[is-target? $filename]} {
		set filepath [file-build $filename]
	} else {
		set filepath $filename
	}
	if {![file exists $filepath]} {
		dputs-D "header-scan-regexp-recursive, $filepath does not exist"
		return {}
	}
	set cachekey "$incpaths $suffix $regex $filename"

	dputs-D "Scanning $filename for headers: incpaths=$incpaths"
	# Can we get the result from the cache?
	set stamp [list [file mtime $filepath] $incpaths $suffix $regex]
	if {[dict exists $tmakecache(headerscan) $filename]} {
		lassign [dict get $tmakecache(headerscan) $filename] cache_stamp headers cachedresults
		if {$cache_stamp eq $stamp} {
			# Need to verify that find-file returns the same result as last time
			#puts "---- $filename ----"
			#parray cachedresults
			set ok 1
			foreach {cfile ctypepath} $cachedresults {
				set typepath [find-file $cfile $incpaths]
				if {$typepath ne $ctypepath} {
					dputs-d "previously $cfile resolved to {$ctypepath}, but now resolves to {$typepath}, discarding cache"

					# Now what if the file was previously a target it is an orphan.
					# Discard it to avoid mistakenly thinking that it is a new source file.
					foreach {type path} $ctypepath {
						if {$type eq "target"} {
							dputs-d "discarding orphan $path"
							file delete $path
						}
					}
					set ok 0
					break
				}
			}
			if {$ok} {
				# Can reuse the cache
				dputs-d "header-scan-regexp $filename (cached) => $headers"
				return $headers
			}
		}
		# Stale
		dict unset tmakecache(headerscan) $filename
	}

	# Recursively scan files
	unset -nocomplain deps results
	array set deps {}
	array set results {}
	set scanned($filename) 1
	set toscan [header-scan-regexp $suffix $regex $filepath]
	while {[llength $toscan]} {
		set newscan {}
		foreach d $toscan {
			if {![info exists scanned($d)]} {
				set scanned($d) 1
				set findfiles [find-file $d $incpaths]
				set results($d) $findfiles
				foreach {type deppath} $findfiles {
					set deps($deppath) 1
					lappend newscan {*}[header-scan-regexp $suffix $regex $deppath]
				}
			}
		}
		set toscan $newscan
	}

	#puts "---- $filename ----"
	#parray results
	# memoize the result
	set headers [array names deps]
	dict set tmakecache(headerscan) $filename [list $stamp $headers [array get results]]
	mark-cache-dirty "New header scan"
	return $headers
}

proc colout {colour string} {
	return $string
}

proc colerr {colour string} {
	return $string
}

# Embedded modules are inserted below here
##-- CUT HERE --##

# ==================================================================
# ENTRY POINT
# ==================================================================

if {[catch {make $argv} msg]} {
	user-notice [colerr lred [error-stacktrace $msg]]
	set tmake(exitcode) 1
}

if {$tmake(numtargets) || $tmake(showtime)} {
	set elapsed [expr {([clock-millis] - $tmake(start)) / 1000.0}]
	if {!$tmake(quiet)} {
		pputs [colout cyan "Built $tmake(numtargets) of [dict size $tmake(targets)] target(s) in [format %.2f $elapsed] seconds"]
	}
}
if {$tmake(exitcode)} {
	user-notice [colerr lred "*** Error: Targets failed to build"]
}

tmake-exit $tmake(exitcode)
