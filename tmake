#!/usr/bin/env jimsh

# ==================================================================
# LOW LEVEL RULES
# ==================================================================

proc xset {name args} {
	upvar #0 $name n
	set n [join $args]
}

proc xset? {name args} {
	upvar #0 $name n
	if {![info exists n] || $n eq ""} {
		set n [join $args]
	}
}

proc suffix {suf args} {
	lmap p [join $args] {
		append p $suf
	}
}

proc change-ext {new args} {
	lmap p [join $args] {
		set x [file rootname $p]$new
	}
}

proc prefix {pre args} {
	lmap p [join $args] {
		set x $pre$p
	}
}

proc is-target? {target} {
	info exists ::maketargets($target)
}

proc target {target args} {
	set info(source) [lrange [info frame 1] 1 end]
	set -depends {}
	set -clean {}
	set -rules {}
	set -onfail {}
	foreach a $args {
		if {[string match -* $a]} {
			if {![info exists $a]} {
				error "Unknown option to target: $a"
			}
			set current $a
		} else {
			lappend $current $a
		}
	}
	# Hmmm. we really want to capture the local variables in our caller's scope
	foreach v [uplevel 1 info locals] {
		dict set info(vars) $v [uplevel 1 set $v]
	}
	set info(depends) [join ${-depends}]
	set info(clean) ${-clean}
	set info(rules) [lindex ${-rules} 0]
	#puts "Doing subst of: <<<${-rules}>>> ==> ((($info(rules))))"
	set info(onfail) ${-onfail}
	set info(target) $target

	if {[info exists ::maketargets($target)]} {
		set orig $::maketargets($target)
		if {$info(rules) ne "" && $orig(rules) ne ""} {
			error "Duplicate rules for $target at $info(source) and $orig(source)"
		}
		lappend info(depends) {*}$orig(depends)
		lappend info(clean) {*}$orig(clean)
		append info(onfail) \n$orig(onfail)
		if {$info(rules) eq ""} {
			set info(rules) $orig(rules)
		}
	}
	dict set info(vars) T $info(target)
	dict set info(vars) D $info(depends)

	set ::maketargets($target) $info
}

proc showrules {rules} {
	foreach j [split $rules \n] {
		set r [string trim $j]
		if {$r ne ""} {
			puts "\t$r"
		}
	}
}

proc dumptarget {target} {
	if {[info exists ::maketargets($target)]} {
		set t $::maketargets($target)
		puts "$target: $t(depends)"
		showrules $t(rules)
		#set V $t(vars)
		#parray V
	} else {
		puts "No rule to make $target"
	}
}

proc dumptargets {} {
	foreach i [lsort [array names ::maketargets]] {
		dumptarget $i
		puts ""
	}
}

proc needbuild? {target source} {
	if {[file exists $target]} {
		if {[file exists $source]} {
			if {[file mtime $target] >= [file mtime $source]} {
				puts "Not building $target because it is newer than $source"
				return 0
			}
		}
		puts "Building $target because it is older than $source or $source does not exist"
		return 1
	} else {
		puts "Building $target because it does not exist"
		return 1
	}
}

proc subst-rules {_v _r} {
	foreach _ [dict keys $::X] {
		set $_ [dict get $::X $_]
	}
	foreach _ [dict keys $_v] {
		set $_ [dict get $_v $_]
	}
	subst $_r
}

proc run {args} {
	puts "[join $args]"
	exec {*}[join $args]
}

proc build {target {making unknown}} {
	if {![info exists ::maketargets($target)]} {
		if {[file exists $target]} {
			return 1
		}
		puts stderr "Don't know how to build $target, while making $making"
		return -1
	}
	set t $::maketargets($target)
	set needbuild 0
	set nobuild 0
	if {[file exists $target]} {
		foreach i $t(depends) {
			if {[needbuild? $target $i]} {
				incr needbuild
				break
			}
		}
	} else {
		incr needbuild
	}

	if {$needbuild} {
		# First make sure dependencies are up to date
		puts "Building dependencies of $target"
		foreach i $t(depends) {
			#puts "Building $i"
			#dumptarget $i
			if {[build $i $target] < 0} {
				puts "Failed to build $i"
				set nobuild 1
			}
		}
		if {!$nobuild && $t(rules) ne ""} {
			puts "Running rules for $target"
			showrules $t(rules)
			try {
				uplevel #0 [subst-rules $t(vars) $t(rules)]
			} on error {msg opts} {
				puts $msg
				file delete $target {*}$t(clean)
			}
		} else {
			#puts "Not running rules for $target [expr {$nobuild ? "because dependency failed" : "because no rules"}]"
		}
	} else {
		puts "No need to build $target"
	}
	return 0
}

proc find {filename} {
	return $filename
}

proc make {argv} {
	if {$argv eq ""} {
		set argv all
	}
	foreach a $argv {
		if {$a eq "-P"} {
			dumptargets
			exit 0
		}
		build $a
	}
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

proc Executable {target {args srcs}} {
	if {$target eq "--test"} {
		set srcs [lassign $srcs target]
		# XXX: Do something with test here
	}
	Link $target {*}[Objects {*}$srcs]
	target all -depends $target
}

# Link an executable from objects
proc Link {target {args objs}} {
	target $target -depends {*}$objs -rules $::EXERULE
	lappend ::cleanfiles $target
}

proc ArchiveLib {base {args srcs}} {
	set libname lib$base.a
	target $libname -depends {*}[Objects {*}$srcs] $::ARRULE
	target all -depends $libname
}

proc Phony {target {args deps}} {
	target all -depends {*}$deps
}

# Create an object file from each source file
# Uses $OBJSRULES(.ext) to determine the build rule
# Returns a list of objects
proc Objects {{args srcs}} {
	set objs {}
	foreach src $srcs {
		set obj [change-ext .o $src]
		lappend objs $obj
		target $obj -depends $src -rules $::OBJRULES([file ext $src])
		lappend ::cleanfiles $obj
	}
	return $objs
}

proc CFlags {{args flags}} {
	lappend ::X(CFLAGS) {*}$flags
}

proc C++Flags {{args flags}} {
	lappend ::X(CXXFLAGS) {*}$flags
}

proc LinkFlags {{args flags}} {
	lappend ::X(LDFLAGS) {*}$flags
}

proc PublishIncludes {{args includes}} {
	#target 
}

proc PublishArchiveLibs {{args libs}} {
	#target 
}

proc RunTest {{args cmd}} {
	#target 
}

set cleanfiles {}
target clean -rules {
	file delete {*}$::cleanfiles
}

# ==================================================================
# DEFAULT RULE BASE
# ==================================================================

set X(CC) cc
set X(CXX) c++
set X(AR) ar
set X(ARFLAGS) cr
set X(CFLAGS) ""
set X(CXXFLAGS) ""
set X(SH_LINKFLAGS) ""
set X(LDFLAGS) ""

set OBJRULES(.c) {run $CC $CFLAGS -c $D -o $T}
set OBJRULES(.cpp) {run $CXX $CXXFLAGS -c $D -o $T}
set EXERULE {run $CC $CFLAGS $SH_LINKFLAGS $LDFLAGS -o $T $D}
set ARRULE {run $AR $ARFLAGS $T $D}

source build.spec

make $argv
