#!/usr/bin/env jimsh
# Copyright (c) 2011-2016 WorkWare Systems http://www.workware.net.au/
# All rights reserved
# vim:se syntax=tcl:

# ==================================================================
# Initialiation
# ==================================================================

set tmake(version) {0.7.6 (27-Jul-2018)}
set tmake(cacheversion) 4

# Turn on debugging as early as possible
set tmake(debug) $("--debug" in $argv)

set tmake(debugtypes) {d 0 n 0 r 0 b 0 t 0 c 0 g 0 G 0 h 0 p 0 m 0 l 0 D 0 C 0 T 0 B 0 v 0 x 0 j 0}
set tmake(debughelp) {
	* "Enable all debug"
	? "Display help for debug types"
	d "Dynamic dependencies"
	D "Dynamic dependencies (detailed)"
	n "Reasons for targets NOT built"
	b "Reasons for targets BUILT"
	B "Reasons for targets BUILT - changed commands or targets"
	r "Display rules when triggered"
	g "Depencency graph for each target"
	G "List goals (targets) as they are attempted"
	h "Show hashing"
	p "Print rules while parsing"
	m "Miscellaneous (locating and parsing of files)"
	l "Locating sources and targets"
	c "Configuration expressions via ifconfig"
	C "Cache handling"
	T "Timing (add --delta for delta times)"
	v "Variable definition"
	j "Parallel (job-based) builds"
}
set tmake(verbose) 0
set tmake(showdelta) 0
set tmake(norun) 0
set tmake(showtime) 0
set tmake(quickstop) 0
set tmake(showrules) 0
set tmake(exitcode) 0
set tmake(autosubdirs) 1
set tmake(checkexternalcmds) 0
set tmake(deferred) {}
set tmake(projfiles) {}
set tmake(defines) {}
set tmake(fixedvars) {}
set tmake(installed) 0
set tmake(cleaning) 0
set tmake(quiet) 0
set tmake(ignoreforce) 0
set tmake(force) 0
set tmake(usepager) 1
set tmake(showcache) 0
set tmake(showvars) 0
set tmake(showaliases) 0
set tmake(showwarnings) 0
set tmake(usehashes) 0
set tmake(cachecleanup) 0
set tmake(depfindcache) {}
set tmake(addtargets) {}
set tmake(varloc) {}
set tmake(emptycache) {
	file {} cmd {} deps {} target {} headerscan {} warnings {}
	exec {} version 0 writecache 0 srchash {} dephash {} usehashes 0
	updatecount 0
}

set tmake(commands-overview) {}
set tmake(commands) {}
set tmake(cli-options) {}
# Template for a target. flags have values of 0, while nonflags have {}
set tmake(emptytarget) {
	alias {} chdir 0 depends {} do {} dyndep {} fatal 0 finally {}
	getvars {} hash 0 inputs {} msg {} nocache 0 nofail 0
	nofork 0 onerror {} phony 0 rootok 0 slow 0 symlink 0 vars {}
}

# The known clean targets
set tmake(clean-targets) {clean distclean clean-orphans}

set tmakecache $tmake(emptycache)
set tmakeprecache {}
set tmakemodules {}

set tmake(defaulttarget) all
set tmake(loadedprojectspec) 0
set tmake(current) {}
set tmake(rules) {}
set tmake(ruledefaultopts) {}
set tmake(aliases) {}
set tmake(rulestatus) {}
set tmake(targetstatus) {}
set tmake(targets) {}
set tmake(parsedone) 0
set tmake(numtargets) 0
set tmake(subdirs) {}
set tmake(prefix) ""
set tmake(localdir) .
set tmake(warningmsgs) {}
set tmake(running) {}
set tmake(pending) {}
set tmake(jobpid) -1
set tmake(resetstatus) 0

# ==================================================================
# Argument Processing
# ==================================================================

proc make-parse-options {argv} {
	global tmake
	#puts "make-parse-options [list $argv]"

	use argparse

	# Do we need to remove anything from cli-options
	# e.g. -C?
	set tmake(cli-options) $argv

	argparse argv {
		--configure {
			# Just want to run configure with the remaining args
			set tmake(configure) 1
			break
		}
		--showcache {
			incr tmake(showcache)
		}
		{--find --find=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 0
		}
		{--findall --findall=*} {
			set tmake(findtarget) [argparam $arg]
			set tmake(findall) 1
		}
		{--jobs=*} {
			define! MAXJOBS [argparam $arg]
		}
		--delta {
			incr tmake(showdelta)
		}
		--build=* {
			set tmake(build) [argparam $arg]
		}
		--force {
			incr tmake(force)
		}
		--showvars {
			set tmake(showvars) 1
		}
		--showvars=* {
			set tmake(showvars) 2
		}
		--hash {
			incr tmake(usehashes)
		}
		--cacheclean* {
			incr tmake(cachecleanup)
		}
		--showaliases {
			incr tmake(showaliases)
		}
		--warnings {
			incr tmake(showwarnings)
		}
		--rulebase {
			set rulebase [get-rulebase]
			if {[llength $rulebase] > 1} {
				puts [lindex $rulebase 1]
			} else {
				puts [readfile [lindex $rulebase 0]]
			}
			exit 0
		}
		--rules {
			user-notice colwarn "Warning: Use --commands rather than the deprecated --rules"
			set tmake(listcommands) *
		}
		--commands {
			set tmake(listcommands) *
		}
		{--commands=*} {
			set tmake(listcommands) [argparam $arg]
		}
		{--targets --targets=all} {
			set tmake(listtargets) [argparam $arg]
		}
		--debug {
			# Enable full stack traces as well as -dg
			set tmake(debug) 1
			dict set tmake(debugtypes) g 1
		}
		-d* {
			if {$arg eq "-d?"} {
				puts "Debugging can be enabled with -d..."
				puts "The debugging categories are as follows:\n"

				foreach {n desc} $tmake(debughelp) {
					puts "\t$n\t$desc"
				}
				exit 0
			}
			if {$arg eq "-d*"} {
				foreach i [dict keys $tmake(debugtypes)] {
					dict set tmake(debugtypes) $i 1
				}
				lappend tmake(cli-options) $arg
			} else {
				foreach i [split [string range $arg 2 end] {}] {
					dict set tmake(debugtypes) $i 1
				}
			}
		}
		{--install=* --install} {
			use install
			tmake_install [argparam $arg]
		}
		{--verbose -v} {
			incr tmake(verbose)
		}
		--col* {
			set tmake(colout) 1
			set tmake(colerr) 1
		}
		--nocol* {
			set tmake(colout) 0
			set tmake(colerr) 0
		}
		--showcol* {
			load-tmakerc
			use colour
			show-colours
			exit 0
		}
		--version {
			use help
			pputs [show-version]
			exit 0
		}
		{--help -h} {
			use help
			show-help $tmake(cli-options)
			exit 0
		}
		--ref {
			use help
			show-reference
			exit 0
		}
		--nopager {
			set tmake(usepager) 0
		}
		--genie {
			use genie
			tmake-genie $tmake(cli-options)
			exit 0
		}
		{--dry-run --just-print -n} {
			set tmake(norun) 1
		}
		{-N -nn} {
			set tmake(norun) 2
		}
		{--tim* -t} {
			incr tmake(showtime)
		}
		{-q --quickstop} {
			incr tmake(quickstop)
		}
		{-Q --quiet} {
			incr tmake(quiet)
		}
		{-p --print*} {
			incr tmake(showrules)
		}
		-C {
			set arg [argnext argv]
			# This will fail with a fatal error if not a dir
			enter-new-dir [file-normalize $arg]
			cd $arg
		}
		-- {
			break
		}
		--* {
			user-error "Unknown option $arg"
		}
		*=* {
			if {[regexp {^([^=]*)=(.*)} $arg -> n v]} {
				# ABC=DEF
				define! $n $v
			}
		}
	}
	return $argv
}

proc callmake {__argv} {
	# This stack frame is designed specifically to hold 'define' variables
	return [make $__argv]
}

proc make {argv} {
	global tmake

	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "early"} {
		fake-an-error
	}

	# 'compat' is needed before we can do anything, so set a temporary $tmake(dir)
	if {!$tmake(installed)} {
		set argv0 $::argv0
		while {[file type $argv0] eq "link"} {
			set argv0 [file readlink $argv0]
		}
		set tmake(dir) [file dirname $argv0]
		use compat
	}

	use colour util fileutil

	# Default colour aliases. We use the col prefix
	# to make it easier to find these in the code
	colalias colwarn purple
	colalias coldebugtime purple
	colalias colrulename purple
	colalias colruleargs yellow
	colalias coldebug yellow
	colalias colenterdir green
	colalias colerror lred
	colalias colnote cyan
	colalias colrunwarn grey
	colalias colstatus lyellow

	set tmake(exe) [file-normalize $::argv0]
	set tmake(dir) [file dirname $tmake(exe)]
	set tmake(start) [clock millis]
	set tmake(hashtime) 0
	set tmake(prevtime) $tmake(start)
	set tmake(initialdir) [pwd]
	set tmake(lastchdir) $tmake(initialdir)
	set tmake(isroot) [is-uid-root]

	# Parse the options and return the list of targets to build

	# XXX Need to do this first to find -C, but
	# tmake.opt and TMAKEFLAGS should really be done first
	# so that command line options can override them
	set tmake(cmdline) [make-parse-options $argv]

	# Need to find the project top
	set tmake(topsrcdir) [find-project-top]
	if {$tmake(topsrcdir) eq ""} {
		user-error "Failed to find project.spec in any parent directory."
	}
	if {[file exists $tmake(topsrcdir)/tmake.opt]} {
		dputs m "tmake.opt exists, so loading command line options"
		make-parse-options [readfile $tmake(topsrcdir)/tmake.opt]
	}
	set TMAKEFLAGS [env TMAKEFLAGS ""]
	if {$TMAKEFLAGS ne ""} {
		dputs m "TMAKEFLAGS is set, so parsing"
		make-parse-options $TMAKEFLAGS
	}

	# We want disabled debugging to be as fast as possible
	# These are called very frequently
	foreach i {n G d D} {
		if {[debug-is-set $i]} {
			alias dputs-$i dputs $i
		} else {
			# proc with null body is specially optimised
			proc dputs-$i {args} {}
		}
	}

	# Find the current dir relative to topsrcdir
	set tmake(subdir) [relative-path [pwd] $tmake(topsrcdir)]

	# Builds run from topsrcdir
	cd $tmake(topsrcdir)

	# Full path
	set tmake(topsrcdir) [pwd]

	load-tmakerc

	# By default, the build directory is 'objdir', but this
	# can be changed with --build, either on the command line or from tmake.opt
	# XXX: Currently tmake.opt overrides the command line because it it parsed later.
	if {![info exists tmake(build)]} {
		dputs m "Setting --build=objdir"
		set tmake(build) objdir
	} else {
		dputs m "Got --build=$tmake(build)"
	}

	# Create the build dir now
	file-mkdir -rooterr $tmake(build)

	set tmake(topbuilddir) [file-normalize $tmake(build)]

	# Make these available in the environment for the benefit of generator programs and scripts
	# which want to be able to find things
	setenv TOPSRCDIR $tmake(topsrcdir)
	setenv TOPBUILDDIR $tmake(topbuilddir)
	setenv BUILDDIR $tmake(build)

	define TOPSRCDIR $tmake(topsrcdir)
	define TOPBUILDDIR $tmake(topbuilddir)
	define BUILDDIR $tmake(build)

	if {$tmake(showcache)} {
		show-cache
		exit 0
	}

	flush stdout

	set tmake(prefix) ""

	if {[exists tmake(configure)]} {
		dputs m "--configure options, so taking over targets"
		# Put the command line in CONFIGURE_OPTS
		# and build configure
		define! CONFIGURE_OPTS $tmake(cmdline)
		set tmake(cmdline) configure
	}

	use getopt config

	# Core implementation simply removes files
	# Project or rulebase can override this
	alias delete-orphan-files file delete

	set rulebase [get-rulebase]

	lassign [invoke-spec-file {*}$rulebase] rc msg opts
	dputs T "Parsed [lindex $rulebase 0]"

	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed rulebase"

	rulebase-invoke init

	dputs T "Initialised rulebase"

	# Save the global state in case we need to reload
	# At this stage it includes defaults, options and the rulebase

	set tmake_save $tmake

	load-build-description 1

	dputs T "Parsing phase complete"
	set tmake(parsedone) 1

	if {$tmake(usehashes)} {
		if {[init-md5sum]} {
			dputs h "Using hashes for file comparison"
		} else {
			set tmake(usehashes) 0
			user-notice colwarn "Warning: no md5sum command - hashing is not available"
		}
	}

	if {$tmake(cachecleanup)} {
		clean-cache
		tmake-exit 0
	}

	if {$tmake(showrules)} {
		show-all-rules
		tmake-exit 0
	}
	if {$tmake(showvars)} {
		show-all-defines $tmake(showvars)
		tmake-exit 0
	}
	if {$tmake(showaliases)} {
		show-all-aliases
		tmake-exit 0
	}
	if {[info exists tmake(listtargets)]} {
		show-all-targets $tmake(listtargets)
		tmake-exit 0
	}
	if {[info exists tmake(listcommands)]} {
		show-matching-commands $tmake(listcommands)
		tmake-exit 0
	}
	if {[info exists tmake(findtarget)]} {
		show-find-results $tmake(findtarget) $tmake(findall)
		tmake-exit 0
	}

	# Targets are relative to the local dir, $tmake(subdir),
	# unless prefixed with / in which case they are global.
	if {[llength $tmake(cmdline)]} {
		foreach arg $tmake(cmdline) {
			if {[regexp {//(.*)} $arg -> realtarget] || [regexp {^/(.*)} $arg -> realtarget]} {
				lappend targets $realtarget
			} else {
				lappend targets [file-join $tmake(subdir) $arg]
			}
		}
	} else {
		lappend targets [file-join $tmake(subdir) $tmake(defaulttarget)]
	}

	# Finally we can begin building the specified targets.
	# Build each target, resetting the status and possibly reloading every time
	while {[llength $targets] && $tmake(exitcode) == 0} {
		set targets [lassign $targets target]

		set tmake(addtargets) {}

		if {$target in $tmake(clean-targets)} {
			set tmake(cleaning) 1
		} else {
			# Try to build all Load files
			# If any files specified to Load are targets,
			# build them before anything else
			# Note that these targets ignore --force
			set reload 0
			set tmake(ignoreforce) 1
			foreach {t nocare} $tmake(projfiles) {
				if {$nocare && ![is-target? $t]} {
					dputs-n "Load --nocare $t, not a target"
					continue
				}
				dputs {b T} "Building Load target $t"
				set status [build-sync $t]
				if {$status eq "failed"} {
					if {$tmake(exitcode) == 0} {
						build-fatal-error "Error: Failed to build $t"
					}
					break
				}
				if {$status eq "built"} {
					dputs m "$t has changed, reloading..."
					set reload 1
				}
			}
			set tmake(ignoreforce) 0

			if {$reload} {
				# Restore the state
				set tmake $tmake_save
				tmake-reset-defines

				# reinitialise the rulebase
				rulebase-invoke init

				dputs T "Reinitialised rulebase"

				load-build-description 0

				dputs T "Reparsing phase complete"
			}

			# Discard orphans before building any non-cleaning target
			do-delete-orphans [get-orphan-targets]
		}

		dputs {b T} "Building target $target"

		set status [build-sync $target]
		if {$status eq "failed"} {
			if {$tmake(exitcode) == 0} {
				if {[is-target? $target]} {
					build-error "Error: Failed to build $target"
				} else {
					build-error "Error: Don't know how to build $target"
				}
			}
			if {$tmake(quickstop)} {
				wait-for-background-jobs
				tmake-exit $tmake(exitcode)
			}
			break
		}

		if {$tmake(cleaning) || $tmake(resetstatus)} {
			# Reset the status of every rule to "unknown" after cleaning or if reset-target-status was called
			set tmake(cleaning) 0
			set tmake(resetstatus) 0
			foreach ruletarget [dict keys $tmake(rules)] {
				set-rule-status $ruletarget unknown
			}
		}

		# Add any new targets to the target list
		# These are added before current targets, so
		set addtargets {}
		foreach new $tmake(addtargets) {
			if {$new ni $targets && $new ni $addtargets} {
				dputs m "$target has added new build target $new"
				lappend addtargets $new
			}
		}
		set targets [list {*}$addtargets {*}$targets]
	}
}

proc load-tmakerc {} {
	set tmakerc [getenv HOME]/.tmakerc
	if {[file exists $tmakerc]} {
		dputs m "Loading $tmakerc"
		source $tmakerc
	}
}

proc rulebase-invoke {cmd} {
	dputs m "No rulebase-invoke, ignoring $cmd"
}

proc get-rulebase {} {
	global tmake
	if {[file exists rulebase.spec]} {
		return rulebase.spec
	} elseif {$tmake(installed)} {
		return [list rulebase.default $tmake(defaultrulebase)]
	} else {
		return [list $tmake(dir)/rulebase.default]
	}
}

# @add-build-targets target ...
#
# May be called from a -do script to dynamically add build targets
# to the list of targets to be built.
proc add-build-targets {args} {
	global tmake
	lappend tmake(addtargets) {*}$args
}

# @reset-target-status
#
# May be called from a -do script if files have been manually changed (e.g. in a phony rule)
# reset-target-status indicates that any new targets added with add-build-targets
# should have their build status set to unknown
proc reset-target-status {} {
	global tmake
	set tmake(resetstatus) 1
}

proc add-project-file {filename nocare} {
	global tmake
	lappend tmake(projfiles) $filename $nocare
}

# @add-clean-targets target...
#
# Adds the targets to list of those considered to be "cleaning" targets.
# i.e. Those that don't need to force projfiles to be loaded
proc add-clean-targets {args} {
	global tmake
	lappend tmake(clean-targets) {*}$args
}

# @set-default-target target
#
# Sets the default target, when tmake is invoked with no options.
# The default is 'all'
proc set-default-target {target} {
	global tmake
	set tmake(defaulttarget) $target
}

proc load-cache {} {
	global tmake tmakecache

	set dirty 1
	set clear 1
	if {![file exists $tmake(topbuilddir)/.makecache]} {
		dputs C ".makecache missing, starting with empty cache"
		set dirty 0
	} else {
		try {
			lassign [time {source $tmake(topbuilddir)/.makecache}] us
			dputs C "Loaded cache, .makecache in [expr {($us + 500) / 1000}]ms"
			if {$tmakecache(version) != $tmake(cacheversion)} {
				user-notice colnote ".makecache is out-of-date -- ignoring"
			} else {
				set clear 0
				set dirty 0
			}
		} on error msg {
			dputs C ".makecache failed to load, starting with empty cache"
		}
	}
	if {$clear} {
		set tmakecache $tmake(emptycache)
		# But overwrite the cache next time around
		set tmakecache(writecache) $dirty
	}
}

proc clean-cache {} {
	global tmakecache

	set count 0
	# go through headerscan and srchash and discard any entries that don't correspond to files
	# that exist (or targets for headerscan)
	foreach file [dict keys $tmakecache(srchash)] {
		if {![file exists $file]} {
			incr count
			dict unset tmakecache(srchash) $file
		}
	}
	foreach file [dict keys $tmakecache(headerscan)] {
		if {![file exists $file] && ![is-target? $file]} {
			incr count
			dict unset tmakecache(headerscan) $file
		}
	}
	if {$count} {
		note Removing $count old entries from cache
		mark-cache-dirty "clean cache"
	}
}

proc mark-cache-dirty {msg} {
	global tmakecache
	if {$tmakecache(writecache) == 0} {
		dputs C "$msg, marking cache dirty"
		set tmakecache(writecache) 1
	}
}

proc write-cache {} {
	global tmake tmakecache
	if {$tmakecache(writecache)} {
		# This should never happend because it is hard to make any changes that require
		# the cache to be updated if only install rules are -rootok
		# Writing an existing file as root is fine
		if {$tmake(isroot) && ![file exists $tmake(topbuilddir)/.makecache]} {
			# Don't call build-fatal-error here since that calls tmake-exit which calls build-fatal-error
			puts stderr [colerr colerror "Error: Refusing to create .makecache when running as root"]
			exit 1
		}
		set tmakecache(version) $tmake(cacheversion)
		unset tmakecache(writecache)
		incr tmakecache(updatecount)
		file-mkdir -rootskip $tmake(topbuilddir)
		lassign [time {
			set f [open $tmake(topbuilddir)/.makecache w]
			foreach i [dict keys $tmakecache] {
				puts $f [list set tmakecache($i) $tmakecache($i)]
			}
			close $f
		}] us
		dputs C "Wrote cache, .makecache in [expr {($us + 500) / 1000}]ms"
	} else {
		dputs C "Cache unchanged, not writing"
	}
}

proc load-build-description {loadcache} {
	global tmake tmakecache

	lassign [invoke-spec-file project.spec] rc msg opts

	# ifconfig returns code 20 to skip some or all of the file
	if {[info return $rc] ni {ok return 20}} {
		return -code $rc {*}$opts $msg
	}

	dputs T "Parsed project.spec"

	# Note that these are global, not per-directory, so fetch the values now
	set tmake(maxjobs) [get-define MAXJOBS [get-num-cpus]]
	if {![exists -command os.fork]} {
		# No os.fork, so we can't do parallel builds
		set tmake(maxjobs) 1
	}
	dputs m "Setting maxjobs=$tmake(maxjobs)"
	set tmake(sepjobio) [get-define SEPJOBIO 1]

	# Loaded in the global scope

	foreach i $tmake(deferred) {
		uplevel #0 $i
	}

	# Now load the cache if it exists and it isn't the second time through
	if {$loadcache} {
		load-cache

		if {!$tmake(checkexternalcmds) && [dict size $tmakecache(exec)]} {
			# If disabled, discard any previously cached external command info
			dict set tmakecache exec {}
			mark-cache-dirty "external cmd cache discarded"
		}
	}

	set tmake(loadedprojectspec) 1

	process-build-spec-file . 1

	unset tmake(prefix)
	unset tmake(localdir)

	# Now validate that there is no non-phony target which depends on a phony target
	foreach ruletarget [dict keys $::tmake(rules)] {
		if {![get-rule-attr $ruletarget phony]} {
			foreach dep [get-rule-attr $ruletarget depends] {
				if {[is-target? $dep]} {
					if {[dict get [get-target-rule $dep] phony]} {
						user-notice colwarn "Non phony target $ruletarget [make-source-location $ruletarget @] depends on phony $dep"
						tmake-exit 1
					}
				}
			}
		}
	}
}

proc is-cleaning? {} {
	return $::tmake(cleaning)
}

# ==================================================================
# .spec file processing
# ==================================================================

# Returns "" if project top not found
proc find-project-top {} {
	set topdir [pwd]
	while {![file exists $topdir/project.spec]} {
		set parent [file dirname $topdir]
		if {$topdir eq $parent} {
			dputs m "Project top not found"
			return ""
		}
		set topdir $parent
	}
	dputs m "Project top found at $topdir"
	return $topdir
}

proc local-prefix {} {
	if {![exists ::tmake(prefix)]} {
		error "local-prefix invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(prefix)
}

proc local-src-prefix {} {
	return $::tmake(topsrcdir)/$::tmake(prefix)
}

proc local-dir {} {
	if {![exists ::tmake(localdir)]} {
		error "local-dir invoked outside of parse phase - did you mean \$tmake(subdir)?"
	}
	return $::tmake(localdir)
}

proc top-src-dir {} {
	return $::tmake(topsrcdir)
}

proc make-local {args} {
	prefix [local-prefix] $args
}

proc make-local-dirs {args} {
	lmap dir $args {
		file-join [local-dir] $dir
	}
}

# Reverses make-local
proc make-unlocal {args} {
	set striplen [string length [local-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

# Reverses make-local-src
proc make-unlocal-src {args} {
	set striplen [string length [local-src-prefix]]
	lmap name $args {
		string range $name $striplen end
	}
}

proc make-prefix {dir} {
	if {$dir eq "."} {
		return ""
	} else {
		return $dir/
	}
}

proc make-local-src {args} {
	prefix [local-src-prefix] $args
}

# @invoke-spec-file filename ?script?
#
# Returns a list of rc msg opts, as returned from run-do
proc invoke-spec-file {filename args} {
	global tmake

	if {$filename eq ""} {
		set cmd [lindex $args 0]
	} else {
		lappend tmake(specfiles) $filename

		# If given, the argument is the contents of the file
		if {[llength $args]} {
			set cmd [info-source [lindex $args 0] $filename 1]
		} else {
			set cmd [list source $filename]
		}
	}

	# Spec files are loaded at frame level #1, in the scope of run-do
	# 'define' relies on this
	set result [uplevel #0 [list run-do {} $cmd]]

	if {[info return [lindex $result 0]] ni {ok return 20}} {
		# If there is an error, ensure the 'Entering directory' message
		# is shown first
		enter-new-dir $tmake(topsrcdir)
	}

	if {[check-signal]} {
		tmake-exit 1
	}
	return $result
}

# @AutoSubDirs on|off
#
# If enabled (it is enabled by default), subdirectories containing
# build.spec files are automatically entered.
#
# If not enabled, SubDirs must be used to specifically select project subdirs.
proc AutoSubDirs {onoff} {
	switch -- $onoff {
		on {
			set ::tmake(autosubdirs) 1
		}
		off {
			set ::tmake(autosubdirs) 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

# @SubDirs dir ...
#
# If AutoSubDirs is set to off, SubDirs may be used to identify which directories
# are entered.
#
# Can be used in any directory, but directory names are relative to the project top.
proc SubDirs {args} {
	foreach dir $args {
		if {![file exists $dir/build.spec]} {
			parse-error "Subdirs: No $dir/build.spec found"
		}
	}
	lappend ::tmake(subdirs) {*}$args
}

proc get-onoff-flag {onoff} {
	switch -- $onoff {
		on {
			return 1
		}
		off {
			return 0
		}
		default {
			parse-error "on or off expected"
		}
	}
}

# @CheckExternalCommands on|off
#
# default=off
#
# If enabled, external commands run with 'run' are checked
# (by path, mtime and size), and if the command changes, the corresponding target is rebuilt.
#
# Note that 'distclean' should be run if enabling this in an already-built project
proc CheckExternalCommands {onoff} {
	set ::tmake(checkexternalcmds) [get-onoff-flag $onoff]
}

# @UseHashes on|off
#
# default=off
#
# If enabled, uses hash-based file comparison rather than time-based.
#
# Note: Using --hash on the command line overrides this setting.
#
proc UseHashes {onoff} {
	# This means that UseHashes off is overridden by --hash
	if {[get-onoff-flag $onoff]} {
		incr ::tmake(usehashes)
	}
}

proc file-build {path} {
	if {[string match <* $path]} {
		# Special <lib>, <bin>, etc. are already build paths
		# XXX But are all aliases build paths?
		return $path
	} else {
		#puts "$::tmake(build) + $path => [file-join $::tmake(build) $path]"
		return [file-join $::tmake(build) $path]
	}
}

proc file-build-list {paths} {
	lmap p $paths { file-build $p }
}

proc build-prefix {} {
	make-prefix $::tmake(build)
}

proc build-dir {} {
	return $::tmake(build)
}

# If $srcdir is a dir from the top of the source tree,
# (defaults to [local-dir])
# return a relative path to $buildpath from the build tree.
#
proc file-build-relative {buildpath {srcdir {}}} {
	if {$srcdir eq ""} {
		set srcdir [local-dir]
	}
	if {$srcdir eq $buildpath} {
		return .
	}
	set build [file join $::tmake(topbuilddir) $buildpath]
	set src [file join $::tmake(topsrcdir) $srcdir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file-mkdir -rootskip [file dirname $src]
	relative-path $build $src
}

# If $builddir is a dir from the top of the build tree,
# (defaults to [local-dir])
# return a relative path to $srcpath from the build tree.
#
proc file-src-relative {srcpath {builddir {}}} {
	if {$builddir eq ""} {
		set builddir [local-dir]
	}
	set there [file join $::tmake(topsrcdir) $srcpath]
	set here [file join $::tmake(topbuilddir) $builddir]
	# Note that the source path needs to exist for relative-path to work on all platforms
	file-mkdir -rootskip [file dirname $here]
	relative-path $there $here
}

# Restore all defines as local variables in stack frame #1
proc tmake-reset-defines {} {
	uplevel #1 {
		unset {*}[info vars]
		dict with ::tmake(defines) {}
	}
}

# @Scope { commands }
#
# XXX
proc Scope {{dir ""} script} {
	global tmake
	# Save all defines
	set defines $tmake(defines)
	if {$dir ne ""} {
		set oldlocaldir $tmake(localdir)
		set oldprefix $tmake(prefix)
		set tmake(localdir) $dir
		set tmake(prefix) [make-prefix $dir]
	}

	set result [uplevel 1 $script]
	set tmake(defines) $defines
	# Now need to reset/restore all the variables at frame #1
	if {$dir ne ""} {
		set tmake(localdir) $oldlocaldir
		set tmake(prefix) $oldprefix
	}
	tmake-reset-defines
	return $result
}


# Read in the given spec file in the given directory (relative to topdir)
# Returns 1 if OK, or 0 if subdirs should be skipped
proc process-build-spec-file {dir {optional 0}} {
	global tmake
	dputs m "process-build-spec $dir"
	set ignore 0

	set path [file-join $dir build.spec]

	if {![file exists $path]} {
		# The top level build.spec is optional
		if {!$optional} {
			user-error "$path does not exist"
		}
		incr ignore
	}

	Scope $dir {
		rulebase-invoke prolog
		if {$ignore} {
			set rc 0
		} else {
			lassign [invoke-spec-file $path] rc msg opts

			dputs T "Parsed [local-prefix]build.spec"
		}
		rulebase-invoke epilog
	}


	if {$rc == 20} {
		dputs m "Skipping $path"
		return
	}
	if {[info return $rc] ni {ok return}} {
		return -code $rc {*}$opts $msg
	}

	# Now subdirectories

	# Find the explicitly set subdirs
	set subdirs $tmake(subdirs)
	set tmake(subdirs) {}

	# Normally we search for dirs containing build.spec
	if {$tmake(autosubdirs)} {
		foreach d [readdir $dir] {
			if {[file exists $dir/$d/build.spec] && $d ni $subdirs} {
				lappend subdirs [file-join $dir $d]
			}
		}
	}

	# Now process subdirs
	foreach d $subdirs {
		process-build-spec-file $d
	}
}

# @VirtualSubDir dir { ... build.spec rules ... }
#
# XXX
proc VirtualSubDir {dir code} {
	Scope $dir {
		rulebase-invoke prolog
		invoke-spec-file {} $code
		rulebase-invoke epilog
	}
}

proc do-delete-orphans {orphans} {
	if {[llength $orphans]} {
		delete-orphan-files {*}[file-build-list $orphans]
		note Clean removing [llength $orphans] orphan target(s)
		dputs C $orphans
		discard-orphan-targets
	}
}

# Returns a list of all files which were once a target but are no longer
proc get-orphan-targets {} {
	global tmakecache

	set result {}
	foreach i [dict keys $tmakecache(file)] {
		if {![is-target? $i]} {
			lappend result $i
		}
	}
	return $result
}

proc discard-orphan-targets {} {
	global tmake tmakecache
	set discard 0

	foreach i [get-orphan-targets] {
		#puts "Discarding orphan file $i"
		dict unset tmakecache(file) $i
		set discard 1
	}

	# Also discard the build commands, targets and dependencies
	foreach i [dict keys $tmakecache(cmd)] {
		if {![is-rule? $i]} {
			#puts "Discarding orphan rule $i"
			dict unset tmakecache(cmd) $i
			dict unset tmakecache(dephash) $i
			set discard 1
			foreach j $i {
				#puts "Discarding orphan target and deps $j"
				dict unset tmakecache(target) $j
				dict unset tmakecache(deps) $j
				dict unset tmakecache(exec) $j
				dict unset tmakecache(file) $j
				dict unset tmakecache(warnings) $j
				dict unset tmakecache(headerscan) $j
			}
		}
	}
	if {$discard} {
		mark-cache-dirty "discarded orphan targets"
	}
}

# Like file mkdir except if the directory doesn't exist
# and the current user is root, the option indicates what should happen.
#
## -rootskip  do nothing
## -rooterr   fatal error

proc file-mkdir {option name} {
	if {![is-uid-root] || [file isdir $name]} {
		tailcall file mkdir $name
	}
	if {$option eq "-rootskip"} {
		return
	} elseif {$option eq "-rooterr"} {
		build-fatal-error "Error: Refusing to create directory $name when running as root"
	} else {
		error "got file-mkdir $option $name, option should be -rootskip or -rooterr"
	}
}


# ==================================================================
# Module Loading
# ==================================================================

proc use {args} {
	if {$::tmake(installed)} {
		return
	}
	foreach m $args {
		if {[dict exists $::tmakemodules $m]} {
			continue
		}
		dict set ::tmakemodules $m 1

		set source $::tmake(dir)/lib/${m}.tcl
		if {![file exists $source]} {
			parse-error "use: No such module: $m"
		}
		uplevel #0 [list source $source]
		if {[info procs init-$m] ne {}} {
			init-$m
		}
	}
}

# ==================================================================
# Debug, Errors and Messages
# ==================================================================

# @user-error ?colour? msg
#
# Indicate incorrect usage to the user
# exits with a non-zero return code.
#
proc user-error {{col colerror} msg} {
	puts stderr [colerr $col "Error: $msg"]
	puts stderr "Try: 'tmake --help' for options"
	tmake-exit 1
}

# @build-error ?colour? msg
#
# Indicate that something failed to build and set exitcode=1
proc build-error {{col colerror} msg} {
	if {$msg eq ""} {
		set msg "-- no message --"
	}
	dputs b "BUILD ERROR: $msg"
	puts stderr [colerr $col $msg]
	stderr flush
	set ::tmake(exitcode) 1
}

# @build-fatal-error msg
#
# Indicate that something failed to build and exit with exitcode=1
proc build-fatal-error {msg} {
	dputs b "BUILD FATAL ERROR: $msg"
	puts stderr [colerr colerror $msg]
	stderr flush
	tmake-exit 1
}


# @user-notice ?colour? msg
#
# Output the given message to stderr, possibly with the given colour.
#
proc user-notice {{col {}} msg} {
	if {$col eq {}} {
		puts stderr $msg
	} else {
		puts stderr [colerr $col $msg]
	}
}

# Incorrect usage in the build.spec file. Identify the location.
proc parse-error {msg} {
	global tmake
	# Message may contain a source reference relative to the top source dir
	enter-new-dir $tmake(topsrcdir)

	user-notice colerror [error-location "Error: $msg"]
	tmake-exit 1
}

proc parse-warning {msg} {
	user-notice colwarn [warning-location "Warning: $msg"]
}

proc wait-for-background-jobs {} {
	global tmake
	if {$tmake(jobpid)} {
		while {[wait-for-one-job] != 0} {
			dputs j "Waiting for background jobs to finish"
		}
	}
}

proc tmake-exit {code {msg {}}} {
	global tmake

	if {$tmake(jobpid) == 0} {
		exit $code
	}

	wait-for-background-jobs
	if {$msg ne ""} {
		user-notice colerror $msg
	}

	if 0 {
		# Kill off any running jobs
		foreach pid [dict keys $tmake(running)] {
			dputs j "[pid] Killing background child $pid"
			catch {kill $pid}
		}

		wait-for-background-jobs
	}

	# Write the cache before exiting
	write-cache

	dputs T Done
	exit $code
}

# Output a message to stdout if --verbose is set.
#
proc vputs {msg} {
	if {$::tmake(verbose)} {
		pputs colnote $msg
	}
}

proc pputs {{col {}} msg} {
	if {$col eq {}} {
		puts $msg
	} else {
		puts [colout $col $msg]
	}
	flush stdout
}

# Returns 1 if any of the debug types is set
proc debug-is-set {types} {
	foreach t $types {
		if {[dict get $::tmake(debugtypes) $t]} {
			return 1
		}
	}
	return 0
}

# Output a message to stdout if --debug is set.
#
proc dputs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		pputs "[colout coldebugtime [dbg-msg-indent $indent]] \[$types\] [colout coldebug $msg]"
	}
}

proc dputs-null {args} {}

# Like dputs, but msg needs to be expanded with subst
# This is used for messages which may be expensive to evaluate
proc dputxs {types msg {indent 1}} {
	if {[debug-is-set $types]} {
		dputs $types [uplevel 1 [list subst $msg]]
	}
}

proc dbg-msg-indent {{autoindent 1}} {
	global tmake

	set now [clock millis]
	if {$tmake(showdelta)} {
		set time [expr {$now - $tmake(prevtime)}]
		set tmake(prevtime) $now
	} else {
		set time [expr {$now - $tmake(start)}]
	}
	if {$autoindent && [debug-is-set G]} {
		set indent [string repeat "    " [llength $::tmake(current)]]
	} else {
		set indent {}
	}
	return [format %5dms $time]$indent
}

# ==================================================================
# Show rules, targets, aliases, etc.
# ==================================================================

# Pretty-print the commands for a rule
#
proc show-rule-commands {do} {
	# Note that we don't want to lose source info for $do, so
	# go to special effort to make a copy first
	set docmd [string cat $do ""]
	set lines [split $docmd \n]
	set first [lindex $lines 0]
	if {$first eq ""} {
		set lines [lrange $lines 1 end]
		set first [lindex $lines 0]
	}
	regexp {^(\s*)} $first -> space
	set trim [string length $space]
	set prefix \t
	foreach j $lines {
		set r [string trimright [string range $j $trim end]]
		if {$r ne ""} {
			puts $prefix$r
		}
	}
}

# Output a rule in a user-friendly format
#
proc show-rule {target} {
	if {[is-target? $target]} {
		set ruletarget [get-rule-target $target]
	} else {
		set ruletarget $target
	}
	if {[is-rule? $ruletarget]} {
		global tmakecache
		set t [get-rule $ruletarget]
		set flags {}
		set lines {}
		puts [pad "-- $ruletarget " 60 -]--
		foreach n [lsort [dict keys $t]] {
			set v $t($n)
			set type [target-option-type $n]
			if {$type eq "flag"} {
				if {$v} {
					lappend flags $n
				}
				continue
			}
			switch -- $n {
				do - depends - inputs - building - msg - target {}
				source {
					if {$v ne "unknown"} {
						puts @[join $v {, }]
					}
				}
				result {
					if {$v < 0} {
						lappend flags failed
					} elseif {$v > 0} {
						lappend flags built
					}
				}
				vars {
					foreach {vn vv} $v {
						lappend lines "  var $vn=$vv"
					}
				}
				onerror - finally {
					if {$v ne ""} {
						lappend lines "$n={[join [split [string trim $v] \n] {;}]}"
					}
				}
				alias {
					if {$v ne ""} {
						lappend lines "$n=$v"
					}
				}
				dyndep {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
					# Should we always show cached dyndeps?
					if {[dict exists $tmakecache(deps) $ruletarget]} {
						set dyndeps [lsort [dict get $tmakecache(deps) $ruletarget]]
						foreach dep $dyndeps {
							lappend lines "       $dep"
						}
					}
				}
				default {
					if {$v ne ""} {
						lappend lines "$n=[string trim $v]"
					}
				}
			}
		}
		if {[llength $flags]} {
			set flags " \[$flags\]"
		}
		puts "$t(target)$flags: $t(depends)"
		if {[llength $lines]} {
			puts [join $lines \n]
		}
		foreach do $t(do) {
			show-rule-commands $do
		}

	} else {
		puts "No rule for $ruletarget"
	}
}

proc show-all-rules {} {
	foreach i [lsort [dict keys $::tmake(rules)]] {
		show-rule $i
		puts ""
	}
}

proc show-cache {} {
	global tmake

	if {![file exists $tmake(topbuilddir)/.makecache]} {
		user-notice colwarn "No .makecache"
		return
	}
	set tmakecache $tmake(emptycache)
	source $tmake(topbuilddir)/.makecache

	# Files
	pputs colstatus ".makecache updated $tmakecache(updatecount) times\n"
	pputs colnote "File timestamp"
	puts "-------------------------------------"

	foreach i [lsort [dict keys $tmakecache(file)]] {
		lassign [dict get $tmakecache(file) $i] mtime
		set mtimestr [show-mtime $mtime]
		puts [format "%35s  %s" $i $mtimestr]
	}
	puts ""

	if {[dict size $tmakecache(srchash)]} {
		pputs colnote "Source Hash (mtime hash)"
		puts "---------------------------------------------"
		foreach i [lsort [dict keys $tmakecache(srchash)]] {
			lassign [dict get $tmakecache(srchash) $i] mtime hash
			puts [format "%35s  %s %s" $i [show-mtime $mtime] $hash]
		}
		puts ""
	}

	pputs colnote "Commands used to build targets and warnings"
	puts "-------------------------------------------"
	# Commands
	foreach i [lsort [dict keys $tmakecache(cmd)]] {
		puts $i:
		foreach do [dict get $tmakecache(cmd) $i] {
			show-rule-commands $do
		}
		if {[dict exists $tmakecache(warnings) $i]} {
			set warnings [dict get $tmakecache(warnings) $i]
			if {[llength $warnings]} {
				foreach msg $warnings {
					pputs colrunwarn $msg
				}
			}
		}
		puts ""
	}
}

proc show-all-targets {detailed} {
	set shown 0
	foreach i [lsort [dict keys $::tmake(targets)]] {
		if {$detailed eq ""} {
			if {![dict get [get-target-rule $i] phony]} {
				incr shown
				puts $i
			}
		} else {
			puts "$i @[make-source-location $i]"
		}
	}
	if {$shown == 0 && $detailed eq ""} {
		puts "Note: All targets are phony. Use --targets=all to show all targets"
	}
}

proc show-matching-commands {pattern} {
	global tmake

	if {$pattern eq "*"} {
		foreach info $tmake(commands-overview) {
			lassign $info loc helptext
			set lines [split [string trim $helptext] \n]
			set lines [string trim [join $lines \n]]
			pputs $lines
			pputs [string repeat - 60]
		}
	}

	set commands $tmake(commands)
	set cmds [dict keys $commands $pattern]
	if {[llength $cmds] == 0} {
		pputs colnote "No commands matched $pattern, showing commands matching ${pattern}*"
		set cmds [dict keys $commands ${pattern}*]
	}
	foreach cmd [lsort $cmds] {
		lassign $commands($cmd) loc helptext
		if {[string match *\t* $helptext]} {
			set helptext [string map [list \t <tab>] $helptext]
			pputs colnote "Warning: help text for rule $cmd contains tabs"
		}
		set otherlines [lassign [split [string trim $helptext] \n] firstline]
		set otherlines [string trim [join $otherlines \n]]
		regexp {^([^ ]*) +(.*)$} $firstline -> cmdname cmdargs
		pputs "\n[colout colrulename $cmdname] [colout colruleargs $cmdargs]"
		pputs \n$otherlines
		#puts [string repeat - 60]
	}
}

proc show-find-results {findtarget findall} {
	global tmake
	if {!$findall} {
		# Prefer a local exact match
		foreach try [list [file-join $tmake(subdir) $findtarget] $findtarget] {
			if {[is-target? $try]} {
				dputs r "find: Found exact match for $try"
				show-rule $try
				# Are there any non-exact matches?
				set count 0
				foreach target [dict keys $tmake(targets)] {
					if {[string match *$findtarget* $target]} {
						incr count
					}
				}
				if {$count > 1} {
					incr count -1
					pputs colnote "Note: $count non-exact matches also exist, use --findall to show them"
				}
				tmake-exit 0
			}
		}
	}
	dputs r "find: Showing all targets that match *$findtarget*"
	foreach target [lsort [dict keys $tmake(targets)]] {
		if {[string match *$findtarget* $target]} {
			show-rule $target
			pputs ""
		}
	}
}

proc num-nonphony-targets {} {
	set n 0
	foreach i [dict keys $::tmake(targets)] {
		if {![dict get [get-target-rule $i] phony]} {
			incr n
		}
	}
	return $n
}

# ==================================================================
# Variable Handling
# ==================================================================

# Internal implementation of define-related commands
proc define-var {name value src addsrc force} {
	global tmake
	if {[dict exists $tmake(fixedvars) $name] && !$force} {
		dputs v "define $name => not overwriting fixed value"
		return
	}
	# Normally we try to take source info from the value, but if there is none,
	# use source info from the name
	if {$src eq "" || [lindex $src 0] eq ""} {
		set src [info source $name]
	}
	if {!$addsrc} {
		dict set tmake(varloc) $name {}
	}
	dict set tmake(varloc) $name $src 1
	dict set tmake(defines) $name $value
	# Ensure that the value is visibile the current spec file
	uplevel #1 [list set $name $value]
}

# Internal command. If $list is empty, returns 1 (e.g. for "define ABC")
# otherwise returns the joined list, but preserving source information.
proc define-get-value {list} {
	if {[llength $list]} {
		set src [info source [lindex $list 0]]
		set value [join $list]
		list $value $src
	} else {
		list 1 ""
	}
}

# @define name arg ...
#
# Set a variable to the given value, unless it was defined with define!
#
# e.g. define CC arm-linux-gcc -mbig-endian
#
proc define {name args} {
	set valueinfo [define-get-value $args]
	define-var $name {*}$valueinfo 0 0
	dputs v "define $name [join $args]"
}

# @define! name arg ...
#
# Like 'define', but marks the variable as fixed. It won't be overwritten by 'define'.
# Should be reserved for variables set directly by the user from the commandline,
# possibly indirectly
proc define! {name args} {
	dict set ::tmake(fixedvars) $name 1
	set valueinfo [define-get-value $args]
	define-var $name {*}$valueinfo 0 1
	dputs v "define! $name [join $args]"
}

# @define? name arg ...
#
# Like 'define', but only sets the variable if it is undefined
# or set to an empty value.
#
proc define? {name args} {
	if {[get-define $name] eq ""} {
		set valueinfo [define-get-value $args]
		define-var $name {*}$valueinfo 0 0
	}
	dputs v "define? $name [join $args]"
}

# @define-append name arg ...
#
# If the variable is not set, set it.
# Otherwise append the new value to the old value
# separated by a space.
#
proc define-append {name args} {
	lassign [define-get-value $args] newvalue src
	set value [get-define $name]
	if {$value eq ""} {
		set appendsrc 0
	} else {
		set appendsrc 1
	}
	append-with-space value $newvalue
	define-var $name $value $src $appendsrc 0
	dputs v "define-append $name [join $args]"
}
# @define-list-append value ...
#
# Like define-append, but the variable is treated as a Tcl list
# and duplicate values are not appended.
#
# This may not be suitable for command lines, e.g. -I abc -I def
# where the -I would be omitted
#
proc define-list-append {name args} {
	lassign [define-get-value $args] newvalue src
	set value [get-define $name]
	if {$value eq ""} {
		set appendsrc 0
	} else {
		set appendsrc 1
	}
	# Avoid duplicates
	foreach arg $args {
		if {$arg ni $value} {
			append-with-space value $arg
		}
	}
	define-var $name $value $src $appendsrc 0
	dputs v "$name += [join $args] => $value"
}

# @get-define name ?default?
#
# Returns the current value of the given defined variable, or $default
# if not set. If not specified, $default is ""
#
proc get-define {name {default ""}} {
	if {$::tmake(parsedone)} {
		build-fatal-error "get-define $name called during build phase"
	}
	if {[dict exists $::tmake(defines) $name]} {
		#dputs v "get-define $name => [dict get $::tmake(defines) $name]"
		dict get $::tmake(defines) $name
	} else {
		#dputs v "get-define $name => default ($default)"
		return $default
	}
}

proc get-all-defines {} {
	return $::tmake(defines)
}

# Returns a list of all the locations that contributed
# to the definition of the given define.
# Each element of the list is of the form path:line
# Returns an empty list of no source information is available
proc get-define-locs {name} {
	set locs {}
	if {[dict exists $::tmake(varloc) $name]} {
		foreach loc [dict keys [dict get $::tmake(varloc) $name]] {
			if {[lindex $loc 0] ne ""} {
				lappend locs [join $loc :]
			}
		}
	}
	lsort $locs
}

proc show-all-defines {what} {
	set d [get-all-defines]
	foreach k [lsort [dict keys $d]] {
		set val [dict get $d $k]
		if {$what == 2} {
			puts -nonewline [colout colnote $k=$val]
			set locs [get-define-locs $k]
			if {[llength $locs]} {
				puts -nonewline " [join $locs ", "]"
			}
			puts ""
		} else {
			puts "$k=$val"
		}
	}
}

proc show-all-aliases {} {
	set d $::tmake(aliases)
	foreach k [lsort [dict keys $d]] {
		puts "$k=[dict get $d $k]"
	}
}

proc define-exists {name} {
	dict exists $::tmake(defines) $name
}


# ==================================================================
# Rule Handling
# ==================================================================

# If $target is an alias, return the aliased target
# Otherwise return $target
proc map-alias {target} {
	if {[dict exists $::tmake(aliases) $target]} {
		set target [dict get $::tmake(aliases) $target]
	}
	return $target
}

# Returns 1 if the target is an individual target
proc is-target? {target} {
	dict exists $::tmake(targets) [map-alias $target]
}

# Returns 1 if the target is a rule target
proc is-rule? {ruletarget} {
	dict exists $::tmake(rules) $ruletarget
}

# Converts a target to the rule target
proc get-rule-target {target} {
	dict get $::tmake(targets) [map-alias $target]
}

# Returns the rule for an individual target
proc get-target-rule {target} {
	dict get $::tmake(rules) [dict get $::tmake(targets) [map-alias $target]]
}

# Returns the rule for a rule target
proc get-rule {ruletarget} {
	dict get $::tmake(rules) $ruletarget
}

# Returns the single attribute for the given rule target
proc get-rule-attr {ruletarget attr} {
	dict get $::tmake(rules) $ruletarget $attr
}

# Like get-rule, but temporarily zaps the current rule.
# Makes it faster when updating the rule
proc take-rule {ruletarget} {
	set rule [dict get $::tmake(rules) $ruletarget]
	dict set ::tmake(rules) $ruletarget {}
	return $rule
}

proc update-rule {ruledict} {
	set ruletarget [dict get $ruledict target]
	if {![is-rule? $ruletarget]} {
		# Haven't seen this rule before so individual target pointers
		foreach t $ruletarget {
			if {[dict exists $::tmake(targets) $t]} {
				parse-error "Rule for $t was already specified [make-source-location $t @]"
			}
			dict set ::tmake(targets) $t $ruletarget
		}
		set-rule-status $ruletarget unknown
	}
	set alias [dict get $ruledict alias]
	if {$alias ne ""} {
		dict set ::tmake(aliases) $alias [lindex $ruletarget 0]
	}

	dict set ::tmake(rules) $ruletarget $ruledict
}

proc set-rule-status {ruletarget status} {
	dict set ::tmake(rulestatus) $ruletarget $status
}

proc get-rule-status {ruletarget} {
	dict get $::tmake(rulestatus) $ruletarget
}

proc show-this-rule {args} {
	if {[debug-is-set p]} {
		global tmake
		set extra ""
		set where "[find-source-location] "
		if {$where eq "unknown "} {
			set where ""
		}
		# We wan't to include any default options
		set ruleargs [lassign [info level -1] rule]
		if {[dict exists $tmake(ruledefaultopts) $rule]} {
			set ruleargs [list \[[dict get $tmake(ruledefaultopts) $rule]\] {*}$ruleargs]
		}
		lappend ruleargs {*}$args
		dputs p "$where$rule [join $ruleargs]" 0
	}
}

proc make-source-location {ruletarget {prefix {}} {suffix {}}} {
	if {[is-rule? $ruletarget]} {
		set source [get-rule-attr $ruletarget source]
	} else {
		set source [dict get [get-target-rule $ruletarget] source]
	}

	if {$source eq "unknown"} {
		return ""
	}
	return $prefix[join $source ", "]$suffix
}

# Defines a high level command.
proc rule {cmdname arglist {helptext {}} body} {
	global tmake
	if {[dict exists $tmake(commands) $cmdname]} {
		lassign [dict get $tmake(commands) $cmdname] loc help
		parse-error "Command $cmdname already defined @$loc"
	}
	if {$helptext eq ""} {
		user-notice colrulename "[join [info source $cmdname] :]:Warning: rule $cmdname has no help"
	}
	dict set tmake(commands) $cmdname [list [info source $cmdname] $helptext]
	proc $cmdname $arglist $body
}

# Should be called as the very first command in a rule that supports default option setting.
# Prepends any options given with set-default-opts
#
#
proc add-default-opts {&arglist} {
	global tmake
	set rule [lindex [info level -1] 0]
	if {[dict exists $tmake(ruledefaultopts) $rule]} {
		# Prepend any default options to the arglist
		set arglist [list {*}[dict get $tmake(ruledefaultopts) $rule] {*}$arglist]
	}
}

# Sets default options, to be prepended to the given rule
proc set-default-opts {rule options} {
	dict set ::tmake(ruledefaultopts) $rule $options
}

proc rule-overview {text} {
	global tmake
	lappend tmake(commands-overview) [list [info source $text] $text]
}

proc add-deferred-action {action} {
	global tmake
	lappend tmake(deferred) $action
}

# Returns flag, string or none
proc target-option-type {opt} {
	if {[dict exists $::tmake(emptytarget) $opt]} {
		if {[dict get $::tmake(emptytarget) $opt] eq "0"} {
			return flag
		}
		return string
	}
	return none
}

# Create a target dependency
#
# Parses the arguments and adds them to the rule base
#
proc target {ruletarget args} {
	global tmake
	# If the rule aready exists, we are updating
	if {[is-rule? $ruletarget]} {
		# Use take-rule here for efficiency
		set orig [take-rule $ruletarget]
	} elseif {[is-target? $ruletarget]} {
		# Can't update a rule via the invidual target
		set source [dict get [get-target-rule $ruletarget] source]
		parse-error "A multiple-target rule for $ruletarget was already specified at $source"
	}

	set info [parse-rule $ruletarget $args]

	#dputs p "target $ruletarget @ $info(source)"

	#show-this-rule

	# And -inputs are also -depends
	set info(depends) [concat $info(depends) $info(inputs)]

	# Cache the prefix with the rule, also
	set info(local) [local-dir]

	if {![info exists orig]} {
		# Now create/update the rule
		update-rule $info
		return $ruletarget
	} else {
		set identical 1
		foreach i [dict keys $tmake(emptytarget)] {
			# XXX: Are there some fields we should not compare?
			if {$info($i) ne $orig($i)} {
				set identical 0
				break
			}
		}
		if {$identical} {
			parse-warning "$ruletarget duplicate rule ignored at  $orig(source)"
			update-rule $orig
			return $ruletarget
		}
	}

	# There is already a rule for this target, so attempt
	# to merge the two rules
	# Note: We generally want the new values to come after the existing values, so
	# merge the new data into orig

	if {[llength $info(do)] && [llength $orig(do)]} {
		#parse-error "$ruletarget already has '-do' at $orig(source)"
		if {$info(do) ne $orig(do)} {
			parse-warning "$ruletarget already has '-do' at $orig(source)"
		}
		set info(do) {}
	}
	if {$info(dyndep) ne "" && $orig(dyndep) ne ""} {
		if {$info(dyndep) eq $orig(dyndep)} {
			set info(dyndep) ""
		} else {
			parse-error "$ruletarget already has '-dyndep' at $orig(source)"
		}
	}
	lappend orig(depends) {*}$info(depends)
	lappend orig(inputs) {*}$info(inputs)
	foreach i [dict keys $tmake(emptytarget)] {
		if {[target-option-type $i] eq "flag"} {
			incr orig($i) $info($i)
		}
	}
	append-with-space orig(onerror) $info(onerror) \n
	append-with-space orig(finally) $info(finally) \n
	# Only one of these will be non-blank
	lappend orig(do) {*}$info(add-do)
	append-with-space orig(dyndep) $info(dyndep) \n

	if {$info(source) eq "unknown" || $info(source) in $orig(source)} {
		# Nothing to do
	} elseif {$info(source) ne "unknown"} {
		lappend orig(source) $info(source)
	}

	# Need to append to any vars which exist
	set orig(vars) [merge-vars $orig(vars) $info(vars)]

	# Whichever rule has '-do' also specifies '-inputs' and '-msg'
	if {[llength $orig(do)] == 0} {
		set orig(do) $info(do)
		set orig(inputs) $info(inputs)
		set orig(msg) $info(msg)
	}
	update-rule $orig

	# Return the rule target for composability
	return $ruletarget
}

# Adds the list elements to the target-specific variable.
#
# This a much faster equivalent of:
#
#     target $ruletarget -vars $varname {*}$list
#
proc target-add-var {ruletarget varname list} {
	# The rule must already exist
	if {![is-rule? $ruletarget]} {
		parse-error "$ruletarget is not a rule target"
	}
	# Note that if we do this blindly, we will duplicate the dict
	# Instead, get the current value. Replace it.
	# lappend.
	# Update it
	set vars [dict get $::tmake(rules) $ruletarget vars $varname]
	dict set ::tmake(rules) $ruletarget vars $varname {}
	lappend vars {*}$list
	dict set ::tmake(rules) $ruletarget vars $varname $vars
}

proc parse-rule-args {arglist} {
	set info {}

	set opt {}
	set skip 1
	set n 0
	foreach arg $arglist {
		if {($n % $skip == 0) && [string match -* $arg]} {
			# Remove the leading dash
			set opt [string range $arg 1 end]
			if {![exists info($opt)]} {
				set info($opt) {}
			}
			set n 0
			set skip 1
			if {$opt eq "vars"} {
				set skip 2
			}
			continue
		}
		if {$opt eq ""} {
			parse-error "Missing option: $arglist"
		}
		lappend info($opt) $arg
		incr n
	}
	return $info
}

# Returns a dictionary (list) representing the parsed target rule
#
proc parse-rule {target arglist} {
	global tmake
	set info $tmake(emptytarget)

	# Note that we prefer build.spec over project.spec and rulebase.spec when
	# finding the source of a rule
	foreach pattern {build.spec *.spec *.default} {
		set info(source) [find-source-location $pattern]
		if {$info(source) ne "unknown"} {
			break
		}
	}
	set info(target) $target

	# split the arglist into a dictionary
	set arginfo [parse-rule-args $arglist]

	# And check/post-process the options
	set add 0
	foreach {opt optargs} $arginfo {
		# Special -add option
		if {$opt eq "add"} {
			incr add
			continue
		}
		set type [target-option-type $opt]

		if {$type eq "none"} {
			parse-error "Rule for $target has unknown option: -$opt"
		}
		if {$type eq "flag"} {
			if {[llength $optargs]} {
				parse-error "Rule for $target has non-option parameters after -$opt: $optargs"
			}
			set info($opt) 1
			continue
		}
		switch -exact -- $opt {
			inputs - depends {
				set info($opt) [join $optargs]
			}
			msg {
				# last one wins
				set info($opt) [lindex $optargs end]
			}
			do - dyndep - onerror - finally - alias {
				if {[llength $optargs] > 1} {
					parse-error "Rule for $target has more than one '-$opt' parameter"
				}
				if {$opt eq "do"} {
					set info($opt) $optargs
				} else {
					set info($opt) [lindex $optargs 0]
				}
			}
			vars {
				if {[llength $optargs] % 2} {
					parse-error "Rule for $target has an odd number of parameters to '-vars'"
				}
				# Need to use lappend here so that they are combined with getvars
				lappend info($opt) {*}$optargs
			}
			getvars {
				foreach v $optargs {
					if {![define-exists $v]} {
						parse-error "Rule for $target has -getvars for non-existent variable: $v"
					}
					lappend info(vars) $v [get-define $v]
				}
			}
		}
	}

	if {$add} {
		if {![llength $info(do)]} {
			parse-error "Rule for $target has '-add' but no '-do'"
		}
		# Transfer -do to add-do
		set info(add-do) $info(do)
		set info(do) {}
	} else {
		set info(add-do) {}
	}

	if {[llength $info(do)] == 0 && [llength $info(inputs)]} {
		parse-error "Rule for $target has '-inputs' but no '-do'"
	}
	if {[llength $info(do)] == 0 && $info(msg) ne ""} {
		parse-error "Rule for $target has '-msg' but no '-do'"
	}

	return $info
}

# ==================================================================
# Dependency Engine
# ==================================================================

# Returns the "hash" of the given file, that must exist.
#
# If hashing is disabled, simply returns file-mtime
#
# If hashing is enabled, first checks file-mtime, and if
# there is a srchash entry in the cache that matches, return the hash
# from the cache. Otherwise calculate the hash, store it in the
# cache and return it.
#
proc get-file-hash {file} {
	set mtime [file-mtime $file]
	if {!$::tmake(usehashes)} {
		return $mtime
	}

	global tmakecache tmake

	# Does it exists in the source hash cache with the same mtime?
	if {[dict exists $tmakecache srchash $file]} {
		lassign [dict get $tmakecache srchash $file] cachedmtime cachedhash
		if {$mtime == $cachedmtime} {
			return $cachedhash
		}
	}

	# Not in the source hash cache, or mtime has changed, so recalculate
	lassign [time {
		set hash md5:[md5sum $file]
	}] us
	incr tmake(hashtime) $us
	dputs h "md5sum $file => $hash"
	dict set tmakecache srchash $file [list $mtime $hash]
	mark-cache-dirty "source hash updated"

	return $hash
}

# The file may be a source, target symlink, target with -hash set
# or regular target
# Calculates the file hash as follows:
# source               - get-file-hash $file
# target is symlink    - link:[readlink [file-build $file]]
# target with -hash    - get-file-hash of [file-build $file]
# target               - file-mtime of [file-build $file]
#
proc calc-file-hash {file} {
	if {[is-target? $file]} {
		set realfile [file-build [map-alias $file]]
		set type [file-type $realfile]
		if {$type eq "link"} {
			# symlinks aways hash to the link contents
			return link:[file readlink $realfile]
		}
		if {[dict get [get-target-rule $file] hash]} {
			return [get-file-hash $realfile]
		} elseif {$::tmake(norun) && $type eq "none"} {
			return 0
		} else {
			return [file-mtime $realfile]
		}
	}

	# Otherwise it is source, so use the source hash (possibly from cache)
	return [get-file-hash $file]
}

# Calculates the hash of each file in the list
# (in sorted order) and returns the list
proc calc-deplist-hash {list} {
	set calchashlist {}
	foreach dep [lsort $list] {
		lappend calchashlist $dep [calc-file-hash $dep]
	}
	return $calchashlist
}


# Both $targets and $depends are lists of files which must exist
# Calculate the hash of all files in $depends
# If this matches the saved hash, 0 is returned.
# Otherwise:
# - save/update the calculated hash in dephash
# - append the details of the mismatch to 'reason' 
# - the ruletarget is out of date so 1 is returned.
#
proc needbuild? {ruletarget depends &reason} {
	global tmake tmakecache
	if {![dict exists $tmakecache dephash $ruletarget]} {
		set savedhash {}
	} else {
		set savedhash [dict get $tmakecache dephash $ruletarget]
	}
	set calchash [calc-deplist-hash $depends]
	if {$calchash eq $savedhash} {
		dputs n "Deps for $ruletarget are unchanged, not building"
		return 0
	}
	if {$savedhash eq ""} {
		dputs b "No saved hash for $ruletarget"
		lappend reason no-hash
	} else {
		dputs b "Deps for $ruletarget have changed, so rebuild"
		dputs B "old hash: $savedhash"
		dputs B "new hash: $calchash"
		# Give a meaninful reason
		if {[debug-is-set g]} {
			foreach {sfile shash} $savedhash {cfile chash} $calchash {
				if {$sfile ne $cfile} {
					lappend reason newdeps
					break
				} elseif {$shash ne $chash} {
					lappend reason changed $sfile
					break
				}
			}
		} else {
			lappend reason changed
		}
	}
	# Save the newly calculated hash
	dict set tmakecache dephash $ruletarget $calchash
	mark-cache-dirty "target hash updated"
	return 1
}

proc locate-files {files} {
	set result {}
	foreach f $files {
		if {[is-target? $f]} {
			#puts "$f is a target => [file-build $f]"
			# If the target is a full path, keep it
			lappend result [file-build $f]
		} else {
			#puts "$f is not a target"
			lappend result $f
		}
	}
	#puts "locate-files $files => $result"
	return $result
}

# Returns a dictionary with the bound and rule-specific variables
proc make-var-dict {info} {
	set vardict [dict get $info vars]
	dict set vardict target [file-build-list [dict get $info target]]
	dict set vardict targetname [dict get $info target]
	dict set vardict local [dict get $info local]
	dict set vardict build [file-build [dict get $info local]]
	dict set vardict depends [locate-files [dict get $info depends]]
	dict set vardict inputs [locate-files [dict get $info inputs]]
	#parray vardict
	return $vardict
}

proc add-warning-msg {msg} {
	lappend ::tmake(warningmsgs) $msg
}

proc note {type args} {
	if {$::tmake(verbose) != 1} {
		pputs "    [pad $type 12] [join $args]"
	}
}

# @tmake-require-version <version-needed>
#
# Checks the current version of tmake against that required.
# A fatal error is generated if the current version is less than that needed.
#
proc tmake-require-version {needversion} {
	use util

	global tmake
	set haveversion [lindex $tmake(version) 0]
	if {[compare-versions $haveversion $needversion] < 0} {
		build-fatal-error "tmake $needversion required, but this is $tmake(version)"
	}
}

proc fork-job-if-required {} {
	global tmake

	if {$tmake(maxjobs) > 1 && $tmake(sync) == 0 && $tmake(jobpid) == -1} {
		wait-for-job-slots
		set pid [add-new-job $tmake(currentruletarget) $tmake(currentnotifytarget) $tmake(chdir)]
		set tmake(jobpid) $pid
	}
	return $tmake(jobpid)
}

# Searches for the command '$cmd' in the path and returns a string that combines:
# - fullpath (or - if not found)
# - mtime
# - size
# Thus is the external command changes, the returned key will change.
proc stat-cmd-in-path {cmd} {
	# Dummy stat
	set stat {mtime 0 size 0 cmdpath -}
	# At this point, before forking, determine if we need to cache the external
	# command as a dependency
	foreach path [split-path] {
		set cmdpath [file join $path $cmd]
		if {[file-isexec $cmdpath]} {
			# Found in the path
			file stat $cmdpath stat
			set stat(cmdpath) $cmdpath
			break
		}
	}
	return $stat(cmdpath),$stat(mtime),$stat(size)
}

proc run {args} {
	global tmake tmakecache

	set cmdline [join $args]
	set cmd [lindex $cmdline 0]
	#puts "run: do we need to convert $cmd to a path from [pwd]?"
	# Is cmd a file in the current dir?
	if {![string match */* $cmd] && [file isfile $cmd]} {
		set cmdline ./$cmdline
	} elseif {$tmake(checkexternalcmds)} {
		# Update the cache with the details of this command
		dict set tmakecache exec $tmake(currentruletarget) $cmd [stat-cmd-in-path $cmd]
	}

	vputs [string trim $cmdline]

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		add-warning-msg $msg
		pputs colrunwarn $msg
	}
	if {$rc} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		if {$msg ne ""} {
			build-error "$msg\n"
		}
		return -code break
	}
	# XXX: What to do on signal?
}

proc run-tmake {args} {
	global tmake

	if {[fork-job-if-required] > 0} {
		# can't just [return] here since we need to ensure that the rest of
		# the -do doesn't run in the parent, but only in the child
		return -code break
	}

	set cmdline [list tmake {*}$tmake(cli-options) {*}$args]

	dputs m $cmdline
	set rc [catch {
		exec-save-stderr {*}$cmdline
	} msg opts]
	if {$rc == 0 && $msg ne ""} {
		pputs colrunwarn $msg
	}
	if {$rc == 1} {
		pputs \n\t$cmdline\n
		# On error, display the command and the error and return break
		build-error "$msg\n"
		return -code break
	}
}

proc calc-dyndeps {vardict target} {
	set t [get-rule $target]
	#puts "=============="
	#parray t

	set dyndeps {}
	if {$t(dyndep) ne ""} {
		# Note that we only look at $inputs when scanning for dyndeps, not $depends
		# XXX: Is this correct?
		foreach i $t(inputs) {
			lassign [run-do $vardict [concat $t(dyndep) $i]] rc result opts
			if {$rc == 0} {
				lappend dyndeps {*}$result
			} else {
				return -code $rc {*}$opts $result
			}
		}
		dputs-d "Dynamic dependencies for $target: $dyndeps"
	}
	return $dyndeps
}

proc file-mtime-if-exists {file {symlink 0}} {
	#puts -nonewline "file-mtime-if-exists $file $symlink => "
	if {$symlink} {
		if {[catch {file readlink $file}]} {
			#puts "0 (not a symlink)"
			return 0
		}
		#puts "[file-lmtime $file]"
		return [file-lmtime $file]
	}
	if {[file exists $file]} {
		#puts "[file-mtime $file]"
		return [file-mtime $file]
	}
	#puts "0 (noexist)"
	return 0
}

proc file-exists-all {list missingname} {
	upvar $missingname missing
	foreach f $list {
		if {[is-target? $f]} {
			set symlink [dict get [get-target-rule $f] symlink]
			set mtime [file-mtime-if-exists [file-build $f] $symlink]
		} else {
			set mtime [file-mtime-if-exists $f]
		}
		if {$mtime == 0} {
			set missing $f
			return 0
		}
	}
	return 1
}

# Run variable [subst] on the given '-do' scripts (a list of -do commabds)
# This is used to determine if the commands have changed for the target.
proc subst-do {__target __vardict __do_list} {
	# Create local vars based on $::tmake(defines) and $__vardict
	# to be used in subst
	dict with ::tmake(defines) {}
	dict with __vardict {}

	# Return a list of substituted '-do' scripts
	lmap __each_do $__do_list {
		# Force __each_do to be copied so that we don't lose source info in the original
		set __each_do [string cat $__each_do ""]
		set source [info source $__each_do]
		# Note: It is an error if the subst fails
		if {[catch {subst -nob -noc $__each_do} __result __opts]} {
			# subst failed -- most likely because a variable was referenced that didn't exist.
			tmake-exit 1 "[join $source :]:Error: $__result while building $__target"
		}
		set __result
	}
}

# Set up the defines and local vars and evaluate the script
# Returns a list of {ret msg opts stacktrace} from catch
#
proc run-do {__vardict __script} {
	if {$__script eq {}} {
		# Optimisation
		return [list 0 {} {}]
	}
	dict with ::tmake(defines) {}
	dict with __vardict {}
	set result [list [catch $__script msg opts] $msg $opts]
	#puts "run-do returned $result"
	return $result
}

proc enter-new-dir {dirname} {
	global tmake
	if {$tmake(lastchdir) ne $dirname} {
		# emulate make for vim quickerr
		pputs colenterdir "tmake: Entering directory `$dirname'"
		set tmake(lastchdir) $dirname
	}
}

proc wait-for-one-job {} {
	global tmake
	while {[dict size $tmake(running)]} {
		lassign [wait -1] status pid code
		if {$pid <= 0} {
			#user-notice colwarn "Warning: No child processes, but tmake(running) is not empty"
			break
		}
		if {[dict exists $tmake(running) $pid]} {
			set job [dict get $tmake(running) $pid]
			dict unset tmake(running) $pid

			lassign $job ruletarget notifytarget chdir outfile errfile
			dputs j "Job $pid building $ruletarget has finished with $status\($code), needed by $notifytarget"
			if {$status eq "CHILDSTATUS" && $code == 0} {
				set rc 0
			} else {
				set rc 1
			}

			# If job I/O was captured in separate files, display it now
			if {$outfile ne ""} {
				set stdmsg [readfile $outfile]
				if {$stdmsg ne ""} {
					# Remove any trailing newlines
					set stdmsg [string trimright $stdmsg \n]
					add-warning-msg $stdmsg
					enter-new-dir $chdir
					pputs colrunwarn $stdmsg
				}
				file delete $outfile
			}
			if {$errfile ne ""} {
				set errmsg [readfile $errfile]
				if {$errmsg ne ""} {
					set stdmsg [string trimright $errmsg \n]
					enter-new-dir $chdir
					if {$rc} {
						build-error $errmsg
					} else {
						pputs colerror $errmsg
					}
				}
				file delete $errfile
			}

			# Set the status, update the cache, delete any files on error, etc.
			target-post-build $ruletarget $rc

			if {$rc == 0} {
				dict incr tmake(pending) $notifytarget -1
				if {[dict get $tmake(pending) $notifytarget] == 0} {
					if {[get-rule-status $notifytarget] eq "waiting"} {
						dputs j "Status of $notifytarget changed from waiting => unknown"
						set-rule-status $notifytarget unknown
					}
				}
			} else {
				dputs j "Status of $notifytarget set to failed"
				set-rule-status $notifytarget failed

				if {$tmake(quickstop)} {
					tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
				}
			}
			return 1
		}
		dputs j "Ignoring unknown pid $pid"
	}
	dputs j "All jobs have finished"
	return 0
}

proc wait-for-job-slots {} {
	global tmake

	while {[dict size $tmake(running)] >= $tmake(maxjobs)} {
		dputs j "Waiting for a job slot to be available"
		wait-for-one-job
	}
}

proc add-new-job {ruletarget notifytarget chdir} {
	global tmake
	if {$tmake(sepjobio)} {
		# Capture job I/O to temporary files so that it doesn't interleave
		set fout [open [file tempfile] w]
		set ferr [open [file tempfile] w]
	} else {
		set fout ""
		set ferr ""
	}
	set pid [os.fork]
	if {$pid == 0} {
		# Turn off debugging in the child unless --debug is set to avoid confusion
		if {!$tmake(debug)} {
			foreach t [dict keys $tmake(debugtypes)] {
				dict set tmake(debugtypes) $t 0
			}
		}
		# And turn off colour output
		set tmake(colout) 0
		set tmake(colerr) 0
	}
	if {$pid > 0} {
		dputs j "Adding job $pid for $ruletarget"
		# Insert the job in the slot
		set-rule-status $ruletarget running
		if {$tmake(sepjobio)} {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir [$fout filename] [$ferr filename]]
			$fout close
			$ferr close
		} else {
			dict set tmake(running) $pid [list $ruletarget $notifytarget $chdir "" ""]
		}
		dict incr tmake(pending) $notifytarget
	} elseif {$tmake(sepjobio)} {
		# This is the child. Redirect stdout and stderr to temporary files.
		rename stdout ""
		rename $fout stdout
		rename stderr ""
		rename $ferr stderr
	}
	return $pid
}

# Runs [build $target] until it either fails or succeeds
proc build-sync {target} {
	while 1 {
		set status [build $target]
		if {$status in {waiting running}} {
			dputs j "Waiting for $target to complete..."
			wait-for-one-job
			continue
		}
		return $status
	}
}

proc target-post-build {ruletarget rc {msg {}} {opts {}}} {
	global tmake tmakeprecache tmakecache

	# Pick up the info from the precache

	set info $tmakeprecache($ruletarget)

	set t $info(rule)
	set target $info(target)
	set dyndeps $info(dyndeps)
	set vardict $info(vardict)

	set status built

	# These needs to be run from topsrcdir
	set savepwd [pwd]
	cd $tmake(topsrcdir)

	# Did the rule make the targets?
	if {$rc == 0 && !$t(phony) && ![is-cleaning?]} {
		foreach f $ruletarget {
			set mtime [file-mtime-if-exists [file-build $f] $t(symlink)]
			if {$mtime == 0} {
				# XXX: Should onerror run here if --quickstop is set?
				# XXX: Should the cache still be updated?
				build-error "[make-source-location $ruletarget "" ": "]Error: Rule for $target failed to build target(s) $f ([file-build $f])"
				# Use break to indicate that we have already output the message
				set rc 3
			} elseif {!$t(nocache)} {
				# Record the time that this target was created.
				# This is used exclusively to remove orphan targets
				#puts "Set cachetime of $f=[show-mtime $mtime]"
				dict set tmakecache(file) $f $mtime
				# Remember the rule which built this target
				dict set tmakecache(target) $f $ruletarget
			}
		}

		# Save the commands in the command cache and the list of dyndeps
		# and any warning messages
		dict set tmakecache(cmd) $ruletarget [subst-do $ruletarget $vardict $t(do)]
		dict set tmakecache(deps) $ruletarget [lsort $dyndeps]
		dict set tmakecache(warnings) $ruletarget $tmake(warningmsgs)
		mark-cache-dirty "Targets built"
	}

	if {$rc == 0} {
		if {!$t(phony)} {
			incr tmake(numtargets)
		}
	} else {
		# On failure, delete the target(s)
		file delete {*}[file-build-list $ruletarget]
		dputs b "build failed so deleting [file-build-list $ruletarget]"

		# It's probably not necessary to do this since we just deleted the files,
		# but it's probably better than leaving 
		dputs h "target $ruletarget failed, so resetting dephash"
		dict set tmakecache dephash $ruletarget failed
		mark-cache-dirty "dephash updated on failed build"

		# Try to run onerror
		lassign [run-do $vardict $t(onerror)] frc fmsg fopts
		if {$frc} {
			# Hmmm. Is the stack trace going to be useful if this is a background job?
			# We really want the subprocess to collect that as part of its error output
			build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		} elseif {$rc == 1} {
			if {$msg ne ""} {
				# failed background task will supply it's own error message
				build-error [error-stacktrace $msg $opts(-errorinfo)]
			}
		}
		set status failed
	}

	lassign [run-do $vardict $t(finally)] frc fmsg fopts
	if {$frc} {
		build-error [error-stacktrace $fmsg $fopts(-errorinfo)]
		set status failed
	}

	set-rule-status $ruletarget $status

	# No longer need this
	unset tmakeprecache($ruletarget)

	# Reset warnings
	set tmake(warningmsgs) {}

	cd $savepwd
}

proc build-deps {target ruletarget status depends phony &reason} {
	global tmake

	set count {
		failed 0
		waiting 0
		running 0
		built 0
		uptodate 0
	}

	foreach dep $depends {
		set ret [build $dep $ruletarget]

		if {[check-signal]} {
			tmake-exit 2 "*** Build cancelled"
		}

		incr count($ret)

		switch $ret {
			failed {
				if {$tmake(exitcode) == 0} {
					build-error "[make-source-location $ruletarget]:Error: Don't know how to build $dep: [join [lreverse $tmake(current)] { <= }]"
				}
				if {$tmake(quickstop)} {
					tmake-exit 1 "*** Error: Targets failed to build"
				}
			}
			built {
				lappend reason depend $dep
			}
		}
	}

	if {$count(running) || $count(waiting)} {
		dputs j "$target has $($count(running) + $count(waiting)) outstanding jobs - waiting"
		return waiting
	}
	if {$count(failed)} {
		dputs b "$target has failed dependencies - failed"
		return failed
	}

	if {!$phony && $tmake(norun) && $count(built)} {
		# If running tmake -n, we can't rely on the actual target to be updated
		# We need to assume that the target needs updating
		dputs b "$target has built dependencies (-n) - built"
		return built
	}

	# Note that previously we returned "built" if a dependency was "built"
	# but there is no need to do this. This allows commands to run but leave targets unchanged.

	#dputs n "$target dependencies are all uptodate - $status"
	return $status
}


# ==================================================================
# build
#
# This is the workhorse of tmake.
# If possible, it builds $target, including any required dependencies
# Returns the target status (also stored as targetstatus):
#          uptodate    if nothing to do,
#          failed      if unable to be built
#          built       if built
#          waiting     if waiting for dependencies to build
#          running     if job is running in the background
# ==================================================================

proc build {target {notifytarget {}}} {
	global tmake tmakecache
	if {![is-target? $target]} {
		# Cache the result here, mostly to avoid excess messages
		if {[dict exists $tmake(targetstatus) $target]} {
			set ret [dict get $tmake(targetstatus) $target]
		} else {
			dputs-G "build $target"
			if {[file exists $target]} {
				dputs-n "$target is not a target, but exists"
				set ret uptodate
			} else {
				dputs b "$target is not a target and does not exist"
				set ret failed
			}
			dict set tmake(targetstatus) $target $ret
		}
		return $ret
	}

	set ruletarget [get-rule-target $target]
	set oldstatus [get-rule-status $ruletarget]

	switch $oldstatus {
		running {
			dputs j "$ruletarget is still running"
			return running
		}
		uptodate {
			return uptodate
		}
		built {
			#dputs b "$target has previously been built"
			return built
		}
		checking {
			set current [list {*}$tmake(current) $target]
			build-fatal-error "[make-source-location $ruletarget]:Error: Recursive definition for [join [lreverse $current] { <= }]"
		}
		failed {
			dputs b "$target has previously failed to build"
			return failed
		}
		unknown - waiting {
			dputs-G "build $target"
		}
		default {
			error "Bad status: $oldstatus"
		}
	}

	# Set the status now to detect recursive dependencies
	set-rule-status $ruletarget checking
	set oldcurrent $tmake(current)
	lappend tmake(current) $target

	set t [get-rule $ruletarget]

	set reason {}
	if {$t(phony)} {
		dputs b "$target is phony, so rebuilding"
		lappend reason phony
		set status built
	} elseif {![file-exists-all $ruletarget missing]} {
		dputs b "$missing doesn't exist, so rebuilding"
		lappend reason noexist
		set status built
	} else {
		#dputs b "$ruletarget exists, so checking dependencies"
		set status uptodate
	}

	# Here is the plan to build $target
	# 1. Run 'build' for each static dependency
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 2. Calculate any dynamic dependencies for $target and run 'build' for each one
	#    - If 'build' returns failed and --quickstop is specified, we are done
	#    - If 'build' returns built, the target needs to be built
	# 3. If nothing was built ($result is uptodate), check each static+dynamic dependency for time
	#    - If needbuild? returns 1, the target needs to be built
	# 4. If build not forced, check substituted '-do' against any cached value
	#    - If cached commands exists and they are different, the target needs to be built
	# 5. If build not forced, check any cached 'exec' entries to see if external dependencies have changed
	#    - If so, the target needs to be built

	set vardict [make-var-dict $t]

	# 1. First build static dependencies
	set depends $t(depends)
	set status [build-deps $target $ruletarget $status $t(depends) $t(phony) reason]
	if {$status in {uptodate built}} {
		# 2. Build dynamic dependencies
		# Note: Only targets or existing files are returned by calc-dyndeps.
		set dyndeps [calc-dyndeps $vardict $ruletarget]
		lappend depends {*}$dyndeps
		set status [build-deps $target $ruletarget $status $dyndeps $t(phony) reason]
	}

	if {$status eq "uptodate" && !$t(phony) && [llength $t(do)]} {
		# If the list of dependencies has changed, the target needs to be built

		if {![dict exists $tmakecache(deps) $ruletarget]} {
			# XXX why are we checking llength $t(depends) here?
			if {[llength $t(depends)]} {
				dputs b "No previous dyndeps for $ruletarget"
				set status built
				lappend reason nocache
			}
		} elseif {[lsort $dyndeps] ne [dict get $tmakecache(deps) $ruletarget]} {
			dputs b "dyndeps for $ruletarget have changed, so forcing build"
			if {[debug-is-set d] && [debug-is-set b]} {
				set olddeps [dict get $tmakecache(deps) $ruletarget]
				puts "=== old ==="
				puts [join [lsort $olddeps] \n]
				puts "=== new ==="
				puts [join [lsort $dyndeps] \n]
				puts "-----------"
			}
			set status built
			lappend reason dyndeps
		}
	}

	if {$tmake(quickstop) && $tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}

	if {$status eq "uptodate" && ([llength $depends] || $tmake(usehashes))} {
		# 3.  Target exists but no dependencies were built so check time/hash dependencies
		#     Note that we can't do this mtime check with no dependencies, but we can do a hash check
		if {[needbuild? $ruletarget $depends reason]} {
			set status built
		}
	} elseif {!$t(phony) && $status in {built uptodate}} {
		# If a target is determined to be uptodate or built without
		# checking dependencies, it won't have it's hash updated in the cache.
		# So do it now. Could wait until it has succeeded, but that could be
		# some time away if the job is run in the background
		set calchash [calc-deplist-hash $depends]
		dputs h "updating hash for $ruletarget (status=$status): $calchash"
		dict set tmakecache dephash $ruletarget $calchash
		mark-cache-dirty "target hash updated"
	}

	# If this target belongs to a different rule than previously...
	if {$status eq "uptodate" && [llength $t(do)] && [dict exists $tmakecache(target) $target]} {
		if {$ruletarget ne [dict get $tmakecache(target) $target]} {
			dputs b "Target $target is built by a different rule"
			dputs B "Was [dict get $tmakecache(target) $target] but is now $ruletarget"
			lappend reason newrule
			set status built
		}
	}

	# This is done now so that (e.g.) vardicts(inputs) is consistent between the build commands
	# check and the build step
	if {$t(chdir)} {
		# Note that -chdir uses the *first* target to determine the directory
		set tmake(chdir) [file-normalize [file-build [file dirname [lindex $ruletarget 0]]]]
		# And we want $inputs, $depends and $target to refer to filenames relative
		# to tmake(chdir), so update these variables to take the chdir into account
		foreach var {inputs depends target} {
			set vardict($var) [lmap p $vardict($var) {
				relative-path [file-join $tmake(topsrcdir) $p] $tmake(chdir)
			}]
		}
	} else {
		set tmake(chdir) $tmake(topsrcdir)
	}

	# 4. Compare previous '-do' commands with current commands
	if {$status eq "uptodate" && [llength $t(do)]} {
		if {![dict exists $tmakecache(cmd) $ruletarget]} {
			# XXX: Do we need a special flag that doesn't rebuild if no dependencies?
			# For now always rebuild
			if {1 || [llength $t(depends)]} {
				dputs b "No cached commands for $ruletarget, so forcing rebuild"
				lappend reason nocache
				set status built
			}
		} else {
			set do [subst-do $ruletarget $vardict $t(do)]
			set prevdo [dict get $tmakecache(cmd) $ruletarget]
			if {$do ne $prevdo} {
				dputs {b B} "Commands for $ruletarget have changed, so forcing rebuild"
				if {[debug-is-set B]} {
					puts "=== old ==="
					foreach d $prevdo {
						show-rule-commands $d
					}
					puts "=== new ==="
					foreach d $do {
						show-rule-commands $d
					}
					puts "-----------"
				}
				lappend reason commands
				set status built
			} else {
				dputs-n "Commands for $ruletarget are unchanged"
			}
		}
	}

	# 5. Check any cached 'exec' entries to see if external dependencies have changed
	if {$status eq "uptodate" && $tmake(checkexternalcmds)} {
		if {[dict exists $tmakecache(exec) $ruletarget]} {
			set execinfo [dict get $tmakecache(exec) $ruletarget]
			foreach {exec info} $execinfo {
				set s [stat-cmd-in-path $exec]
				if {$s ne $info} {
					dputs b "External command '$exec' for $ruletarget has changed, so forcing rebuild"
					set status built
					lappend reason extcmd
					break
				}
			}
		}
	}

	if {$status eq "uptodate" && $tmake(force) && !$tmake(ignoreforce)} {
		dputs b "Rebuilding $target because of --force"
		lappend reason force
		set status built
	}

	if {$status eq "built" && [llength $t(do)]} {
		if {!$t(rootok) && $tmake(isroot)} {
			dputs b "Running command for $target as root"
			dputs b $t(do)
			build-fatal-error "Error: [make-source-location $ruletarget] Refusing to run command for $target as root"
			set status failed
		}
	}

	if {$status eq "built" && [llength $t(do)]} {
		dputs g "[join $tmake(current) { --> }] ($reason)" 0

		set tmake(sync) 1

		dputs b "Building [join [lreverse $tmake(current)] { <= }] [make-source-location $ruletarget "with rule @"]"
		lassign [run-do $vardict $t(msg)] rc msg opts
		if {$rc != 0} {
			build-error [error-stacktrace $msg $opts(-errorinfo)]
		}

		if {[debug-is-set r]} {
			dputs r "Rule for $ruletarget"
			show-rule $ruletarget
		}

		if {$tmake(norun)} {
			if {$tmake(norun) == 1} {
				foreach do [subst-do $ruletarget $vardict $t(do)] {
					show-rule-commands $do
				}
			}
			set rc 0
		} else {
			if {$notifytarget eq ""} {
				set tmake(sync) 1
				if {$tmake(maxjobs) > 1} {
					dputs j "$ruletarget: notifytarget is empty, so building synchronously"
				}
			} else {
				set tmake(sync) 0
			}

			# Create all the target directories as required
			set dirlist {}
			foreach i $ruletarget {
				set targetdir [file-build [file dirname $i]]
				if {![file isdir $targetdir]} {
					lappend dirlist $targetdir
				}
			}
			if {[llength $dirlist]} {
				dputs m "mkdir [join $dirlist]"
				if {$t(rootok) || !$tmake(isroot)} {
					file mkdir {*}$dirlist
				}
			}

			enter-new-dir $tmake(chdir)

			# If necessary, chdir now
			if {$t(chdir)} {
				dputs m "cd $tmake(chdir)"
				cd $tmake(chdir)
			}

			# Stash info for this rule that can be used in target-post-build either
			# immediately, or when the background job finishes
			global tmakeprecache

			set tmakeprecache($ruletarget) [dict create rule $t target $target dyndeps $dyndeps vardict $vardict]

			# Set these in case the job needs to be forked into the background
			set tmake(currentnotifytarget) $notifytarget
			set tmake(currentruletarget) $ruletarget
			set tmake(jobpid) -1
			set tmake(warningmsgs) {}
			incr tmake(sync) $t(nofork)

			# Check the 'slow' flag of the target to see if we should fork
			if {$t(slow)} {
				fork-job-if-required
			}
			if {$tmake(jobpid) <= 0} {
				# child process or sync, so run the jobs
				foreach do $t(do) {
					set oldenv [env-save]
					if {!$t(rootok) && $tmake(isroot)} {
						build-fatal-error "Error: [make-source-location $ruletarget] Refusing to run command for $target as root"
					} else {
						lassign [run-do $vardict $do] rc msg opts
					}
					env-restore $oldenv
					if {$tmake(jobpid) > 0} {
						# run has forked and this is the parent
						break
					}
					if {$rc} {
						if {$t(nofail) && [info return $rc] eq "error"} {
							user-notice colnote "\[ignored\] $msg"
							set rc 0
						} else {
							break
						}
					}
				}
			}

			# Always restore the current dir afterwards
			cd $tmake(topsrcdir)

			incr tmake(sync) -$t(nofork)

			if {$tmake(jobpid) > 0} {
				set status running
			} else {
				# Now the child is done
				if {[check-signal 1]} {
					# Caught a signal
					dputs j "Got signal while building $ruletarget"
					if {$tmake(jobpid) == 0} {
						exit 2
					}
					pputs ""
					tmake-exit 2 "*** Build cancelled"
				}
				if {$tmake(jobpid) == 0} {
					if {$rc} {
						dputs j "Job [pid] ($ruletarget) failed with rc=$rc, msg=$msg, opts=$opts"
						# Must output the failure here since it's the only place we have the strack trace
						dputs b "BUILD ERROR: $msg"
						if {[exists opts(-errorinfo)]} {
							puts stderr [colerr colerror [error-stacktrace $msg $opts(-errorinfo)]]
						} elseif {$msg ne ""} {
							puts stderr [colerr colerror $msg]
						}
						exit 1
					} else {
						dputs j "Job [pid] ($ruletarget) succeeded"
						exit 0
					}
				}
				if {$rc} {
					set status failed
				} else {
					set status built
				}
			}
			set tmake(sync) 1
		}

		if {!$tmake(norun)} {
			if {$status ne "running"} {
				target-post-build $ruletarget $rc $msg $opts
			}
		}

		if {($tmake(quickstop) || $t(fatal)) && $tmake(exitcode)} {
			tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
		}
	}

	if {$status eq "uptodate"} {
		# If --warnings is set, show any cached warnings
		if {$tmake(showwarnings)} {
			if {[dict exists $tmakecache(warnings) $ruletarget]} {
				set warnings [dict get $tmakecache(warnings) $ruletarget]
				if {[llength $warnings]} {
					enter-new-dir $tmake(chdir)

					# In verbose mode, the 'run' cmdline won't be shown.
					# The best we can do is output the complete cached command
					if {$tmake(verbose)} {
						foreach do [dict get $tmakecache(cmd) $ruletarget] {
							show-rule-commands $do
						}
					}
					run-do $vardict $t(msg)
					foreach msg $warnings {
						pputs colrunwarn $msg
					}
				}
			}
		}
	}

	#puts "status changed for $ruletarget from $oldstatus => $status ($reason)"
	set-rule-status $ruletarget $status

	set tmake(current) $oldcurrent
	return $status
}

# ==================================================================
# Dynamic dependencies
# ==================================================================

proc header-scan-regexp {suffix regex filename} {
	if {![file exists $filename]} {
		set filename [file-build $filename]
		if {![file exists $filename]} {
			# Might be a target which failed to build. This will be handled later
			dputs-D "header-scan-regexp $filename => <does not exist>"
			return {}
		}
	}
	set f [open $filename]
	set headers {}
	set n 0
	set d 0
	while {[gets $f buf] >= 0} {
		incr n
		if {[regexp $regex $buf -> name]} {
			append name $suffix
			lappend headers $name
		}
	}
	close $f
	dputs-D "header-scan-regexp $filename => $headers"
	return $headers
}

# Returns a list of {type path-to-filename hash}
# where type is "target" or "source"
#
# If the $path/$filename is neither a target nor source, the empty list is returned
proc find-file-on-path {filename path} {
	set f [file-join $path $filename]

	set result {}
	if {[is-target? $f]} {
		dputs-D "$f is a target, so building first"
		# Even if it fails to build, it is needed
		set status [build-sync $f]
		if {$status in {built uptodate}} {
			# with tmake -n, the file may not have actually been built
			set filepath [file-build $f]
			set result [list target $f [calc-file-hash $f]]
		} else {
			dputs-D "failed to build $f"
			if {$::tmake(quickstop)} {
				tmake-exit 1 "Error: Failed to build $f"
			} else {
				build-error "Error: Failed to build $f"
			}
		}
	} else {
		if {[file exists $f]} {
			set result [list source $f [get-file-hash $f]]
		}
	}
	#dputs-D "find-file-on-path: file=$filename, path=$path ($f) => $result"
	return $result
}

# Returns a list of {type path hash}
# where type is "target" or "source".
#
# Note that the current directory (.) is special.
# We return both the first match along $paths and any match on [file dirname $filename]
# (Unless they are the same)
#
proc find-file {filename paths} {
	#puts "find-file filename=$filename, paths=$paths"

	# First check the per-run cache
	set cachekey "$filename $paths"
	if {[dict exists $::tmake(depfindcache) $cachekey]} {
		set result [dict get $::tmake(depfindcache) $cachekey]
		#puts "find-file (cached) filename=$filename, paths=$paths => $result"
		return $result
	}

	set result {}
	set filedir [file dirname $filename]
	set seendot 0

	# Add $filedir to the end of paths if not already there
	if {$filedir ni $paths} {
		lappend paths $filedir
	}

	set result {}
	# First search the given paths
	foreach p $paths {
		set result [find-file-on-path $filename $p]
		if {[llength $result]} {
			break
		}
	}

	#puts "find-file filename=$filename, paths=$paths => $result"

	if {[llength $result] == 0} {
		dputs-D "Not a file and not a target, $filename"
	}

	# Cache this result
	dict set ::tmake(depfindcache) $cachekey $result

	#puts "=> [dict get $::tmake(depfindcache) $cachekey]"

	return $result
}

# XXX: This could be done better
#
proc header-scan-regexp-recursive {incpaths suffix regex filename} {
	global tmake tmakecache

	if {[is-target? $filename]} {
		set filepath [file-build $filename]
	} else {
		set filepath $filename
	}
	if {![file exists $filepath]} {
		dputs-D "header-scan-regexp-recursive, $filepath does not exist"
		return {}
	}
	set cachekey "$incpaths $suffix $regex $filename"

	dputs-D "Scanning $filename for headers: incpaths=$incpaths"
	# Can we get the result from the cache?
	set stamp [list [get-file-hash $filepath] $incpaths $suffix $regex]
	if {[dict exists $tmakecache(headerscan) $filename]} {
		lassign [dict get $tmakecache(headerscan) $filename] cache_stamp headers cachedresults
		if {$cache_stamp eq $stamp} {
			# Need to verify that find-file returns the same result as last time
			dputs-D "verifying up-to-date cached results for $filename"
			set ok 1
			#cachedresults=test2.in {source subdir/test2.in 1560901841973445} test4.in {source subdir/test4.in 1560899705528444}
			foreach {cname cinfo} $cachedresults {
				set finfo [find-file $cname $incpaths]
				if {$cinfo ne $finfo} {
					dputs-d "$cname has changed from {$cinfo} => {$finfo} -- rescan"
					set ok 0
					break
				}
				dputs-D "ok, $cname still resolves to {$cinfo}"
			}
			if {$ok} {
				# Can reuse the cache
				dputs-d "header-scan-regexp $filename (cached) => $headers"
				return $headers
			} else {
				dputs-d "cache is out-of-date for $filename - rescanning"
			}
		}
		# Stale
		dict unset tmakecache(headerscan) $filename
	}

	# Recursively scan files
	unset -nocomplain deps results
	set deps {}
	set results {}
	set scanned($filename) 1
	set toscan [header-scan-regexp $suffix $regex $filepath]
	while {[llength $toscan]} {
		set newscan {}
		foreach d $toscan {
			if {![info exists scanned($d)]} {
				set scanned($d) 1
				set findfiles [find-file $d $incpaths]
				set results($d) $findfiles
				foreach {type deppath hash} $findfiles {
					set deps($deppath) 1
					lappend newscan {*}[header-scan-regexp $suffix $regex $deppath]
				}
			}
		}
		set toscan $newscan
	}

	#puts "---- $filename ----"
	#parray results
	# memoize the result
	set headers [dict keys $deps]
	dict set tmakecache(headerscan) $filename [list $stamp $headers $results]
	#dputs d results=$results
	mark-cache-dirty "New header scan"
	return $headers
}

# These are overridden by the colour module
proc colout {colour string} {
	return $string
}

proc colerr {colour string} {
	return $string
}

# Embedded modules are inserted below here
set tmake(installed) 1
# ----- module argparse.tcl -----
# @synopsis:
#
# Simple command line argument parser.
# This module is always loaded.
# 

# @argparse &argv { patterns code patterns code ... }
#
# The code is evaluated if the arg matches a correponding glob pattern.
# The current argument is available as $arg.
#
# - Call [argnext argv] to get the next arg.
# - Call [argparam $arg] to extract the value from a parameter like --option=value.
#
# Leaves $argv with unconsumed args.

proc argparse {&argv spec} {
	# Make the arg available in the calling context
	upvar arg arg

	if {[exists arg]} {
		error "Variable arg already exists in calling context"
	}
	if {[llength $spec] == 1} {
		set spec [lindex $spec 0]
	}

	# Get the next arg from argv and return it
	local proc argnext {&argv} {
		# Remove an arg and return following one
		set argv [lassign $argv arg]
		return [lindex $argv 0]
	}
	# Extract the value from --option=value
	local proc argparam {arg} {
		if {[regexp {^(-+[^=]*)(=)?(.*)?} $arg -> option equals value]} {
			return $value
		}
		parse-error "Can't find parameter from $arg"
	}

	set done 0
	while {[llength $argv]} {
		set arg [lindex $argv 0]
		set matched 0
		foreach {patterns code} $spec {
			foreach pattern $patterns {
				if {[string match $pattern $arg]} {
					incr matched
					try {
						uplevel 1 $code
					} on break {} {
						incr done
					}
					break
				}
			}
			if {$matched} {
				# consume it
				argnext argv
				break
			}
		}
		# Stop once something doesn't match
		if {!$matched || $done} {
			break
		}
	}
	# argv now contains all unconsumed args
}

# ----- module colour.tcl -----
# Copyright (c) 2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved
#
# @synopsis:
#
# Provide colourised output to ANSI-compatible terminals
#
# Colourised output will not be used if:- $NOCOLOR is set in the environment,
# $TERM is one of dumb, emacs or cygwin, or if the channel (stdout, stderr)
# is not a tty.
#
# Note that tmake allows colour to be forced on with --col and forced off with --nocol
#
# Known colours are: none black red green yellow blue purple cyan normal gray grey lred
# lgreen lyellow lblue lpurple lcyan white

# Should colourised output be used to stdout and stderr?
set tmake(colout) 0
set tmake(colerr) 0

# These are the ANSI escape sequences
set tmake(ansicodes) {
	none "\x1b\[0m"
	black "\x1b\[30m"
	red "\x1b\[31m"
	green "\x1b\[32m"
	yellow "\x1b\[33m"
	blue "\x1b\[34m"
	purple "\x1b\[35m"
	cyan "\x1b\[36m"
	normal "\x1b\[37m"
	grey "\x1b\[30;1m"
	gray "\x1b\[30;1m"
	lred "\x1b\[31;1m"
	lgreen "\x1b\[32;1m"
	lyellow "\x1b\[33;1m"
	lblue "\x1b\[34;1m"
	lpurple "\x1b\[35;1m"
	lcyan "\x1b\[36;1m"
	white "\x1b\[37;1m"
}

# Colour aliases
set tmake(colalias) {}

proc init-colour {} {
	global tmake

	if {[getenv NOCOLOR ""] eq "" && [getenv TERM ""] ni {dumb emacs cygwin}} {
		set tmake(colout) [isatty? stdout]
		set tmake(colerr) [isatty? stderr]
	}
	foreach {n v} $tmake(ansicodes) {
		lappend tmake(collist) $n
	}
}

# @colstr colour string
#
# Return a value that will output $string to an ANSI terminal with the given colour (or colour alias).
proc colstr {colour string} {
	return [colget $colour]$string[colget none]
}

# @colout colour string
#
# Return a coloured message destined for stdout. The message
# will only be coloured if colour support is enabled for stdout.
proc colout {colour string} {
	if {$::tmake(colout)} {
		return [colstr $colour $string]
	}
	return $string
}

# @colerr colour string
#
# Return a coloured message destined for stderr. The message
# will only be coloured if colour support is enabled for stderr.
proc colerr {colour string} {
	if {$::tmake(colerr)} {
		return [colstr $colour $string]
	}
	return $string
}

# @colalias name colour
#
# Set or replace a name that will alias to the given colour
# Note that aliases may only refer to base colours, not other aliases.
#
proc colalias {name colour} {
	if {[dict exists $::tmake(ansicodes) $colour]} {
		dict set ::tmake(colalias) $name $colour
	} else {
		return -code error "Unknown colour, $colour, specified for alias"
	}
}

# @colget name
#
# Returns the ansi code for the given colour alias or base colour.
# The name must exist as an alias or base colour.
proc colget {name} {
	if {[dict exists $::tmake(colalias) $name]} {
		set name [dict get $::tmake(colalias) $name]
	}
	dict get $::tmake(ansicodes) $name
}

proc show-colours {} {
	global tmake
	set colmap {}
	foreach {n v} $tmake(colalias) {
		lappend colmap($v) $n
	}
	foreach col $tmake(collist) {
		if {[exists colmap($col)]} {
			set aliases $colmap($col)
		} else {
			set aliases -none-
		}
		puts "Colour [colstr $col [pad $col 7]] is used for: $aliases"
	}
	puts "\nUse [colstr yellow "colalias <alias> <colour>"] to change colour usage"
}

# ----- module compat.tcl -----
# Copyright (c) 2007-2010 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# @synopsis:
#
# Module containing misc procs useful to modules, 
# largely for platform compatibility.

if {[string equal windows $tcl_platform(platform)]} {
	proc iswin {} { return 1 }
} else {
	proc iswin {} { return 0 }
}

# @file-isexec filename
#
# Implements 'file isexec'

# @exec-save-stderr cmd ...
#
# Implements 'exec >@stdout ...' to capture and return stderr on platforms
# that don't support this natively.

if {[iswin]} {
	# mingw/windows doesn't have an executable bit so use a heuristic
	proc file-isexec {exec} {
		# Basic test for windows. We ignore .bat
		if {[file isfile $exec] || [file isfile $exec.exe]} {
			return 1
		}
		return 0
	}
	proc exec-save-stderr {args} {
		# If the command is a shell script, we need to manually implement #!/bin/sh
		# by running "sh script ..."
		set scriptargs [lassign $args script]
		if {[file exists $script]} {
			set f [open $script]
			if {[gets $f buf] > 0} {
				if {[regexp {^#!([^ ]*)(.*)$} $buf -> cmd cmdargs]} {
					set args [list [file tail $cmd] {*}$cmdargs {*}$args]
				}
			}
			close $f
		}
		exec >@stdout {*}$args
	}
	# minw32 seems to use full buffering for stderr
	stdout buffering line
	stderr buffering none
} else {
	# unix separates $PATH with colons and has and executable bit
	proc file-isexec {exec} {
		file executable $exec
	}
	proc exec-save-stderr {args} {
		exec >@stdout {*}$args
	}
}


# @split-path
#
# Returns environment variable $PATH as a list
#
proc split-path {} {
	split [getenv PATH .] $::tcl_platform(pathSeparator)
}

# @lunique list
#
# Returns a copy of $list with any duplicates removed.
# The list is returned in 'lsort' order.
#
proc lunique {list} {
	set a {}
	foreach i $list {
		set a($i) 1
	}
	lsort [dict keys $a]
}

# @isatty? channel
#
# Returns 1 if the channel is a tty. 
#
proc isatty? {channel} {
	set tty 0
	catch {
		# isatty is a recent addition to Jim Tcl
		set tty [$channel isatty]
	}
	return $tty
}

# Returns a dictionary containing the current environment
proc env-save {} {
	return $::env
}

# Sets the current environment to the given dictionary
proc env-restore {newenv} {
	set ::env $newenv
}

# @getenv name ?default?
#
# Returns the value of environment variable 'name'.
# If not set, returns 'default' if specified, otherwise generates an error.
#
# Note that on Windows, all environment variable values have backslash
# converted to forward slash automatically.
proc getenv {name args} {
	if {[info exists ::env($name)]} {
		set value $::env($name)
	} elseif {[llength $args]} {
		set value [lindex $args 0]
	} else {
		return -code error "environment variable \"$name\" does not exist"
	}
	if {[iswin]} {
		# On Windows, backslash convert all environment variables
		set value [string map {\\ /} $value]
	}
	return $value
}

# @setenv name value
#
# Sets the value of the given environment variable
#
proc setenv {name value} {
	set ::env($name) $value
}


# @file-normalize path
#
# Like 'file normalize', but follows symlinks and is supported even on 
# platforms withouth 'file normalize'
#
proc file-normalize {path} {
	if {$path eq ""} {
		return ""
	}
	while {[file exists $path] && [file type $path] eq "link"} {
		set path [file readlink $path]
	}
	if {[catch {file normalize $path} result]} {
		# If file normalize isn't support, use cd/pwd
		# This requires the path to exist
		set oldpwd [pwd]
		if {[file isdir $path]} {
			cd $path
			set result [pwd]
		} else {
			file mkdir [file dirname $path]
			cd [file dirname $path]
			set result [file join [pwd] [file tail $path]]
		}
		cd $oldpwd
	}
	return $result
}

# @file-join dir path
#
# Like 'file join' except will omit "." in either 'dir' or 'path'
# e.g.
#
## file-join . abc => abc
## file-join abc/def . => abc/def
## file-join abc/def ghi => abc/def/ghi
proc file-join {dir path} {
	if {$dir eq "."} {
		return $path
	}
	if {$path eq "."} {
		return $dir
	}
	file join $dir $path
}

# @file-link ?-symbolic|-hard? newname target
#
# Implements 'file link', but uses the external command 'ln' if
# 'file link' is not supported internally.
#
# Note that the arguments are reversed from 'ln', so creates 
# 'dest' -> 'target'
if {"link" in [file -commands]} {
	alias file-link file link
} elseif {![iswin]} {
	proc file-link {{-symbolic|-hard -hard} newname target} {
		set opt ${-symbolic|-hard}
		switch -glob -- $opt {
			-h* {
				exec ln $target $newname
			}
			-s* {
				exec ln -s $target $newname
			}
			default {
				return -code error "bad option \"$opt\": must be -hard, or -symbolic"
			}
		}
	}
}

# @file-mtime filename
#
# Return modification time of the file, using the high-res timestamp if possble.
#
# @file-lmtime linkname
#
# Return modification time of the symlink, using the high-res timestamp if possble.
#
if {"mtimeus" in [file -commands]} {
	alias file-mtime file mtimeus
	proc show-mtime {mtime} {
		set ms_str [format %03d $($mtime / 1000 % 1000)]
		set secs $($mtime / 1000000)
		return [clock format $secs -format "%H:%M:%S.$ms_str %d-%b-%Y"]
	}
	proc file-lmtime {filename} {
		dict get [file-lstat $filename] mtimeus
	}
} else {
	alias file-mtime file mtime
	proc show-mtime {mtime} {
		return [clock format $mtime -format "%H:%M:%S %d-%b-%Y"]
	}
	proc file-lmtime {filename} {
		dict get [file-lstat $filename] mtime
	}
}

# @file-lstat filename ?var?
#
# Implements 'file lstat', or 'file stat' if lstat isn't supported.
#
if {"lstat" in [file -commands]} {
	alias file-lstat file lstat
} else {
	alias file-lstat file stat
}

# Like file type but returns "none" if the file doesn't exist
# rather than throwing an error
proc file-type {file} {
	set type none
	catch {
		set type [file type $file]
	}
	return $type
}

# Implements 'wait' in terms of the older 'os.wait'
#
if {![exists -command wait]} {
	proc wait {args} {
		lassign [os.wait {*}$args] pid status rc
		switch -exact -- $status {
			error - none {
				set status NONE
			}
			exit {
				set status CHILDSTATUS
			}
			signal {
				set status CHILDKILLED
			}
			other {
				set status CHILDSUSP
			}
		}
		list $status $pid $rc
	}
}

##################################################################
#
# Directory/path handling
#

# @relative-path path ?pwd?
#
# Convert absolute path 'path' into a path relative
# to 'pwd', (or the current directory, if not given).
#
proc relative-path {path {pwd {}}} {
	if {![string match /* $path]} {
		if {![file exists $path]} {
			stderr puts "Warning: $path does not exist. May not be canonical"
		} else {
			set path [file-normalize $path]
		}
	}
	if {$pwd eq ""} {
		set pwd [pwd]
	} else {
		set pwd [file-normalize $pwd]
	}

	if {$path eq $pwd} {
		return .
	}

	set splitpath [split $path /]
	set splitpwd [split $pwd /]

	# Count the number of identical levels
	# The first level will always match
	set n 0
	foreach i $splitpath j $splitpwd {
		if {$i ne $j} {
			#puts "Not equal, so stripping $n levels"
			set splitpath [lrange $splitpath $n end]
			set splitpwd [lrange $splitpwd $n end]
			break
		}
		incr n
		continue
	}
	if {$n == 1} {
		return $path
	}
	if {[llength $splitpwd]} {
		set relpath [lrepeat [llength $splitpwd] ..]
	}
	lappend relpath {*}$splitpath

	join $relpath /
}

# If everything is working properly, the only errors which occur
# should be generated in user code (e.g. auto.def).
# By default, we only want to show the error location in user code.
# We use [info frame] to achieve this.
#
# This is designed to be called for incorrect usage, via parse-error
#
proc error-location {msg} {
	if {$::tmake(debug)} {
		tailcall error-stacktrace $msg
	}
	warning-location $msg
}

# warning-location is like error-location except
# it does not show a stack trace, even when debugging is enabled
#
proc warning-location {msg {pattern *.spec}} {
	set loc [find-source-location $pattern]
	if {$loc ne "unknown"} {
		return "$loc: $msg"
	}
	puts "warning-location: no location found"
	return $msg
}

# Look down the stack frame for the first location
# which is in a file matching the pattern and return it as file:line
# Returns "unknown" if not known.
#
proc find-source-location {{pattern *.spec}} {
	# Search back through the stack for the first location in a .spec file
	set result unknown

	for {set i 1} {$i < [info level]} {incr i} {
		lassign [info frame -$i] info(caller) info(file) info(line)
		if {[string match *.spec $info(file)]} {
			return [relative-path $info(file)]:$info(line)
		}
		# But use the last occurrence when searching in (e.g.) rulebase.default
		if {[string match $pattern $info(file)]} {
			set result $info(file):$info(line)
		}
	}
	return $result
}

# Similar to error-location, but called when user code generates an error
# In this case we want to show the stack trace in user code, but not in system code
# (unless --debug is enabled)
#
proc error-stacktrace {msg {stacktrace {}}} {
	if {$::tmake(debug)} {
		# In debug mode, prepend a live stacktrace to the error stacktrace, omitting the current level
		lappend stacktrace {*}[lrange [stacktrace] 3 end]
	}

	if {!$::tmake(debug)} {
		# Only keep levels from *.spec files or with no file
		set newstacktrace {}
		foreach {p f l} $stacktrace {
			if {![string match "*.spec" $f] || $f eq ""} {
				#puts "Skipping $p $f:$l"
				continue
			}
			lappend newstacktrace $p $f $l
		}
		set stacktrace $newstacktrace
	}

	# Convert filenames to relative paths
	set newstacktrace {}
	foreach {p f l} $stacktrace {
		if {$f ne "" && [file exists $f]} {
			set f [relative-path $f]
		}
		lappend newstacktrace $p $f $l
	}
	lassign $newstacktrace p f l
	if {$f ne ""} {
		set prefix "$f:$l: "
		set newstacktrace [lrange $newstacktrace 3 end]
	} else {
		set prefix ""
	}

	if {[llength $newstacktrace]} {
		return "${prefix}Error: $msg\n[stackdump $newstacktrace]"
	} else {
		return "${prefix}Error: $msg"
	}
}

proc check-signal {{clear 0}} {
	if {$clear} {
		set clear -clear
	} else {
		set clear ""
	}
	if {[signal check {*}$clear] ne ""} {
		return 1
	}
	return 0
}

# returns the number of cpus/cores if possible, or 1 if unknown
proc get-num-cpus {} {
	set numcpus 1
	catch {
		if {[iswin]} {
			# Actually, we always return 1 on Windows since without os.fork
			# we can't support concurrent jobs
			return 1

			# https://msdn.microsoft.com/en-us/library/aa394531(v=vs.85).aspx
			#set numcpus [lindex [exec wmic cpu get NumberOfCores] end]
		} else {
			# http://pubs.opengroup.org/onlinepubs/009604499/utilities/getconf.html
			set numcpus [exec getconf _NPROCESSORS_ONLN]
		}
	}
	return $numcpus
}

# Returns 1 if the current user is root
# On platforms with no concept of root, always returns 0
proc is-uid-root {} {
	if {[exists -command os.getids]} {
		if {[dict get [os.getids] uid] == 0} {
			return 1
		}
	}
	return 0
}

# Returns 1 if md5sum hashing is available
proc init-md5sum {} {
	foreach cmd {md5sum md5} {
		if {[catch [list exec $cmd /dev/null] result] == 0} {
			lassign $result sum
			if {$sum eq "d41d8cd98f00b204e9800998ecf8427e"} {
				# OK. Create the md5sum proc
				proc md5sum {filename} cmd {
					if {![file exists $filename]} {
						build-error "md5sum $filename does not exist"
					}
					lindex [exec $cmd $filename] 0
				}
				return 1
			}
		}
	}
	return 0
}

proc init-compat {} {

	# Do we have the signal command?
	if {![exists -command signal]} {
		proc signal {args} {
			# Return "no signal" for [signal check]
			return ""
		}
	}

	# How to eval a script and provide source info?
	# Older versions of Jim Tcl didn't support this
	if {[catch {info source {} t.tcl 1}] == 0} {
		# Have [info source]
		proc info-source {script filename line} {
			tailcall info source $script $filename $line
		}
	} else {
		proc info-source {script filename args} {
			return $script
		}
	}

	# Check SIGINT and SIGTERM with check-signal
	# SIGPIPE is caught in main
	# Only changes signals that exist and are set to default
	foreach {sig disp} {SIGINT ignore SIGTERM ignore SIGPIPE handle} {
		if {$sig in [signal default]} {
			signal $disp $sig
		}
	}
}

# ----- module config.tcl -----
# Copyright (c) 2011 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# @synopsis:
#
# Provides 'ifconfig', a mechanism for simple conditional statements based on defines.

# @is-defined? name
#
# Returns 1 if the define exists and is not set to "" or 0
proc is-defined? {name} {
	if {[get-define $name] ni {"" 0}} {
		return 1
	}
	return 0
}

# @ifconfig expr ?code? ?else-code?
#
# Evaluates the given expression, where each term is substituted with [is-defined? term].
# If 'code' is not specified and the expression is false, the rest of the file is skipped.
#
# Otherwise evaluates either 'code' or 'else-code' depending on the result of the expression.
# For example:
#
# Skip the rest of the file if 'CONFIGURED' is not defined.
## ifconfig CONFIGURED
#
# Evaluate the given code if USE_UTF8 and CONFIGURED are both defined.
## ifconfig {USE_UTF8 && CONFIGURED} {
##    ...
## }
proc ifconfig {expr args} {
	# convert the simple expression into something we can evaluate
	regsub -all {([A-Z][A-Z0-9_]*)} $expr {[is-defined? \1]} tclexpr

	dputs c "ifconfig: expr='$expr' tclexpr='$tclexpr'"

	do_ifconfig ifconfig $tclexpr $args
}

# Internal command.
# If 'code' is not specified, the entire file is skipped unless
# the expression is true.
#
proc do_ifconfig {name expr exprargs} {
	if {[llength $exprargs] == 0} {
		# bare 'ifconfig expr'
		do_if_else 3 $expr "" "return -code 20 skip"
		return
	}

	switch -exact [llength $exprargs] {
		1 {
			# ifconfig expr {code}
			do_if_else 3 $expr [lindex $exprargs 0] ""
			return
		}
		3 {
			# ifconfig expr {code} else {code}
			if {[lindex $exprargs 1] eq "else"} {
				do_if_else 3 $expr [lindex $exprargs 0] [lindex $exprargs 2]
				return
			}
		}
	}
	parse-error "ifconfig: should be $name {expr} ?{code}? ?else {code}?"
}


# Internal command to implement ifconfig
#
proc do_if_else {level expr true false} {
	if $expr {
		dputs c "Expression is true, so executing $true"
		if {$true ne ""} {
			uplevel $level $true
		}
	} else {
		dputs c "Expression is false"
		if {$false ne ""} {
			uplevel $level $false
		}
	}
}

# ----- module fileutil.tcl -----
# ==================================================================
# File Utilities
# ==================================================================

# @readfile filename ?default?
#
# Return the contents of the file.
# If the file doesn't exist or can't be read, returns $default.
# If no default is given, it is an error. 
#
proc readfile {filename args} {
	try {
		set f [open $filename]
		set result [read $f]
		close $f
	} on error {msg opts} {
		if {[llength $args] != 1} {
			return -code error $msg
		}
		lassign $args result
	}
	return $result
}

# @writefile filename value
#
# Creates the given file containing $value.
# Does not add an extra newline.
#
proc writefile {filename value} {
	file mkdir [file dirname $filename]
	set f [open $filename w]
	puts -nonewline $f $value
	close $f
}

# If $file doesn't exist, or it's contents are different than $buf,
# the file is written and 1 is returned.
# Otherwise 0 is returned.
proc write-if-changed {file buf {script {}}} {
	set old [readfile $file ""]
	if {$old ne $buf || ![file exists $file]} {
		writefile $file $buf
		return 1
	}
	return 0
}

proc copy-if-changed {source dest} {
	if {[file exists $dest] && [file size $dest] == [file size $source]} {
		write-if-changed $dest [readfile $source]
	} else {
		file copy -force $source $dest
		return 1
	}
}

# ----- module genie.tcl -----
# Copyright (c) 2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which provides auto-generation of build.spec files

# Implements tmake --genie ?--force?
#
proc tmake-genie {argv} {
	use getopt

	# Ignore any options we don't understand
	set force 0
	argparse argv {
		--force {
			incr force
		}
	}

	if {[file exists build.spec] && !$force} {
		puts "Warning: build.spec already exists - remove it first or use --force to overwrite"
		exit 1
	}

	set headers [glob -nocomplain *.h *.hpp]
	set src [glob -nocomplain *.c *.cpp *.cc *.cxx *.y *.l]

	# Categorise the sources
	set progsrc {}
	set testsrc {}
	set libsrc {}

	foreach i $src {
		if {[regexp {\<main[ \t]*\(} [readfile $i]]} {
			# Has main(), so must be executable source or test source
			if {[string match {*[tT]est*} $i]} {
				lappend testsrc $i
			} else {
				lappend progsrc $i
			}
		} else {
			lappend libsrc $i
		}
	}

	set libname [string tolower [file tail [pwd]]]

	set buildspec {}
	lappend buildspec "# This is a sample build.spec file generated by tmake --genie"
	lappend buildspec "# Edit it as required\n"
	if {[llength $headers]} {
		lappend buildspec "# Any non-private headers should be published"
		lappend buildspec "#PublishIncludes [join $headers]\n"
	}
	if {[llength $libsrc]} {
		lappend buildspec "# If this library is only used by local executables, remove --publish"
		lappend buildspec "Lib --publish $libname [join $libsrc]\n"
	}
	foreach i $progsrc {
		lappend buildspec "Executable [file rootname $i] $i"
	}
	foreach i $testsrc {
		lappend buildspec "Executable --test [file rootname $i] $i"
	}
	writefile build.spec [join $buildspec \n]\n
	puts "Created build.spec"

	if {[find-project-top] eq ""} {
		puts "Not already in a project, so creating project.spec"
		writefile project.spec {}
	}
	exit 0
}

# ----- module getopt.tcl -----
# Copyright (c) 2006 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Simple getopt module

# Implements the core of getopt
# Returns a list of {vars newargv}
# Where $vars is a list of {name value ...} corresponding to the set options
# and $newargv contains any unused args (always {} unless 'args' is given)
#
proc getopt-core {optdef argv} {
	set nargv {}
	set boolopts {}
	set stropts {}

	set vars {}

	# Parse the option definition
	set haveargs 0
	set named {}
	foreach i $optdef {
		if {[regexp {^--([^:]*)(:*)(.*)$} $i -> name colon extra]} {
			switch [string length $colon] {
				0 {
					set default 0
					if {[string match *=* $name]} {
						lassign [split $name =] name default
					}
					if {[string match *|* $name]} {
						lassign [split $name |] prefix name
						set boolopts($prefix$name) [list $name 0]
					}
					# boolopts($name) stores a list of the actual option name and the
					# value to set
					set boolopts($name) [list $name 1]
					set vars($name) $default
				}
				1 {
					set stropts($name) [list 1 $extra]
				}
				2 {
					set stropts($name) [list 2 $extra]
				}
				default {
					parse-error "Bad getopt specification: $i"
				}
			}
			continue
		}
		if {$i eq "args"} {
			incr haveargs
		} else {
			lappend named $i
		}
	}

	for {set i 0} {$i < [llength $argv]} {incr i} {
		set arg [lindex $argv $i]

		if {$arg eq "--"} {
			# End of options
			incr i
			lappend nargv {*}[lrange $argv $i end]
			break
		}

		unset -nocomplain value
		if {[regexp {^--([^=]+)=(.*)} $arg -> name value]} {
			# --abc=def
		} elseif {[regexp {^--(.*)} $arg -> name]} {
			# --abc
		} else {
			lappend nargv {*}[lrange $argv $i end]
			break
		}

		if {[exists boolopts($name)]} {
			if {[exists value]} {
				parse-error "Option --$name does not accept a parameter"
			}
			lassign $boolopts($name) optname optval
			set vars($optname) $optval
		} elseif {[exists stropts($name)]} {
			lassign $stropts($name) type extra
			if {$type == 1} {
				if {[exists value]} {
					set vars($name) $value
				} elseif {$extra ne ""} {
					set vars($name) $extra
				} else {
					parse-error "Option --$name requires a parameter"
				}
			} else {
				if {[exists value]} {
					lappend vars($name) $value
				} elseif {$extra ne ""} {
					lappend vars($name) $extra
				} else {
					parse-error "Option --$name requires a parameter"
				}
			}
		} else {
			parse-error "Unknown option: --$name"
		}
	}

	if {[llength $nargv] < [llength $named]} {
		parse-error "No value supplied for [lindex $named [llength $nargv]]"
	}
	if {!$haveargs && [llength $nargv] > [llength $named]} {
		parse-error "Too many parameters supplied"
	}

	# Assign named args
	set i 0
	foreach name $named {
		set vars($name) [lindex $nargv $i]
		incr i
	}
	# Store any leftovers in $remaining
	set remaining [lrange $nargv $i end]

	list $vars $remaining
}

# @getopt optdef &argvn
#
# optdef looks something like:
## --test --install: --no|strip --excludes:: dest source args
#
# Boolean options:
##  --test
##  --no|test
##  --test=1
##  --no|test=1
#
# Single string options:
##  --install:
##  --install:default
#
# Multi string options:
##   --exclude::
##   --exclude::default
#
# Named arguments:
##   dest
#
# Remaining arguments:
##  args
#
# Sets variables in the caller's scope with the names given in optdef, except
# any remaining args are left in the original argv
# Extra args are only valid if 'args' is given as the last option.
#
#- If --test is set, then test=1, otherwise test=0
#- If --install is specified, it is stored in $install, otherwise $install is left unset
#- If --excludes is specified (multiple times, each value is stored in the list $excludes
#- Either --strip or --nostrip can be specified as a boolean option. --strip will set strip=1, while --nostrip will set strip=0
#- If a boolean or single string option is specified multiple times, the last one wins
proc getopt {optdef &argv} {
	#puts [list getopt-test $optdef $argv]
	lassign [getopt-core $optdef $argv] vars argv
	foreach {name val} $vars {
		uplevel 1 [list set $name $val]
	}
}

# ----- module glob.tcl -----
# Copyright (c) 2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which provides local-aware file globbing

# Patterns are file patterns actual paths, typically created by make-local-src
# If $all is true, non-patterns are returned as-is
proc glob-nonrecursive {patterns all {istype isfile} {exclude {}}} {
	set result {}

	# Optimise the common case
	if {$all && ![string match {*[{}*?]*} $patterns] && $exclude eq {}} {
		return [join $patterns]
	}

	foreach pattern $patterns {
		# Use --all to ensure that non-patterns aren't silently removed
		if {$all && ![string match {*[{}*?]*} $pattern]} {
			lappend result $pattern
			continue
		}
		set globpattern $pattern
		foreach path [glob -nocomplain $globpattern] {
			if {[file $istype $path] && [file tail $path] ni $exclude} {
				lappend result $path
			}
		}
	}

	return $result
}

# Patterns are file patterns actual paths, typically created by make-local-src
proc glob-recursive {patterns type {exclude {}}} {
	set result {}

	foreach pattern $patterns {
		# Split the pattern into the directory part and the pattern part
		set dirpattern [file dirname $pattern]
		set tailpattern [file tail $pattern]

		# Find all directories which match the directory pattern
		foreach dir [glob-nonrecursive $dirpattern 0 isdir $exclude] {
			lappend result {*}[glob-recursive [file-join $dir/* $tailpattern] $type $exclude]
			lappend result {*}[glob-nonrecursive [file-join $dir $tailpattern] 0 $type $exclude]
		}
	}
	return $result
}

# @Glob ?--warn? ?--dirs? ?--all? ?--recursive? ?--exclude=filename? pattern ...
#
# Returns "local" filenames matching the given pattern(s).
# The pattern may include a path/directory pattern.
#
## --warn       produces a warning if no files matched any pattern
## --dirs       returns directories matching the given pattern(s). otherwise only files.
## --all        patterns that don't match any files are returned as-is instead of no result.
## --recursive  recurse into subdirectories
## --exclude    exclude results matching the given filename (may be specified more than once)
#
# Examples:
#
# Return all .test files:
#
## Glob *.test
#
# Return all .c files any directory below test.*, including ignore.c:
#
## Glob --recursive --exclude=ignore.c test.*/*.c
#
proc Glob {args} {
	show-this-rule

	set exclude {}
	getopt {--warn --dirs --all --recursive --exclude:: args} args

	# Any args which are already absolute paths shouldn't have make-local-src applied
	set args [join $args]

	set patterns {}
	set pwd [pwd]
	foreach pattern $args {
		if {[file join $pwd $pattern] eq $pattern} {
			parse-error "Glob $pattern is not a (source) relative path. Try \[glob\]"
		}
	}
	set patterns [make-local-src {*}$args]

	if {$dirs} {
		set type exists
	} else {
		set type isfile
	}

	if {$recursive} {
		set paths [glob-recursive $patterns $type $exclude]
	} else {
		set paths [glob-nonrecursive $patterns $all $type $exclude]
	}

	if {[llength $paths]} {
		set paths [make-unlocal-src {*}$paths]
	} else {
		if {$warn} {
			user-notice "Warning: No matches for Glob $patterns"
		}
	}

	lsort $paths
}

# ----- module help.tcl -----
# Copyright (c) 2011 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which provides version, usage, help

proc show-version {} {
    return "tmake v$::tmake(version)"
}

proc show-help {argv} {
    puts \
{Usage: tmake [options] [name=value ...] [targets]

   tmake builds projects based on simple, flexible build descriptions.

   -h|--help             Show this help
   -C|--directory=<dir>  Run as if from directory <dir>
   -v|--verbose          Force "V=1" mode when building to show commands executed
   -n|--dry-run          Show commands which would have been run, but don't execute
   -N|-nn                Like -n, but don't show detailed commands
   --force               Treat all targets to be built as out-of-date
   -t|--time             Show build time even if nothing was run
   -q|--quickstop        Stop on the first build error
   -Q|--quiet            Don't show the build time
   --targets[=all]       List all non-phony targets. If a parameter is given, include all targets and the rule location.
   -p|--print            Show all known rules
   --find=<target>       Show rules that contain the given substring as a target
   --jobs=<n>            Limit parallel jobs to <n>. Defaults to the number of cpus, or $MAXJOBS if set.
   --genie               Generate an initial build.spec from sources in the current dir
   --commands            Show commands from the rulebase
   -d...                 Enable various debugging "types"
   -d?                   Show all individual debugging types
   --debug               Alternative to "-dg"
   --showcache           Dump the tmake cache in a readable form
   --build=<objdir>      Specify the directory for build results (default: objdir)
   --install=<dir>       Install tmake to the given directory as a single script: <dir>/tmake
   --version             Show the tmake version
   --rulebase            Output the builtin rulebase
   --ref                 Show developer reference
}
   # Note: The following are not documented. Should include these with --help=all
   # --findall
   # --delta
   # --force
   # --showvars?=where?
   # --showaliases
   # --warnings
   # --commands
   # --col
   # --nocol
   # --nopager
   # --hash

    puts [show-version]
    exit 0
}

# If not already paged and stdout is a tty, pipe the output through the pager
# This is done by reinvoking autosetup with --nopager added
proc use_pager {} {
    if {$::tmake(usepager) && [getenv PAGER ""] ne "" && [isatty? stdin] && [isatty? stdout]} {
        if {[catch {
            exec [info nameofexecutable] $::argv0 --nopager {*}$::argv |& {*}[getenv PAGER] >@stdout <@stdin 2>@stderr
        } msg opts] == 1} {
            if {[dict get $opts -errorcode] eq "NONE"} {
                # an internal/exec error
                puts stderr $msg
                exit 1
            }
        }
        exit 0
    }
}

proc help-select-formatter {type} {
    switch -glob -- $type {
        wiki {use wiki-formatting}
        ascii* {use asciidoc-formatting}
        md - markdown {use markdown-formatting}
        default {use text-formatting}
    }
}

# Outputs the reference manual in one of several formats
proc show-reference {{type text}} {

    use_pager
    help-select-formatter $type

    title "[show-version] -- Command Reference"

    section {Introduction}

    p {
        See https://dev.workware.net.au/git/?p=tmake.git;a=summary for the online documentation for 'tmake'
    }

    p {
        'tmake' is a concept build system. It is used as a test bench
        for various ideas for a simple but powerful build system, while
        also being useful for real-world projects.

        'tmake' is not yet ready for public consumption. It lacks a number
        of key features and much documentation.
    }

    show-command-reference

    exit 0
}

proc output-help-block {type lines} {
    if {[llength $lines]} {
        switch $type {
            code {
                codelines $lines
            }
            p {
                p [join $lines]
            }
            list {
                foreach line $lines {
                    bullet $line
                }
                nl
            }
        }
    }
}

# Generate a command reference from inline documentation
proc show-command-reference {} {
    lappend files $::tmake(exe)
    lappend files {*}[lsort [glob -nocomplain $::tmake(dir)/lib/*.tcl]]

    set rulebase [get-rulebase]
    if {[llength $rulebase] == 1} {
        # External rulebase
        lappend files [lindex $rulebase 0]
    }

    section "Core Commands"

    foreach file $files {
        show-command-reference-blob [file rootname [file tail $file]] [readfile $file]
    }

    if {[llength $rulebase] > 1} {
        # Default/internal rulebase
        show-command-reference-blob {*}$rulebase
    }
    exit 0
}

proc show-command-reference-blob {name text} {
    set searching 1
    set lines {}
    set type p

    foreach line [split $text \n] {
        if {$searching} {
            # Find lines starting with "# @*" and continuing through the remaining comment lines
            if {![regexp {^# @(.*)} $line -> cmd]} {
                continue
            }
            set searching 0

            # Synopsis or command?
            if {$cmd eq "synopsis:"} {
                section "Module: $name"
            } else {
                subsection $cmd
            }

            set lines {}
            set type p
            continue
        }

        # Now the description
        if {![regexp {^#(#)? ?(.*)} $line -> hash cmd]} {
            set cmd ""
            set searching 1
        } else {
            if {$hash eq "#"} {
                set t code
            } elseif {[regexp {^- (.*)} $cmd -> cmd]} {
                set t list
            } else {
                set t p
            }

            #puts "hash=$hash, oldhash=$oldhash, lines=[llength $lines], cmd=$cmd"
        }

        if {$t ne $type || $cmd eq ""} {
            # Finish the current block
            output-help-block $type $lines
            set lines {}
            set type $t
        }
        if {$cmd ne ""} {
            lappend lines $cmd
        }
    }

    output-help-block $type $lines
}

# ----- module install.tcl -----
# Copyright (c) 2011 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which can install tmake

proc tmake_install {dir} {
	if {$dir eq ""} {
		user-error "Usage: tmake --install=<dir>"
	}
	if {[catch {
		file mkdir $dir

		cd $dir

		set f [open tmake w]

		# Write the main script, but only up until "CUT HERE"
		set in [open $::tmake(dir)/tmake]
		while {[gets $in buf] >= 0} {
			if {$buf ne "##-- CUT HERE --##"} {
				puts $f $buf
				continue
			}

			# Insert the static modules here
			puts $f "set tmake(installed) 1"
			set modules {}
			foreach file [lsort [glob -nocomplain $::tmake(dir)/lib/*.tcl]] {
				lappend modules [file rootname [file tail $file]]
				puts $f "# ----- module [file tail $file] -----"
				puts $f [readfile $file]
			}
			foreach m $modules {
				puts $f "if {\[exists -proc init-$m\]} {init-$m}"
			}
			# Embed the default rulebase
			puts $f "set tmake(defaultrulebase) {[readfile $::tmake(dir)/rulebase.default]}"
		}
		close $in
		close $f
		exec chmod +x tmake
	} error]} {
		user-error "Failed to install tmake: $error"
	}
	exit 0
}

# ----- module pkg-config.tcl -----
# Copyright (c) 2016 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# @synopsis:
#
# Module which provides simple pkg-config support

# @pkg-config modulename
#
# If the given pkg-config module was detected with autosetup,
# add the required compiler/linker flags and libraries.
# Returns 1 if found/added, or 0 otherwise.
#
# Typicaly usage is as follows:
#
# In auto.def:
#
## use pkg-config
## if {[pkg-config pango >= 1.30.0]} {
##   msg-result "Enabling pango"
## }
#
# In build.spec:
#
## use pkg-config
## if {[pkg-config pango]} {
##   lappend sources pango-integration.c
## }
#
proc pkg-config {name} {
	set prefix PKG_[string toupper $name]
	ifconfig HAVE_$prefix {
		UseSystemLibs {*}[get-define ${prefix}_LIBS]
		CFlags {*}[get-define ${prefix}_CFLAGS]
		C++Flags {*}[get-define ${prefix}_CFLAGS]
		LinkFlags {*}[get-define ${prefix}_LDFLAGS]
		return 1
	}
	return 0
}

# ----- module template.tcl -----
# Copyright (c) 2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which provides creation of a file from a template with substitution
# XXX: Should this be in the default rulebase instead?

# @apply-template infile outfile vars targetname
#
# Reads the input file '$infile' and writes the output file '$outfile'
#
# '$vars' contains a list of variable name value pairs
#
# '$targetname' is the name of the output file for warning reporting purposes.
#
# If '$outfile' is blank/omitted, '$template' should end with '.in' which
# is removed to create the output file name.
#
# Conditional sections may be specified as follows:
## @if NAME eq "value"
## lines
## @else
## lines
## @endif
#
# Where 'NAME' is a variable name from '$vars' and '@else' is optional.
# If the expression does not match, all lines through '@endif' are ignored.
#
# The alternative forms may also be used:
## @if NAME  (true if the variable is defined, but not empty and not "0")
## @if !NAME  (opposite of the form above)
## @if <general-tcl-expression>
#
# In the general Tcl expression, any words beginning with an uppercase letter
# are translated into the [dict get $vars NAME]
#
# Expressions may be nested
#
proc apply-template {infile outfile vars target} {

	# A stack of true/false conditions, one for each nested conditional
	# starting with "true"
	set condstack {1}
	set result {}
	set linenum 0
	foreach line [split [readfile $infile] \n] {
		incr linenum
		if {[regexp {^@(if|else|endif)\s*(.*)} $line -> condtype condargs]} {
			dputs m "condtype=$condtype, condargs=$condargs, vars=$vars"
			if {$condtype eq "if"} {
				if {[llength $condargs] == 1} {
					# ABC => [dict get $vars ABC] ni {0 ""}
					# !ABC => [dict get $vars ABC] in {0 ""}
					lassign $condargs condvar
					set not 0
					if {[regexp {^!(.*)} $condvar -> condvar]} {
						set not 1
					}
					if {![dict exists $vars $condvar]} {
						build-fatal-error "$infile:$linenum: No such variable: $condvar"
					}
					set value [dict get $vars $condvar]
					set condexpr 0
					if {$not} {
						if {$value in {0 ""}} {
							set condexpr 1
						}
					} else {
						if {$value ni {0 ""}} {
							set condexpr 1
						}
					}
					dputs m condexpr=$condexpr
				} else {
					# Translate alphanumeric ABC into [dict get $vars ABC] and leave the
					# rest of the expression untouched
					regsub -all {([A-Z][[:alnum:]_]*)} $condargs {[dict get \$vars \1]} condexpr
				}
				if {[catch [list expr $condexpr] condval]} {
					dputs m $condval
					build-fatal-error "$infile:$linenum: Invalid expression: $line"
				}
				dputs m "@$condtype: $condexpr => $condval"
			}
			if {$condtype ne "if" && [llength $condstack] <= 1} {
				build-fatal-error "$infile:$linenum: Error: @$condtype missing @if"
			}
			switch -exact $condtype {
				if {
					# push condval
					lappend condstack $condval
				}
				else {
					# Toggle the last entry
					set condval [lpop condstack]
					set condval [expr {!$condval}]
					lappend condstack $condval
				}
				endif {
					if {[llength $condstack] == 0} {
						user-notice "$infile:$linenum: Error: @endif missing @if"
					}
					lpop condstack
				}
			}
			continue
		}
		# Only output this line if the stack contains all "true"
		if {"0" in $condstack} {
			continue
		}
		lappend result $line
	}

	# Now the inline mapping
	set mapping {}
	foreach {name value} $vars {
		lappend mapping @$name@ $value
	}

	# Apply the mapping
	set mapped [string map $mapping [join $result \n]]\n
	# Check for any unmapped variables
	set unmapped [regexp -all -inline {@[A-Za-z0-9_]+@} $mapped]
	if {[llength $unmapped]} {
		set unmapped [string map {@ ""} [lunique $unmapped]]
		user-notice purple [make-source-location $target "" ": Warning: $target has unmapped variables: $unmapped"]
	}
	writefile $outfile $mapped
}

# Note that it is possible to omit any mapping, in
# which case all defined variables are mapped.
# This is not recommended since any change to a variable will cause
# the template to be regenerated.
#
# Returns the local target to allow the following construct:
#
# Depends all [Template target src ...]
#
rule Template {args} {
Template ?--nowarn? target src ?var1 var2 var3=value ...?

Creates 'target' from 'src' substituting @var1@, @var2@, etc. with
the value of the corresponding defined variables, or the given value.

Also supports conditionals, @if, @else and @endif. See 'apply-template' in the tmake reference.

Note: If no variables are specified, all defined variables will be mapped but this is not recommended
and produces a warning unless '--warn' is given.
} {
	show-this-rule

	getopt {--nowarn target src args} args

	if {[llength $args] == 0} {
		# This is more of a hint than a warning
		if {!$nowarn} {
			user-notice purple [warning-location "Warning: Template $target with no variables, mapping all variables"]
		}
		set args [lsort [dict keys $::tmake(defines)]]
	}

	# Create the mapping as a variable to the rule.
	# If the mapping changes, the rule will re-run
	#       
	set vars {}
	foreach var $args {
		if {[regexp {([^=]*)=(.*)} $var -> name value]} {
			lappend vars $name $value
		} else {
			if {![define-exists $var]} {
				user-notice purple [warning-location "Warning: $target maps undefined variable $var" build.spec]
			}
			lappend vars $var [get-define $var]
		}
	}
	target [make-local $target] -inputs [make-local $src] -vars vars $vars -msg {note Template $targetname} -do {
		apply-template $inputs $target $vars $targetname
	}
	Clean $target
	return [make-local $target]
}

# ----- module text-formatting.tcl -----
# Copyright (c) 2010 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# Module which provides text formatting

proc wordwrap {text length {firstprefix ""} {nextprefix ""}} {
    set len 0
    set space $firstprefix
    foreach word [split $text] {
        set word [string trim $word]
        if {$word eq ""} {
            continue
        }
        if {$len && [string length $space$word] + $len >= $length} {
            puts ""
            set len 0
            set space $nextprefix
        }
        incr len [string length $space$word]

        # Use man-page conventions for highlighting 'quoted' and *quoted*
        # single words.
        # Use x^Hx for *bold* and _^Hx for 'underline'.
        #
        # less and more will both understand this.
        # Pipe through 'col -b' to remove them.
        if {[regexp {^'(.*)'([^a-zA-Z0-9_]*)$} $word -> bareword dot]} {
            regsub -all . $bareword "_\b&" word
            append word $dot
        } elseif {[regexp {^[*](.*)[*]([^a-zA-Z0-9_]*)$} $word -> bareword dot]} {
            regsub -all . $bareword "&\b&" word
            append word $dot
        }
        puts -nonewline $space$word
        set space " "
    }
    if {$len} {
        puts ""
    }
}
proc title {text} {
    underline [string trim $text] =
    nl
}
proc p {text} {
    wordwrap $text 80
    nl
}
proc codelines {lines} {
    foreach line $lines {
        puts "    $line"
    }
    nl
}
proc nl {} {
    puts ""
}
proc underline {text char} {
    regexp "^(\[ \t\]*)(.*)" $text -> indent words
    puts $text
    puts $indent[string repeat $char [string length $words]]
}
proc section {text} {
    underline "[string trim $text]" -
    nl
}
proc subsection {text} {
    underline "$text" ~
    nl
}
proc bullet {text} {
    wordwrap $text 76 "  * " "    "
}
proc indent {text} {
    wordwrap $text 76 "    " "    "
}
proc defn {first args} {
    if {$first ne ""} {
        underline "    $first" ~
    }
    foreach p $args {
        if {$p ne ""} {
            indent $p
        }
    }
}

# ----- module util.tcl -----
# Copyright (c) 2012 WorkWare Systems http://www.workware.net.au/
# All rights reserved

# @synopsis:
#
# Module containing miscellaneous utility functions

# Dump variables in the parent scope to stdout
proc dump-vars {{maxlength 50}} {
	set vars [uplevel 1 info vars]
	foreach v [lsort $vars] {
		set value [uplevel 1 [list set $v]]
		set value [string map [list \\ \\\\ \n \\n] $value]
		if {[string length $value] > $maxlength} {
			set value [string range $value 0 $maxlength]...
		}
		puts "\$[set v] = $value"
	}
}

# @compare-versions version1 version2
#
# Versions are of the form a.b.c (may be any number of numeric components)
#
# Compares the two versions and returns:
## -1 if v1 < v2
##  0 if v1 == v2
##  1 if v1 > v2
#
# If one version has fewer components than the other, 0 is substituted. e.g.
## 0.2   <  0.3
## 0.2.5 >  0.2
## 1.1   == 1.1.0
#
proc compare-versions {v1 v2} {
	foreach c1 [split $v1 .] c2 [split $v2 .] {
		if {$c1 eq ""} {
			set c1 0
		}
		if {$c2 eq ""} {
			set c2 0
		}
		if {$c1 < $c2} {
			return -1
		}
		if {$c1 > $c2} {
			return 1
		}
	}
	return 0
}

# @pad string width ?padchar?
#
# Returns $string, right padded to a length
# of at least $with. If the pad char is not given,
# pads with spaces (" ")
proc pad {text width {char { }}} {
	if {[string length $text] >= $width} {
		return $text
	}
	return $text[string repeat $char [expr {$width - [string length $text]}]]
}

# @append-with-spaces varname value ?space?
#
# If the given var is not set or is "", sets it to $value
# Otherise appends $value with a space separator (or $space)
#
proc append-with-space {varname value {space " "}} {
	upvar $varname n
	if {[info exists n] && $n ne ""} {
		append n $space $value
	} else {
		set n $value
	}
}

# @suffix suf element ...
#
# Returns a list with $suf appended to each element
# 
## suffix .c a b c => a.c b.c c.c
#
proc suffix {suf args} {
	set result {}
	foreach p [join $args] {
		lappend result $p$suf
	}
	return $result
}

# @prefix pre element ...
#
# Returns a list with $pre prepended to each element
# 
## prefix jim- a.c b.c => jim-a.c jim-b.c
#
proc prefix {pre args} {
	set result {}
	foreach p [join $args] {
		lappend result $pre$p
	}
	return $result
}

# @change-ext ext filename ...
#
# Returns a list of filenames, where the extension of each each filename
# is changed to $ext
# 
## change-ext .c a.o b.o c => a.c b.c c.c
#
proc change-ext {ext args} {
	set result {}
	foreach p [join $args] {
		lappend result [file rootname $p]$ext
	}
	return $result
}

# @omit list element ...
#
# Returns a list with the given elements removed
#
proc omit {list args} {
	lmap p $list {
		if {$p in $args} {
			continue
		}
		lindex $p
	}
}

# @lpop list
#
# Removes the last entry from the given list and returns it.
proc lpop {listname} {
	upvar $listname list
	set val [lindex $list end]
	set list [lrange $list 0 end-1]
	return $val
}

# Merges target variables.
# These are stored in dictionaries, where $dict1 is the current vars
# and the new vars $dict2 need to be merged.
# Where there is no overlap, the dictionaries are simply merged.
# Where a var exists in both, the values are combined with a space separator.
proc merge-vars {dict1 dict2} {
	if {[dict size $dict2]} {
		if {[dict size $dict1] == 0} {
			return $dict2
		}
		set d1 $dict1
		foreach {n v} $dict2 {
			append-with-space d1($n) $v
		}
		return $d1
	}
	return $dict1
}

# @quote-if-needed string
#
# Returns a new string that is escaped according to shell
# escaping rules. That is, double quotes and backslashes are
# escape with backslash and the result is quoted if it contains double quotes.
#
## quote-if-needed {-DT=13 "Oct"} => {"-DT=13 \"Oct\""}
#
# Useful in cases like this:
#
## CFlags [quote-if-needed -DPROCESSOR_VERSION=\"[exec date]\"]
proc quote-if-needed {str} {
	if {[string match {*[\" \t]*} $str]} {
		return \"[string map [list \" \\" \\ \\\\] $str]\"
	}
	return $str
}

# @shell-quote-list list
#
# Applies 'quote-if-needed' to each element of the list and returns
# a string suitable for passing to the shell.
proc shell-quote-list {argv} {
	set args {}
	foreach arg $argv {
		lappend args [quote-if-needed $arg]
	}
	join $args
}

if {[exists -proc init-argparse]} {init-argparse}
if {[exists -proc init-colour]} {init-colour}
if {[exists -proc init-compat]} {init-compat}
if {[exists -proc init-config]} {init-config}
if {[exists -proc init-fileutil]} {init-fileutil}
if {[exists -proc init-genie]} {init-genie}
if {[exists -proc init-getopt]} {init-getopt}
if {[exists -proc init-glob]} {init-glob}
if {[exists -proc init-help]} {init-help}
if {[exists -proc init-install]} {init-install}
if {[exists -proc init-pkg-config]} {init-pkg-config}
if {[exists -proc init-template]} {init-template}
if {[exists -proc init-text-formatting]} {init-text-formatting}
if {[exists -proc init-util]} {init-util}
set tmake(defaultrulebase) {# vim:set syntax=tcl:
# vi:se noet sw=4 ts=4:
#
# These are the built-in rules
#
# They can be replaced if necessary by creating rulebase.spec
# at the top level of your project.

# @synopsis:
#
# rulebase.default is the default tmake rulebase...
#
# The following environment variables are used if set:
#
## CC       - C compiler
## CXX      - C++ compiler
## ...

use getopt glob

proc rulebase-invoke {cmd} {
	switch -exact -- $cmd {
		prolog {
			tailcall rulebase-prolog
		}
		epilog {
			tailcall rulebase-epilog
		}
		init {
			tailcall rulebase-init
		}
		default {
			dputs m "Rulebase does not implement rulebase-invoke $cmd"
		}
	}
}

# ==================================================================
# Default variable settings and rules
# ==================================================================

proc rulebase-init {} {
	# If settings are loaded via Load, these should all be ignored
	# Thus we use define?
	define? CCACHE ""
	define? CC gcc
	define? CXX g++
	define? AR ar
	define? RANLIB ranlib
	define? STRIP strip
	define? STRIPFLAGS ""
	define? STRIPLIBFLAGS ""
	define? ARFLAGS cr
	define? CFLAGS ""
	define? CXXFLAGS ""
	define? LDFLAGS ""
	if {[iswin]} {
		define? EXEEXT .exe
	} else {
		define? EXEEXT ""
	}

	define? SH_CFLAGS ""
	define? SH_LDFLAGS ""
	define? SH_LINKFLAGS ""
	define? SH_SOEXT .so
	define? SHOBJ_CFLAGS ""
	define? SHOBJ_LDFLAGS ""
	define? LD_LIBRARY_PATH ""

	define? CC_FOR_BUILD gcc
	define? HOST_CFLAGS ""
	if {[iswin]} {
		define? HOST_EXEEXT .exe
	} else {
		define? HOST_EXEEXT ""
	}

	define? LEX flex
	define? LFLAGS ""
	define? YACC bison
	define? YFLAGS -y

	define? LOCAL_LIBS ""
	define? DESTDIR ""
	define? OBJCFLAGS ""
	define? INCPATHS ""

	# Default header pattern for C and C++ dynamic dependencies
	define? CHDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

	# Value to check for change (e.g. from environment)  to force Autosetup configure to rerun
	define? CONFIGURE_ENV ""

	# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
	define C_FLAGS ""
	define CXX_FLAGS ""
	define LD_FLAGS ""

	define PUBLISH publish

	define PROJLIBS ""
	define SYSLIBS ""
	define HOST_SYSLIBS ""
	define PRECOMPILED_HEADER ""

	# All globals variables for rulebase.default are kept in the $::tmakedrb array
	set ::tmakedrb {
		testruncount 0
		testpasscount 0
		testid 0
		setuptestenv 0
		objmap {}
		objrules {}
	}
}

# ==================================================================
# Help Overview
# ==================================================================
rule-overview {
This is rulebase.default, the default tmake rulebase. Note the following conventions:

File specifications for Install and Publish rules support the following forms:
  - Regular filenames
  - Renaming rules of the form: target=source
  - Glob patterns (e.g. *.png)

For rules that set variables/flags, those definitions apply to rules later in the file.
For example, when setting C_FLAGS with CFlags, those flags are used by subsequent
Object and Executable rules, but not earlier rules.

Note: Scope can be used to limit the lifetime of definitions.

The following global phony targets are created:

  all:       Builds the 'all' targets from all subdirectories
  test:      Runs the 'test' targets from all subdirectories
  clean:     Runs the 'clean' targets from all subdirectories
  distclean: Runs the 'distclean' targets from all subdirectories
  install:   Runs all install rules
  uninstall: Runs all uninstall rules

  Note that these global targets can be accessed from within a subdirectory
  by using a / prefix. e.g. /all

The following per-directory phony targets are created:
  all:       Builds executables and shared objects for the current directory
             (or libraries if there are no executables or shared objects)
  test:      Runs all tests for the current directory
  clean:     Removes all build products, including Clean targets, for the current directory
  distclean: Runs 'clean', and removes DistClean targets for the current directory,
             and removes all orphan objects
  install:   A convenience alias for /install
  uninstall: A convenience alias for /uninstall

Note that by default, Lib is an alias for ArchiveLib. This can be changed with:
  alias Lib SharedLib

Normally 'install' targets are built on-demand, but the following can be set
to build the install dependencies as part of the 'all' target in order to avoid
build during install when installing as root.

  define INSTALLDEPTARGET all
}

# ==================================================================
# BUILT-IN Object Rules
# ==================================================================

proc is-duplicate-obj-rule {obj src vars} {
	global tmakedrb

	# Build the info for the rule
	set info [list $src]
	foreach var $vars {
		lappend info $var [get-define $var]
	}

	if {[dict exists $tmakedrb objrules $obj]} {
		# Is it identical?
		dputs m "Ignoring identical duplicate object rule for $obj at [find-source-location]"

		set oldinfo [dict get $tmakedrb objrules $obj]
		if {$oldinfo ne $info} {
			build-error [warning-location "Error: Duplicate Object rule for $obj with different settings"]
		}
		return 1
	}

	dict set tmakedrb objrules $obj $info
	return 0
}

# @ObjectRule.<ext> object source
#
# Rule for creating 'object' from source file 'source' with the
# extentions 'ext'.
#
# The appropriate ObjectRule.<ext> is invoked from Object
# (and hence Objects, Executable and Lib) based on the extension.
#
# Note that 'object' and 'source' are fully qualified names

rule ObjectRule.c {obj src} {
ObjectRule.c object source

Generates an object file from a C source file

Bound variables: CC, C_FLAGS (from CFlags, ObjectCFlags), INCPATHS (from IncludePaths)
Used variables:  CFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
                 PRECOMPILED_HEADER (see PrecompiledHeader)
} {
	if {![is-duplicate-obj-rule $obj $src {CC C_FLAGS INCPATHS}]} {
		# Capture the current value of CC, C_FLAGS and INCPATHS
		target $obj -inputs $src -msg {note Cc $targetname} -getvars CC C_FLAGS INCPATHS -do {
			run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
		} -dyndep {
			header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
		} -depends [get-define PRECOMPILED_HEADER]
	}
	return $obj
}

rule ObjectRule.cpp {obj src} {
ObjectRule.cpp object source
(Also aliases ObjectRule.cc, ObjectRule.cxx, ObjectRule.C)

Generates an object file from a C++ source file

Bound variables: CXX, CXX_FLAGS (from C++Flags), INCPATHS (from IncludePaths)
Used variables:  CXXFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation),
                 PRECOMPILED_HEADER (see PrecompiledHeader)
} {
	if {![is-duplicate-obj-rule $obj $src {CXX CXX_FLAGS INCPATHS}]} {
		# Capture the current value of CXX, CXX_FLAGS and INCPATHS
		target $obj -inputs $src -msg {note C++ $targetname} -getvars CXX CXX_FLAGS INCPATHS -do {
			run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
		} -dyndep {
			header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
		} -depends [get-define PRECOMPILED_HEADER]
	}
	return $obj
}

# Why haven't we settled on a single extension?
alias ObjectRule.cc ObjectRule.cpp
alias ObjectRule.cxx ObjectRule.cpp
alias ObjectRule.C ObjectRule.cpp

rule ObjectRule.l {obj src} {
ObjectRule.l object source

Generates an object file from a lexer source file
Note that $LEX must support --outfile and --header-file

Bound variables: LEX, LFLAGS
} {
	set base [file rootname $src]
	set targets [list $base.lex.c $base.lex.h]

	# Build the output files with lex/flex
	target $targets -inputs $src -msg {note Lex $targetname} -getvars LEX LFLAGS -do {
		run $LEX $LFLAGS --outfile=[lindex $target 0] --header-file=[lindex $target 1] $inputs
	}
	add-clean [make-local clean] $targets
	add-clean [make-local distclean] $targets

	# And create the object through Object
	Object [make-unlocal $base.lex.o] [make-unlocal $base.lex.c]
}

rule ObjectRule.y {obj src} {
ObjectRule.y object source

Generates an object file from a yacc source file

Note that $YACC must support --output and --defines

Bound variables: YACC, YFLAGS
} {
	set base [file rootname $src]
	set targets [list $base.tab.c $base.tab.h]

	# Build the output files with yacc/bison
	target $targets -inputs $src -msg {note Yacc $targetname} -getvars YACC YFLAGS -do {
		run $YACC $YFLAGS --output=[lindex $target 0] --defines=[lindex $target 1] $inputs
	}
	add-clean [make-local clean] $targets
	add-clean [make-local distclean] $targets

	# And create the object through Object
	Object [make-unlocal $base.tab.o] [make-unlocal $base.tab.c]
}

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc rulebase-prolog {} {
	global tmakedrb

	show-this-rule [local-dir]

	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			set localtarget [make-local $t]
			target $localtarget -phony
			target $parentprefix$t -phony -depends $localtarget
		}
		Phony install install
		Phony uninstall uninstall
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}

	# Capture these variables
	foreach i {INCPATHS C_FLAGS CXX_FLAGS} {
		dict set tmakedrb $i [get-define $i]
	}

	# This can be removed with IncludePaths --reset
	IncludePaths .
}

proc rulebase-epilog {} {
	show-this-rule [local-dir]

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	# Ensure that even directories with no targets are removed
	Clean __dummy__
}

# ==================================================================
# UTILTY PROCS
# ==================================================================

# @target-alias target targetexe
#
# On some systems, executables are identified with an extension (e.g. .exe)
# For cross-platform compatibility, rules omit this extension and an alias is used
# to link to the actual filename.
#
# This command checks the rule name (e.g. abc) and the executable name (e.g. abc.exe)
# and if they are different, returns an appropriate target alias for the executable
# (e.g. -alias abc). Otherwise an empty list is returned.
#
proc target-alias {target targetexe} {
	if {$target ne $targetexe} {
		return [list -alias [make-local $target]]
	}
	return ""
}

# @publish-path dir
#
# Returns the path to the given 'publish' subdirectory,
# e.g. [publish-path include] returns something like objdir/.publish/include
#
proc publish-path {dir} {
	file-build [file-join [get-define PUBLISH] $dir]
}

# @publish-dir dir
#
# Returns the path to the given 'publish' subdirectory relative to the build directory
# e.g. [publish-dir include] returns something like .publish/include
#
proc publish-dir {dir} {
	file-join [get-define PUBLISH] $dir
}

# @publish-prefix dir
#
# Like publish-dir, but returns the value suitable to be used as a prefix
#
proc publish-prefix {dir} {
	make-prefix [publish-dir $dir]
}

# @publish-one-file dest src
#
# Creates a rule to publish $src as $dest (build relative name) by creating a hard link.
# e.g. publish-one-file include/header.h header.h
#
proc publish-one-file {dest src} {
	#dputs m "publish-one-file dest=$dest, src=$src, realdest=[publish-dir $dest]"
	hard-link [publish-dir $dest] $src -msg {note Publish $targetname}
}

# @publish-lib libname alias
#
# Creates a rule to publish an archive library, $libname, to the $PUBLISH/lib directory.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-lib {libname alias} {
	hard-link [publish-prefix lib]$libname [make-local $libname] -msg {note Publish $targetname} -alias $alias
}

# @make-shlib-symlinks first alias...
#
# Create symlinks such that each of the given aliase is a symlink to $first.
# All paths/names should be in the same directory
# The alias targets must not exist.
#
proc make-shlib-symlinks {first args} {
	foreach alias $args {
		file-link -sym $alias [file tail $first]
	}
}

# @publish-shared-lib names source alias
#
# Creates a rule to publish a shared library, $source, with the given names to the
# $PUBLISH/lib directory.
# This includes creating appropriate symlinks.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-shared-lib {names source alias} {
	set published [prefix [publish-prefix lib] {*}$names]

	target $published -inputs $source -msg {note Publish [lindex $targetname 0]} -do {
		file delete {*}$target
		file-link [lindex $target 0] $inputs
		make-shlib-symlinks {*}$target
	} -vars libname [lindex $names 0] -alias $alias
	add-clean [make-local clean] $published
	add-clean [make-local distclean] $published
}

# @install-shared-lib ?--striplib? dest names source flags
#
# Creates a rule to install a shared library, $source, to install directory $dest
# This includes creating appropriate symlinks.
# $flags are passed to install-file and should either be empty, or "striplib".
proc install-shared-lib {args} {
	getopt {--striplib dest names source} args

	set installed [prefix [make-prefix [get-define DESTDIR]$dest] $names]

	set installopts {}
	lappend installopts --bin
	if {$striplib} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPLIBFLAGS]"
	}
	target $installed -nocache -rootok -inputs $source -msg {note Install $libname} -do {
		file delete {*}$target
		install-file {*}$installopts [lindex $target 0] $inputs
		make-shlib-symlinks {*}$target
	} -vars installopts $installopts libname [file-join $dest [lindex $names 0]]

	target install -depends {*}$installed
	add-clean uninstall $installed
}

# @make-local-or-abs filename
#
# If $filename is an absolute path, returns $filename
# Otherwise returns [make-local $filename]
proc make-local-or-abs {filename} {
	if {[string match /* $filename]} {
		return $filename
	}
	return [make-local $filename]
}

# @expand-filespec dir filelist keepdir
#
# Implements target renaming/globbing for Publish and Install
#
# $dir is the target directory
# $filelist is the file specification
# $keepdir is a boolean which indicates whether to keep the source dir in the target name
#
# The file specification may include:
# - Regular filenames
# - Renaming rules of the form: target=src
# - Glob patterns
#
# Returns a list of the form: target1 source1 target2 source2 ...
proc expand-filespec {dir filelist keepdir} {
	set result {}

	foreach spec $filelist {
		if {$spec eq ""} {
			continue
		}
		if {[string match *=* $spec]} {
			lassign [split $spec =] target src
			#dputs m "file renaming: dir=$dir, target=$target, src=$src => target=[file-join $dir $target] src=[make-local $src]"
			lappend result [file-join $dir $target] [make-local-or-abs $src]
			continue
		}
		if {[string match {*[{}*?]*} $spec]} {
			set srcs [Glob --all $spec]
		} else {
			set srcs $spec
		}
		foreach src $srcs {
			if {$keepdir} {
				#dputs m "keepdir: dir=$dir, src=$src => target=[file-join $dir $src] src=[make-local-or-abs $src]"
				lappend result [file-join $dir $src] [make-local-or-abs $src]
			} else {
				#dputs m "no keepdir: dir=$dir, src=$src => target=[file-join $dir [file tail $src]] src=[make-local-or-abs $src]"
				lappend result [file-join $dir [file tail $src]] [make-local-or-abs $src]
			}
		}
	}
	#puts "expand-filespec: $filelist => $result"
	return $result
}

# @expand-objects objs
#
# Expands a list of objects which may contain library aliases of the form <lib>$basename
# Each library alias is expanded into the list of objects for that library.
# (Note that SharedLib and ArchiveLib create an object list when creating libraries)
# Any non-aliases are left unchanged.
#
# Returns the expanded object list.
proc expand-objects {objs} {
	set result {}
	foreach obj $objs {
		if {[string match <lib>* $obj]} {
			if {![dict exists $::tmakedrb(objmap) $obj]} {
				build-error [warning-location "Error: Unable to find objects for unknown lib $obj"]
				return -code break
			}
			# XXX: How to guarantee that $SH_CFLAGS are set on these objects?
			# (Either directly via ObjectCFlags or with a top-level CFlags)
			#
			lappend result {*}[file-build-list [dict get $::tmakedrb(objmap) $obj]]
		} else {
			lappend result $obj
		}
	}
	#puts "expand-objects $objs =>\n$result"
	return $result
}

# @load-config-file filename
#
# Reads a configuration file of the form:
#
## CONFIG_BOOL_VALUE=y (or m)
## CONFIG_STR_VALUE="string value"
## CONFIG_INT_VALUE=123
#
# Each matching value is loaded as a corresponding variable definition
# where if the value is "y", it is changed to "1", and if the value
# is a quoted string, the quotes are removed.
proc load-config-file {filename} {
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			dputs c "define $name $value"
			# Add source info here for tracking purposes
			define $name [info-source $value $filename $n]
		} else {
			user-notice purple "$filename:$n: Warning: Failed to parse $line"
		}
	}
	if {$n == 0} {
		user-notice purple "Warning: $filename contains no configuration"
	}
}

# @setup-test-env
#
# Prepares the environment for running tests.
# Given the (absolute path of) $PUBLISH/lib and the name of the LD_LIBRARY_PATH variable,
# appends the publish lib $LD_LIBRARY_PATH in the environment to allow published shared libraries to be loaded
# Also sets TMAKE_LIBPATH to the same value for script helpers on Mac OS X
# since DYLD_LIBRARY_PATH can't be passed to scripts
# (See https://forums.developer.apple.com/message/31148)
proc setup-test-env {publishlib ldlibpath} {
	setenv TMAKE_LIBPATH $publishlib
	if {$ldlibpath ne ""} {
		set path [getenv $ldlibpath ""]
		append-with-space path $publishlib $::tcl_platform(pathSeparator)
		setenv $ldlibpath $path
	}


}

# @get-test-id
#
# Returns a unique test id of the form 'test#nnn'
# Used to help identify Test targets since they don't have
# a natural target name.
proc get-test-id {} {
	return test#[incr ::tmakedrb(testid)]
}

# @run-test-command testcommand
#
# This is a helper for running test commands.
# The environment is set up with setup-test-env
# Then SRCDIR is exported to the environment
# stdout, stderr and errok are checked from the caller to determine
# how output/errors are handled/checked
proc run-test-command {testcommand} {
	upvar stdout stdout
	upvar stderr stderr
	upvar errok errok
	upvar SRCDIR SRCDIR

	set cmdline $testcommand

	set outfile {}

	foreach i {stdout stderr} redir {> 2>} {
		if {[exists $i]} {
			set outfile($i) [file tempfile]
			lappend testcommand ${redir}$outfile($i)
		}
	}

	if {![exists stdout]} {
		lappend testcommand >@stdout
	}

	# Get this value from the calling scope and set in the environment
	setenv SRCDIR $SRCDIR
	incr ::tmakedrb(testruncount)
	set rc [catch {
		vputs [string trim $testcommand]
		exec {*}$testcommand
	} msg opts]
	if {[exists errok]} {
		set rc 0
	}
	if {$rc == 0} {
		# Succeeded. Does the output match?
		foreach {i gotfile} $outfile {
			set expfile [set $i]
			set got [readfile $gotfile]
			set exp [readfile $expfile]
			if {$got ne $exp} {
				if {$rc == 0} {
					set rc 1
					pputs \n\t$cmdline\n
					set msg "\nError: Output does not match"
				}
				vputs "diff -u $expfile $gotfile"
				catch {
					exec diff -u $expfile $gotfile >@stdout
				}
			}
		}
	}

	# Delete output
	foreach file [dict values $outfile] {
		file delete -force $file
	}

	if {$rc == 0} {
		incr ::tmakedrb(testpasscount)
		return 0
	}
	build-error $msg
	return -code break
}

# @hard-link ?--copy? dest source ?target-args...?
#
# Creates a rule to link $dest to $source (or copy if --copy is specified)
# Additional arguments may be passed and are added to the target rule.
#
proc hard-link {args} {
	#show-this-rule

	getopt {dest source --copy args} args

	# XXX: If the platform doesn't support hard links,
	# consider falling back to soft links and then to file copy
	if {$copy || ![exists -command file-link]} {
		target $dest -inputs $source -do {
			file delete $target
			file copy $inputs $target
		} {*}$args
	} else {
		target $dest -inputs $source -do {
			file delete $target
			file-link $target $inputs
		} {*}$args
	}

	# Note that we can't use Clean here because $dest is already
	# a local name
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# @sym-link dest source ?target-args...?
#
# Creates a rule to link $dest to $source
# Additional arguments may be passed and are added to the target rule.
#
proc sym-link {args} {
	#show-this-rule

	getopt {dest linktarget args} args

	target $dest -symlink -vars linktarget $linktarget -do {
		file delete $target
		file-link -sym $target $linktarget
	} {*}$args

	# Note that we can't use Clean here because $dest is already
	# a local name
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# @install-file ?--strip=$STRIPCMD? ?--bin? target source
#
# Helper for installing files
# Copies the file from $source to $target, then performs zero or more actions
# depending upon the flags (which is a list)
#
#- --bin                 - make the target executable with chmodx-file
#- --strip=$STRIPCMD     - If specified, strips the target with the given strip command
#
proc install-file {args} {
	getopt {--strip: --bin target source} args

	vputs "Copy $source $target"
	file copy -force $source $target
	if {$bin} {
		chmodx-file $target
	}
	if {[exists strip]} {
		vputs "Strip $target"
		exec {*}$strip $target
	}
}

# @chmodx-file target
#
# Makes the given file executable with chmod +x
proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

# @strip-file flags target
#
# Invokes '$STRIP $flags $target' to strip the given executable
#
# If $STRIP is not set, does nothing
proc strip-file {flags target} {
}

# @remove-empty-directories filename-list
#
# Considers the set of directories containing each filename in the list.
# Removes any of those directories that are empty.
proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# @clean-files filename-list ?msg?
#
# Helper to clean files (and any empty directories)
#
# Removes the list of files, and then any directories that contain those
# files which have become empty.
#
# If $msg is provided, it is printed via 'note', otherwise a default
# message is printed.
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# @clean-target type msg ?args...?
#
# Create the phony clean target of the given type and message.
# The created target invokes clean-files
#
# Additional files can be added to the target with 'add-clean'
#
# If 'args' are specified, these are added to the target. e.g. -rootok
#
proc clean-target {type msg args} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" {*}$args -do {
		clean-files $cleanfiles
	}
}

# @add-clean type filename-list
#
# Adds the given files to the list to be removed for the given type (target)
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	target-add-var $type cleanfiles [file-build-list $filelist]
}

# @add-src-clean type filename-list
#
# Like add-clean, except $filelist are in the source directory rather than the build directory
#
proc add-src-clean {type filelist} {
	target-add-var $type cleanfiles $filelist
}

# @find-project-bin binfile ?-chdir 0|1? ?-optional 0|1?
#
# Searches for the given binary file as follows:
#- If $binfile is a known target, the result is the target
#- If $binfile is of the form <bin>name, the result is the published binary
#- If the file exists in the local directory, the result is the file
#- Otherwise, if optional=1, the file is assumed to be an external binary
#- Otherwise an error is raised.
#
# The result is a list of two values: {dependency filename}
#
# The first value is a build dependency for the file. (Empty for an external binary)
# The second value is the path to the file suitable for executing it, taking
# into account the setting of 'chdir'.
proc find-project-bin {bin args} {
	set opts [list -chdir 0 -optional 0 {*}$args]

	set localbin [make-local $bin]

	if {[is-target? $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin is a local target}
		if {$opts(-chdir)} {
			set result [list $localbin ./$bin]
		} else {
			# Note: Use [build-dir] here rather than [file-build] to retain ./
			#       if building in-tree
			set result [list $localbin [build-dir]/$localbin]
		}
	} elseif {[regexp {^<bin>(.*)} $bin -> basename]} {
		dputxs l {[find-source-location]: find-project-bin: $bin is a publish target}
		set publishbin [publish-prefix bin]$basename
		if {$opts(-chdir)} {
			# We will be running in [file-build [local-dir]],
			# while the executable to run is in [file-build $PUBLISH/bin]
			# So calculate a relative path
			set curdir [file-build [local-dir]]
			set builddir [publish-path bin]
			# It can't hurt to create the $PUBLISH/bin here and it makes relative-path always work
			file-mkdir -rootskip $builddir
			set reldir [relative-path $builddir $curdir]

			set result [list $bin $reldir/$basename]
		} else {
			set result [list $bin [file-build $publishbin]]
		}
	} elseif {[file exists $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin exists as source}
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			set result [list $localbin [file-src-relative $localbin]]
		} else {
			set result [list $localbin $localbin]
		}
	} elseif {$opts(-optional)} {
		dputxs l {[find-source-location]: find-project-bin: $bin is assumed to be external}
		set result [list "" $bin]
	} else {
		# Not found
		build-error [warning-location "$bin is neither a local nor a published (<bin>) target"]
		set result [list "" ""]
	}
	dputxs l {[find-source-location]: find-project-bin returning $result}
	return $result
}

add-deferred-action {
	# Need to add $PUBLISH/include to the include paths
	IncludePaths --build [publish-dir include]
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

rule Executable {args} {
Executable --test --chdir --nobuild --publish --no|strip --nofork --install=<dir> target sources...

Builds an executable from one or more source files. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the executable.

Bound variables: CCLD (from Linker), LD_FLAGS (from LinkFlags), PROJLIBS and PROJDEPS (from UseLibs)
                 LOCAL_LIBS (from ArchiveLib), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS

The following options are supported:
  --test              Marks the executable as a test (see Test)
  --nofork            With --test, uses Test --nofork
  --chdir             With --test, uses Test --chdir
  --nobuild           Don't make this executable dependent on phony 'all' (which is otherwise the default)
  --publish           Publishes the executable (see PublishBin)
  --install=<dir>     Install the executable to the given directory (see InstallFile)
  --strip[=full|dynamic|none]  Sets the strip type on installation. --strip means full. omitted means none. (see InstallFile)
} {
	add-default-opts args
	show-this-rule
	set strip none
	getopt {--test --chdir --nobuild --nofork --publish --strip:full --install: target args} args

	set localtarget [make-local $target]
	set targetexe $target[get-define EXEEXT]
	set localtargetexe $localtarget[get-define EXEEXT]

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	define? CCLD [get-define CC]

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target $localtargetexe -inputs {*}$objects [get-define LOCAL_LIBS] -depends [get-define PROJDEPS] -msg {note Link $targetname} -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $PROJLIBS $SYSLIBS
	} -getvars CCLD LD_FLAGS PROJLIBS SYSLIBS {*}[target-alias $target $targetexe]
	Clean $targetexe

	if {$publish} {
		PublishBin $target
	}

	if {[info exists install]} {
		set opts --bin
		if {$strip ni {none full dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		if {$strip eq "full"} {
			lappend opts --strip
		} elseif {$strip eq "dynamic"} {
			lappend opts --striplib
		}
		InstallFile {*}$opts [file-join $install $targetexe] $localtargetexe
	}
	if {$test} {
		set opts {}
		if {$chdir} {
			lappend opts --chdir
		}
		if {$nofork} {
			lappend opts --nofork
		}
		Test {*}$opts $target
	}
	if {!$nobuild} {
		Phony all $localtargetexe
	}
}

rule PublishBin {args} {
PublishBin ?--script? ?--copy? name ...

Publishes one or more executables (either binaries or scripts)
Unless --script is specified, the executable extension (e.g. .exe) is used.
If --copy is specified, the target is copied. Otherwise it is hard linked (if supported).

Note that 'name' can be 'target=src' to rename a file when published.
} {
	show-this-rule

	getopt {--script --copy args} args

	set destdir [publish-dir bin]

	if {$script} {
		set exe ""
	} else {
		set exe [get-define EXEEXT]
	}
	set opts {}
	if {$copy} {
		set opts --copy
	}

	# XXX Currently does not support external sources
	foreach {dest src} [expand-filespec $destdir $args 0] {
		hard-link {*}$opts $dest$exe $src$exe -vars dest bin/$dest -msg {note Publish $targetname} -alias <bin>[file tail $dest]
		target $dest$exe -add -do {
			chmodx-file $target
		}
	}
}

rule Publish {args} {
Publish ?--keepdir? dir name...

Publishes one or more files to directory $PUBLISH/$dir

Accepts the following file names:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (.e.g *.img)

Normally files are published directly into $PUBLISH/$dir, but if --keepdir is
specified, the relative source directory is kept and replicated under $PUBLISH/$dir

Note: Libraries and Binaries should not be published with this rule.
Rather Publishlib and PublishBin should be used.
} {
	show-this-rule
	getopt {--keepdir dir args} args

	if {$dir eq "bin"} {
		user-notice purple [warning-location "Warning: Use PublishBin to publish binaries"]
	}
	if {$dir eq "lib" && [string match lib* $args]} {
		user-notice purple [warning-location "Warning: Use Lib --publish to publish libraries"]
	}

	# XXX Does not support external sources
	foreach {dest src} [expand-filespec $dir $args $keepdir] {
		publish-one-file $dest $src
	}
}

rule ArchiveLib {args} {
ArchiveLib ?--publish? ?--install=<dir>? basename sources...

Creates an archive library from the given sources. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are combined with $AR and $RANLIB to create the archive library.

This library is added to LOCAL_LIBS so that subsequent Executable's are linked against it.

Used variables: AR, ARFLAGS, RANLIB

The following options are supported:
  --publish           Publishes the library (see PublishLib)
  --install=<dir>     Install the library to the given directory (see InstallFile)
} {
	show-this-rule
	getopt {--publish --install: basename args} args

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set libname lib$basename.a
	set libalias <lib>$basename

	set locallibname [make-local $libname]
	target $locallibname -inputs {*}$objects -msg {note Ar $targetname} -do {
		file delete $target
		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target
	}

	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $locallibname
	Clean $libname
	define-append LOCAL_LIBS $locallibname

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $locallibname
	}
	if {$publish} {
		publish-lib $libname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects
	}
}

rule SharedLib {args} {
SharedLib ?--publish? ?--strip=<type>? ?--version=<ver>? ?--soversion=<ver>? ?--install=<dir>? basename source...

Creates a shared library from the given sources. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the shared library.

Bound variables: CCLD (from Linker), PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LD_FLAGS, LDFLAGS, SH_LDFLAGS, SH_SOEXT, SH_SOEXTVER, SH_SOPREFIX

The following options are supported:
  --publish              For compatibility. Note that shared libraries are always published. (see PublishLib)
  --install=<dir>        Install the shared library to the given directory (see InstallFile)
  --version=<ver>        A version for the shared library of the form n.n.n (1-3 parts)
  --soversion=<ver>      Override the soname version. Otherwise the first part of the version is used.
  --strip[=dynamic|none] Sets the strip type on installation. --strip means dynamic. omitted means none. (see InstallFile)
} {
	show-this-rule
	add-default-opts args
	set strip none
	getopt {--publish --strip:dynamic --version: --soversion: --install: basename args} args

	if {![info exists version]} {
		set version 0
	}
	set n 0
	foreach part [split $version .] {
		if {![string is integer -strict $part]} {
			set n -1
			break
		}
		incr n
	}
	if {$n < 0 || $n > 3} {
		build-error [warning-location "Not a valid shared library version number: $version"]
		return
	}

	# What names may our shared lib have?
	set nameinfo [list [get-define SH_SOEXTVER] $version %s [get-define SH_SOEXT]]
	set default_soversion $version
	if {$n > 1} {
		# If more that one part is given, the first one is the defaul soversion
		lassign [split $version .] default_soversion
		lappend nameinfo [get-define SH_SOEXTVER] $version
		lappend nameinfo [get-define SH_SOEXTVER] $default_soversion
	}

	set names {}
	set libname {}

	foreach {fmt version} $nameinfo {
		if {$fmt eq ""} {
			continue
		}
		set name lib$basename[format $fmt $version]
		if {$libname eq {}} {
			set libname $name
		}
		if {$name ni $names} {
			lappend names $name
		}
	}

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set locallibname [make-local $libname]
	set srcs [join $args]
	set libalias <lib>$basename
	ObjectCFlags $srcs [get-define SH_CFLAGS]

	set setsoname {}
	if {[get-define SH_SOPREFIX ""] ne ""} {
		if {![info exists soversion]} {
			set soversion $default_soversion
		}
		set soname lib$basename[format [get-define SH_SOEXTVER] $soversion]
		if {[info exists install] && [get-define SH_SOFULLPATH] ne ""} {
			set fullsoname [file-join $install $soname]
		} else {
			set fullsoname $soname
		}
		set setsoname [get-define SH_SOPREFIX]$fullsoname
	}

	define? CCLD [get-define CC]

	# Note: Do not link against local archive libs (LOCAL_LIBS)
	# XXX: Here we use $LDFLAGS to capture any user-specified link flags (.e.g. -mbig-endian).
	#      Assume that these are required both for shared libs and for executables.
	#      Any shared-library-only flags are in $SH_LDFLAGS.
	#      LinkFlags/LD_FLAGS are also used here (we assume they are appropriate)

	target $locallibname -inputs {*}$objects -depends [get-define PROJDEPS] -msg {note SharedLib $targetname} -do {
		run $CCLD $LD_FLAGS $SH_LDFLAGS $LDFLAGS -o $target $setsoname {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS -vars setsoname $setsoname
	Clean $locallibname

	# Only the fully versioned name is built in the local dir
	Phony libs $locallibname
	Clean $libname

	# Note: --publish is dummy. Shared libs always need to be published to be used
	# The reason is that it gets difficult to manage LD_LIBRARY_PATH or equalivalent.
	# If shared libraries are always published, a single definition of LD_LIBRARY_PATH=$PUBLISH/lib
	# will work for all shared libs
	incr publish

	if {$publish} {
		# Publish along with the various symlinks and create an alias
		publish-shared-lib $names $locallibname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects

		# Local executables link against this library
		UseLibs $basename
	}
	if {[info exists install]} {
		if {$strip ni {none dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		set opts {}
		if {$strip eq "dynamic"} {
			lappend opts --striplib
		}

		install-shared-lib {*}$opts $install $names $locallibname
	}
	return $libname
}

# If desired, this can be aliased to SharedLib in project.spec
alias Lib ArchiveLib

rule SharedObject {args} {
SharedObject ?--install=<dir>? ?--strip=<type>? target sources...

Builds a dynamically loadable shared object from the given sources.
For each source, the appropriate ObjectRule is used to generate the object file,
and these files are linked (along with any libraries) to create the loadable object.

Bound variables: CCLD (from Linker), SHOBJ_LDFLAGS (must be set appropriately),
                 PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables:  LD_FLAGS, LDFLAGS, SHOBJ_CFLAGS (must be set appropriately)

Note that sources are marked to be built with SHOBJ_CFLAGS via ObjectCFlags.

The following options are supported:
  --install=<dir>        Install the shared object to the given directory (see InstallFile)
  --strip[=dynamic|none] Sets the strip type on installation. --strip means dynamic. omitted means none. (see InstallFile)
} {
	show-this-rule
	add-default-opts args

	set strip none
	getopt {--install: --strip:dynamic target args} args

	set srcs [join $args]

	define? CCLD [get-define CC]

	# Must build objects with -fpic, etc.
	ObjectCFlags $srcs [get-define SHOBJ_CFLAGS]

	set localtarget [make-local $target]

	target $localtarget -inputs {*}[Objects $srcs] -depends [get-define PROJDEPS] -msg {note SharedObject $targetname} -do {
		run $CCLD $LD_FLAGS $SHOBJ_LDFLAGS -o $target {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS
	Clean $target
	Phony all $localtarget

	if {[info exists install]} {
		set opts --bin
		if {$strip ni {none dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		if {$strip eq "dynamic"} {
			lappend opts --striplib
		}
		InstallFile {*}$opts [file-join $install $target] $localtarget
	}
}

rule Objects {args} {
Objects source ...

Create an object file from each source file using the appropriate ObjectRule for each source.
Accepts object files (.o) and <lib> aliases in addition to source files and simply returns them.

Returns a list of (local) objects.

e.g.

  Objects file1.c file2.o file3.cc <lib>compat
} {
	show-this-rule
	set args [join $args]
	set objs {}
	foreach src $args {
		if {[string match <lib>* $src]} {
			lappend objs $src
		} else {
			lappend objs [Object [change-ext .o $src] $src]
		}
	}
	return $objs
}

rule Object {target src} {
Object obj src

Creates object 'obj' from source 'src' by using the appropriate ObjectRule, e.g. ObjectRule.c
for .c sources.
} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		if {[info commands ObjectRule$ext] eq ""} {
			build-error [warning-location "Don't know how to build Object from $src"]
			return $obj
		} else {
			set obj [ObjectRule$ext $obj $src]
			Clean $target
		}
	}
	return $obj
}

rule ObjectCFlags {srcs args} {
ObjectCFlags {sources} ...

Like CFlags, but instead of adding C_FLAGS for all subsequent rules, adds
C_FLAGS only to the objects created from the given list of source files.

Can also be used to apply directly to object files. e.g.

  ObjectCFlags {file1.c file2.o file3.cc} -O0
} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

rule CFlags {args} {
CFlags ...

Add the given flags to C_FLAGS (used in all subsequent ObjectRule.c)
e.g.  CFlags -DABC=7

Note that to pass a string value, it generally sufficient to quote it normally:

  CFlags -DVERSION="v1.0"

However if the value may contain spaces, use quote-if-needed. eg.

  CFlags [quote-if-needed {-DVERSION="processor v1.0"}]
} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

rule C++Flags {args} {
C++Flags ...

Add the given flags to CXX_FLAGS (used in all subsequent ObjectRule.cpp)

See CFlags
} {
	define-append CXX_FLAGS {*}$args
}

rule LinkFlags {args} {
LinkFlags ...

Add the given flags to LD_FLAGS (used in all subsequent Executable and SharedLib)
} {
	define-append LD_FLAGS {*}$args
}

rule Linker {linker} {
Linker prog

Defines the linker to use for subsequent Executable and SharedLib ($CCLD).
By default $CC is used. For C++ applications, it is typical to set:

  Linker $CXX
} {
	define CCLD $linker
}

rule UseLibs {args} {
UseLibs projlib ...

Identifies published project libraries from other directories that are required for
linking subsequent Executables, Shared Libraries and Shared Objects.

The libraries are both added as dependencies (via $PROJDEPS) and added to the link line
(via $PROJLIBS)

For non-project libraries (such as system libraries), see UseSystemLibs and LinkFlags
} {
	# Create/append to PROJLIBS (the link line)
	if {[get-define PROJLIBS] eq ""} {
		define PROJLIBS "-L[publish-path lib]"
	}
	define-append PROJLIBS [prefix -l $args]

	# Now the dependencies
	define-append PROJDEPS [prefix <lib> $args]
}

rule IncludePaths {args} {
IncludePaths ?--reset? ?--global? ?--build|--source? paths...

Arranges to search the given paths for header files.

The paths are added:
- to $INCPATHS for use by dynamic header dependency searching
- to CFlags ($C_FLAGS) as -I <path>
- to C++Flags ($CXX_FLAGS) as -I <path>

By default, the paths (relative to the current local directory) are
searched in both the source tree and the build tree, but this can
be changed by specifying --build or --source.

The following options are supported:
  --build         Search the paths only in the build tree
  --source        Search the paths only in the source tree
  --reset         INCPATHS, C_FLAGS, and CXX_FLAGS are reset to their default values,
                  before any IncludePaths invocations.
                  This can be useful to remove the implicit 'IncludePaths .'

  --global        Paths are considered to be from the top of the tree rather
                  than local (to the current dir) paths.

Note that normally only relative paths should be used, however adding an absolute
path (e.g. /usr/local/include) is possible, in which case the path is added as-is
and headers in that directory will then be included in dynamic dependency analysis.
} {
	show-this-rule

	getopt {--reset --build --source --global args} args

	if {$reset} {
		global tmakedrb
		# Reset INCPATHS, C_FLAGS and CXX_FLAGS to their defaults
		foreach i {INCPATHS C_FLAGS CXX_FLAGS} {
			define $i [dict get $tmakedrb $i]
		}
	}

	if {!$build && !$source} {
		# No options means both
		incr build
		incr source
	}

	if {$global} {
		set srcdir .
		set builddir [file-build .]
	} else {
		set srcdir [local-dir]
		set builddir [file-build [local-dir]]
	}

	foreach dir $args {
		set srcpath [file-join $srcdir $dir]
		set buildpath [file-join $builddir $dir]

		if {$srcpath in [get-define INCPATHS]} {
			dputs m "IncludePaths: Ignoring duplicate $srcpath"
			# Already have this one added, so ignore it
			continue
		}
		define-append INCPATHS $srcpath
		if {$source} {
			CFlags [prefix -I $srcpath]
			C++Flags [prefix -I $srcpath]
		}
		if {$build} {
			if {$source && $buildpath eq $srcpath} {
				# Normally buildpath would not equal srcpath, but
				# if an out-of-tree location is given (e.g. /usr/local/include)
				# then it will. No need to include twice.
			} else {
				CFlags [prefix -I $buildpath]
				C++Flags [prefix -I $buildpath]
			}
		}
	}
}

rule Load {args} {
Load ?--nocare? ?--config? filename

Reads a configuration file in one of two forms.
If --config is specified, the following form is expected:

  CONFIG_BOOL_VALUE=y (or m)
  CONFIG_STR_VALUE="string value"
  CONFIG_INT_VALUE=123

Otherwise a Tcl source file is expected to contain 'define' commands. e.g.

  define CONFIG_BOOL_VALUE
  define CONFIG_STR_VALUE "string value"
  define CONFIG_INT_VALUE 123

Unless --nocare is specified, the file must exist.

The symbols contained in the file are defined, and the file is marked
as a project dependency. This means that if the file changes, it is re-read.
It is possibly for the build to create/re-create this file, in which case the
parsing phase will be restarted.
} {
	show-this-rule

	getopt {--nocare --config filename} args

	# XXX: Should we allow loading an out-of-tree file?

	if {[is-target? $filename]} {
		set f [file-build $filename]
		dputs m "Load: $filename is a target => $f"
	} elseif {[file exists $filename]} {
		dputs m "Load: $filename is source"
		set f $filename
		lappend result $f
	} elseif {![is-cleaning?] && !$nocare} {
		build-fatal-error [warning-location "Error: Load $filename does not exist and is not a target"]
		tmake-exit 1
	}

	if {[info exists f] && [file exists $f]} {
		if {$config} {
			dputs m "load-config-file $f"
			load-config-file $f
		} else {
			dputs m "source $f"
			source $f
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	add-project-file $filename $nocare
}

rule UseSystemLibs {args} {
UseSystemLibs ...

Adds system libraries to be used when linking subsequent Executables, Shared Libraries and Shared Objects
via the $SYSLIBS variable.
Typical usage is:

  UseSystemLibs -ldl -lm
} {
	define-append SYSLIBS {*}$args
}

rule PublishIncludes {args} {
PublishIncludes ?--keepdir? name ...

Shorthand for:

  Publish ?--keepdir? include name ...
} {
	getopt {--keepdir args} args

	if {$keepdir} {
		Publish --keepdir include {*}$args
	} else {
		Publish include {*}$args
	}
}

rule PrecompiledHeader {header} {
PrecompiledHeader headerfile.h

Arranges for the given header file to be precompiled (to headerfile.gch) and included
when compiling subsequent C/C++ sources.

Note that this is a work-in-progress. It appears to work with gcc and clang.
} {
	show-this-rule

	set local [make-local $header]

	# Build the precompiled header
	ObjectRule.c $local.gch $local
	Clean $local.gch
	# Need to publish both of these to the same directory
	PublishIncludes $header $header.gch

	# Now add this as an included for for subsequent compilation
	# Should we be using -include $header or -include-pch?
	# Is the latter only a clang thing?
	CFlags -include $header
	#CFlags -include-pch [publish-path include]/$header.gch

	# And we need to make sources depend on this too
	define PRECOMPILED_HEADER [publish-dir include]/$header.gch
}

rule Test {args} {
Test --interp=<interp> --errok --chdir --quiet --nofork --stdout=<stdout.exp.file> --stderr=<stderr.exp.file> command args

Runs the given test command with the given arguments.

The following options are supported (all are optional):
  --interp  Built or external program required to run the test. Available as $interp
  --chdir   The test runs from the local (build) directory
  --stdout  A local file. The command output must exactly match the file for the test to pass
  --stderr  As per --stdout, but for the command stderr output.
  --quiet   Do not output a message with the test rule runs.
  --errok   Ignores the return code of the command. Normally a non-zero return code indicates failure.
  --nofork  The test is run in the foreground. Otherwise tests are always run as separate jobs.
} {
	show-this-rule

	getopt {--interp: --errok --chdir --quiet --nofork --stdout: --stderr: command args} args
	set testid [get-test-id]
	set depends {}
	set localcommand [make-local $command]

	set opts {}
	set deps {}
	set vars {}

	if {$chdir} {
		lappend opts -chdir
	}
	if {$nofork} {
		lappend opts -nofork
	} else {
		lappend opts -slow
	}
	if {$errok} {
		lappend vars errok 1
	}

	# If there is an interpreter, find it
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir -optional 1] dep filename

		# In this case, the command is a script - find it
		lassign [find-project-bin $command -chdir $chdir -optional 0] cmddep scriptpath
		set testcommand [list $filename $scriptpath {*}$args]

		if {$dep ne ""} {
			lappend deps $dep
		}
	} else {
		# Find the local or published command and add it to the command and deps
		lassign [find-project-bin $command -chdir $chdir -optional 0] dep filename

		set testcommand [list $filename {*}$args]
		lappend deps $dep
	}

	lappend vars testcommand $testcommand

	if {!$quiet} {
		lappend opts -msg [list note Test $testcommand]
	}

	# set up srcpath to allow the test command/script to find resources
	if {$chdir} {
		# We are in objdir/... and we need to find [local-dir] from src
		set srcdir [file-src-relative [local-dir]]
	} else {
		set srcdir [local-dir]
	}
	lappend vars SRCDIR $srcdir

	foreach i {stdout stderr} {
		if {[info exists $i]} {
			set path [set $i]
			lappend deps [make-local $path]
			lappend vars $i [file-join $srcdir $path]
		}
	}

	lappend vars publishlib [file-join [get-define TOPBUILDDIR] [publish-dir lib]]

	target [make-local $testid] -phony -depends $deps -vars {*}$vars {*}$opts -do {
		setup-test-env $publishlib $LD_LIBRARY_PATH
		run-test-command $testcommand
	} -getvars LD_LIBRARY_PATH

	Phony test [make-local $testid]

	return $testid
}

rule CopyFile {dest source} {
CopyFile dest source

Copies the source file to the destination file
} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg [list note Copy $dest] -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

rule InstallSymlink {args} {
InstallSymlink dest linktarget

Installs a symlink pointing to the given (relative) target

Adds the rule to the global 'install' target and adds the symlink to the list of files
to be uninstalled with 'uninstall'
} {
	show-this-rule

	getopt {dest linktarget} args

	set destfile [get-define DESTDIR]$dest
	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}

	# Note that we pass variable $dest purely so we can show a nice path in the message
	sym-link $destfile $linktarget -nocache -rootok -vars dest "$dest -> $linktarget" -msg {note InstallLink $dest}

	target install -depends $destfile
	add-clean uninstall $destfile

	return $destfile
}


rule InstallFile {args} {
InstallFile ?--strip|--striplib? ?--bin? dest source

Installs the given source file to the destination (file) relative to $DESTDIR

The following options are supported:
  --bin               Make the target executable
  --strip             Strip the target with $STRIP $STRIPFLAGS
  --striplib          Strip the target with $STRIP $STRIPLIBFLAGS

Adds the rule to the global 'install' target and adds the file the list of files
to be uninstalled with 'uninstall'

Note that the source can be an absolute path to install an external file.
} {
	show-this-rule

	getopt {--strip --striplib --bin --build dest src} args

	#puts "InstallFile $dest $src"

	set destfile [get-define DESTDIR]$dest
	if {$strip && $striplib} {
		build-error "Only one of --strip and --striplib can be specified"
	}
	set installopts {}
	if {$strip} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPFLAGS]"
	} elseif {$striplib} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPLIBFLAGS]"
	}
	if {$bin} {
		lappend installopts --bin
	}

	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}

	# Note that we pass variable $dest purely so we can show a nice path in the message
	if {[string match /* $src]} {
		target $destfile -nocache -rootok -vars dest $dest src $src installopts $installopts -msg {note Install $dest} -do {
			install-file {*}$installopts $target $src
		}
	} else {
		target $destfile -nocache -rootok -vars dest $dest installopts $installopts -inputs $src -msg {note Install $dest} -do {
			install-file {*}$installopts $target $inputs
		}
	}

	target install -depends $destfile
	# Should $src be built by default?
	set srcdep [get-define INSTALLDEPTARGET]
	if {$srcdep ne ""} {
		Depends $srcdep $src
	}

	# This file also needs to be uninstalled
	add-clean uninstall $destfile

	return $destfile
}

rule Install {args} {
Install ?--bin? ?--strip|--striplib? ?--keepdir? destdir file-spec...

A convenience wrapper around InstallFile to allow multiple files to be installed at once.
See InstallFile for more details.

Files are installed to (directory) 'destdir'.  'file-spec...' is a
list of file specifications for files to be installed. See 'File
specifications' above.

The following options are supported:
  --bin               Pass --bin to InstallFile
  --strip|--striplib  Pass --strip or --striplib to InstallFile
  --keepdir           Pass --keepdir to InstallFile
} {
	show-this-rule

	getopt {--bin --strip --striplib --keepdir destdir args} args
	set args [join $args]
	set opts {}
	if {$bin} {
		lappend opts --bin
	}
	if {$strip} {
		lappend opts --strip
	}
	if {$striplib} {
		lappend opts --striplib
	}

	set srcs {}
	foreach {dest src} [expand-filespec $destdir $args $keepdir] {
		lappend srcs $src
		InstallFile {*}$opts $dest $src
	}
	return $srcs
}

rule Clean {args} {
Clean ?--source? target ...

Adds the given targets to the list of files to be removed on 'tmake clean'

The following options are supported:
  --source       The file is relative to the source directory instead of the build directory
} {
	# DistClean also cleans these files
	DistClean {*}$args

	getopt {--src --source args} args

	set args [join $args]

	if {$source || $src} {
		add-src-clean [make-local clean] $args
	} else {
		add-clean [make-local clean] [make-local {*}$args]
	}
}

rule DistClean {args} {
DistClean ?--source? target ...

Adds the given targets to the list of files to be removed on 'tmake distclean'

The following options are supported:
  --source       The file is relative to the source directory instead of the build directory
} {
	getopt {--source --src args} args

	set args [join $args]

	if {$src} {
		user-notice purple [warning-location "Warning: DistClean --src is deprecated, use --source instead"]
	}
	if {$source || $src} {
		add-src-clean [make-local distclean] $args
	} else {
		add-clean [make-local distclean] [make-local {*}$args]
	}
}

rule Generate {args} {
Generate ?--interp=<interp>? ?--chdir? target generator inputs rules target-args...

A general purpose rule to create a target via a generator (program or script).

The arguments are as follows:
  --interp    Optional built or external program required to run the generator. Available as $interp
  --chdir     If specified, the generator runs from the local directory
  target      The target to generator. May be a list of one or more targets. Available as $target
  generator   The generator program or script. May be a local built target, a published built target
              (in which case the <bin> prefix is used), empty for none, or an external command (if none of the above).
              Unless empty, this is available as $script
  inputs      Local files that are inputs to the generator. Available as $inputs
  rules       A -do script that generates the target
  target-args Additional arguments to 'target'

The following is an example of a local, built generator.

  Executable mkindex mkindex.c
  Generate page_index.h mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex' were created in another directory and published with 'Executable --publish'
or 'PublishBin', we would use the following:

  Generate page_index.h <bin>mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex.rb' were a script that used a locally built version of 'ruby' to run, we would use:

  Generate --interp=<bin>ruby page_index.h mkindex.rb *.c {
    run $interp $script -o $target $inputs
  }

} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: --chdir target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script -chdir $chdir -optional 1] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	if {$chdir} {
		lappend args -chdir
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $targetname} {*}$args
	Clean $target
	return $localtarget
}

rule Depends {target args} {
Depends target target-args...

Creates a local target with the given additional target arguments.

e.g.

  Depends b.txt -inputs [make-local b.in] -do {
    cat $inputs >$target
  }
} {
	target [make-local {*}$target] -depends {*}$args
}

rule Phony {target args} {
Phony target target-args...

Creates a Phony, local target with the given additional target arguments.

See Depends
} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	user-notice purple [warning-location "Warning: LocalMakefile is deprecated and ignored"]
}

rule DefaultOptions {rule args} {
DefaultOptions <command> options...

e.g. DefaultOptions Executable --strip
e.g. DefaultOptions SharedObject --strip=dynamic

Allows default options to be supplied for commands.
Note that currently only Executable, SharedObject and SharedLib support DefaultOptions
} {
	set-default-opts $rule $args
}

rule DefaultTarget {name} {
DefaultTarget target

Sets the default (local) target.
i.e. when tmake is invoked with no options.
The default is 'all'
} {
	show-this-rule
	set-default-target $name
}

rule HostLibs {args} {
HostLibs ...

Like UseSystemLibs, but for host builds with HostExecutable.
Adds the given arguments to HOST_SYSLIBS
} {
	define-append HOST_SYSLIBS {*}$args
}

rule HostExecutable {target args} {
HostExecutable target sources ...

A very simple version of Executable for building host (as opposed to target) applications.

Bound variables: HOST_CFLAGS, HOST_SYSLIBS (from HostLibs)
Used variables: CC_FOR_BUILD (defaults to gcc)

Note: HostExecutable and HostLibs are stopgaps until separate build contexts are fully supported
} {
	set localtarget [make-local $target]

	set localtargetexe $localtarget[get-define HOST_EXEEXT]
	set targetexe $target[get-define HOST_EXEEXT]

	target $localtargetexe -inputs {*}[make-local {*}$args] -msg {note HostExecutable $targetname} -getvars HOST_CFLAGS HOST_SYSLIBS -do {
		run $CC_FOR_BUILD $HOST_CFLAGS -o $target $inputs $HOST_SYSLIBS
	} -dyndep {
		header-scan-regexp-recursive $local "" $CHDRPATTERN
	} {*}[target-alias $target $targetexe]

	set desttargetexe [file-join [publish-dir bin] $targetexe]
	hard-link $desttargetexe $localtargetexe -vars dest bin/$target -msg {note Publish $targetname} -alias <bin>[file tail $target]
	target $desttargetexe -add -do {
		chmodx-file $target
	}
	Clean $targetexe

	return $localtarget
}

rule ExternalBuild {user_spec} {
ExternalBuild build-specification

Simplifies integration of a project with it's own build system.

Supports configure, build, clean and distclean targets.

build-specification is a dictionary containing some or all of the following entries:

  configure          - Name of the configure script, or "" if none. [default: configure]
  configure_opts     - Additional options to configure [default: none]
  configure_targets  - Targets generated by 'configure' [default: none]
  build              - Command to build [default: make]
  build_opts         - Additional options to build [default: none]
  build_targets      - Non-library targets generated by 'make' [default: none]
  lib_targets        - Archive library targets generated by 'make', as a list of: libname filename ... [default: none]
  clean              - Command to clean [default: make clean]
  distclean          - Command to distclean [default: make distclean]

Notes:
- The build is done "out of tree", and configure must accept --host and --build
- CONFIGURE_HOST and CONFIGURE_BUILD must be defined
- Currently shared libaries are not supported
- Header files, binaries etc. should be published and installed as normal
- The only dependencies for the external project are:
  - The completion of the configure and build commands
  - The existence of the configure and build targets
  - The commands used to configure and build
- configure_opts and build_opts are expanded at build time, so they may include, e.g. [get-define]
} {
	# Set up the default behaviour
	set spec {
		configure {configure}
		configure_opts {}
		build {make}
		build_opts {}
		clean {make clean}
		distclean {make distclean}
		configure_targets {}
		build_targets {}
		lib_targets {}
	}
	foreach {k v} $user_spec {
		if {$k eq "#"} {
			continue
		}
		if {![exists spec($k)]} {
			user-error "ExternalBuild doesn't recognise $k=$v"
		}
		set spec($k) $v
	}

	# --- configure ----
	if {$spec(configure) ne ""} {
		lassign [find-project-bin $spec(configure) -chdir 1] script_dep script_filename
		set configure_targets [list .configure {*}$spec(configure_targets)]

		set configure_opts [list --host=[get-define CONFIGURE_HOST] --build=[get-define CONFIGURE_BUILD] {*}[subst $spec(configure_opts)]]

		Depends $configure_targets [make-local $spec(configure)] -msg [list note External [make-local configure]] -do {
			run $script_filename $configure_opts
			writefile .configure "done"
		} -vars script_filename $script_filename configure_opts $configure_opts -chdir

		# Assume .distclean can only run if configured
		Phony .distclean -do {
			if {[file exists .configure]} {
				run $cmd
			}
		} -vars cmd $spec(distclean) -chdir
		Depends distclean [make-local .distclean]
		DistClean .configure
	} else {
		# Create a dummy configure step
		Depends .configure -do {
			writefile $target "done"
		}
		DistClean .configure
	}

	# --- build ----
	set build_targets [list .build {*}$spec(build_targets)]
	foreach {basename lib} $spec(lib_targets) {
		lappend build_targets $lib
	}
	set build_opts [subst $spec(build_opts)]

	Depends $build_targets [make-local .configure] -msg [list note External [make-local build]] -do {
		run $cmd $build_opts
		writefile .build "done"
	} -vars cmd $spec(build) build_opts $build_opts -chdir

	# Assume .clean can only run if configured
	Phony .clean -do {
		if {[file exists .configure]} {
			run $cmd
		}
	} -vars cmd $spec(clean) -chdir
	Depends clean [make-local .clean]
	Clean .built

	# --- libs ----
	foreach {basename lib} $spec(lib_targets) {
		set libname [file tail $lib]
		set libalias <lib>$basename
		set liblocal [make-local $lib]

		Phony libs $liblocal

		# Can't use publish-lib here because the lib may be in a subdir
		hard-link [publish-prefix lib]$libname $liblocal -msg {note Publish $targetname} -alias $libalias
		#publish-lib $libname $libalias
	}

	# XXX support for shared libs ...
}

rule Configure {args} {
Configure ?--configure=configscript? ?--output=filename? ?--logfile=logfile? {targets} {inputs} {do rules} ...

Runs an autoconf-compatible ./configure (defaults to "configure") to produce the given
targets. The given inputs (if any) are added as dependencies.
Runs the "do" rules, with the $configure variable set to the name of the configure script.

Additional 'target' arguments may be appended.

Typical usage for autoconf is:

  Configure --output=config.out --logfile=config.log include/config.h {} {
    run $configure >config.out
  }

The following options are supported:
  --output=filename    The output from the configure command is assumed to be written to 'filename',
                       and it is displayed if the configure fails.
  --logfile=filename   'Distclean --source $logfile' is added to delete the logfile on distclean.
} {
	getopt {--output: --logfile: --configure: targets inputs rules args} args

	if {![info exists configure]} {
		set configure "configure"
	}
	set inputs [make-local $configure {*}$inputs]
	set opts {}

	if {[info exists output]} {
		lappend opts -onerror "puts \[readfile \$build/$output\]"
		Clean $output
	}
	if {[info exists logfile]} {
		DistClean --source $logfile
	}

	Depends $targets $inputs -msg {note Configure $targetname} -fatal -vars configure $configure -do $rules {*}$opts {*}$args
	DistClean $targets
}

rule Autosetup {args} {
Autosetup ?--verbose? {targets} ...

Runs an autosetup-compatible configure to produce settings.conf plus the additional given targets.

Be sure to add something similar to the following to your auto.def file:

  use tmake
  ...
  make-tmake-settings [get-env BUILDDIR objdir]/settings.conf {[A-Z]*} *dir lib_*

The following options are supported:
  --verbose  Normally output is sent to config.out and only shown on error,
             but --verbose causes the output to be sent directly to stdout instead.

Bound variables: CONFIGURE_ENV is checked for changes to force configure to rerun
Used variables: AUTOREMAKE is the configure command to run
} {
	getopt {--verbose targets args} args

	set opts {}
	set redirect {}

	# We use [set redirect] in the -do to avoid rebuilding settings.conf
	# if just the verbosity setting changes
	if {!$verbose} {
		set redirect >[file-build config.out]
		lappend opts --output=config.out
	}

	Configure {*}$opts --logfile=config.log [list settings.conf {*}$targets] auto.def {
		# $CONFIGURE_ENV
		run $AUTOREMAKE [set redirect]
	} -getvars CONFIGURE_ENV -nofork -vars redirect $redirect {*}$args

	# If not configured, configure with default options
	# Note that it is expected that configure will normally be run
	# separately. This is just a convenience.
	# project.spec can redefine AUTOREMAKE if required
	define? AUTOREMAKE configure
	Load settings.conf
}

# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall -rootok

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans

DistClean .makecache

# Invoked manually
Phony clean-orphans -do {
	do-delete-orphans [get-orphan-targets]
	# Now remove the trash
	if {[file exists .trash]} {
		note Clean .trash
		file delete -force .trash
	}
}

# @delete-orphan-files files ...
#
# This callback is invoked to delete orphans
# This version replaces the builtin version.
# Instead of deleting files immediately, orphans are moved into
# the .trash directory. This directory is only removed via the
# 'clean', 'distclean' or 'clean-orphans' targets.
proc delete-orphan-files {args} {
	# XXX can't create .trash if it doesn't exist and we are root 
	file-mkdir -rooterr .trash
	foreach file $args {
		if {[file-type $file] in {file link}} {
			set trashfile .trash/[string map {/ _} $file]
			# Can't simple use file rename -force in case the files are hard links
			file delete $trashfile
			file rename $file $trashfile
		}
	}
}
}

# ==================================================================
# ENTRY POINT
# ==================================================================

set rc [catch -signal {
	set rc [catch {callmake $argv} msg opts]
	if {$rc} {
		if {$rc == 1 && [exists -command error-stacktrace]} {
			user-notice colerror [error-stacktrace $msg $opts(-errorinfo)]
		} elseif {$msg ne ""} {
			user-notice colerror $msg
		}
		set tmake(exitcode) 1
	}

	# We do this even on error
	if {$tmake(numtargets) || $tmake(showtime) || $tmake(verbose)} {
		set elapsed [expr {([clock millis] - $tmake(start)) / 1000.0}]
		if {!$tmake(quiet)} {
			pputs colnote "Built $tmake(numtargets) of [num-nonphony-targets] target(s) in [format %.2f $elapsed] seconds"
		}
	}
	if {$tmake(usehashes)} {
		dputs T "Time spending hashing sources: [format %.2f $($tmake(hashtime) / 1e6)] seconds"
	}
	# This is to support unit testing
	if {[env TMAKE_ERROR ""] eq "late"} {
		fake-an-error
	}
	if {$tmake(exitcode)} {
		tmake-exit $tmake(exitcode) "*** Error: Targets failed to build"
	}
} msg opts]

switch [info returncodes $rc] {
	"signal" {
		# This must be SIGPIPE since we catch/ignore other errors
		set tmake(exitcode) 1
	}
	"error" {
		stderr puts $msg
	}
}

tmake-exit $tmake(exitcode)
