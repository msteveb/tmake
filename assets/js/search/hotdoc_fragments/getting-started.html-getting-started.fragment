fragment_downloaded_cb({"url":"getting-started.html#getting-started","fragment":"Getting Started\nIt is easiest to start using tmake with an existing C or C++ project.  Consider the following simple project:\napi.c and api.h provide an implementation of a simple API and test-api.c\nprovides unit testing of that API. We want to build a library (libapi.a), compile test-api.c, link it\nagainst the library and run it. While it is easy to write a build specification for this project, let's make\nuse of tmake --genie to create a starting build definition.\ntmake --genie notices that some C sources and header files exist and that no existing\nbuild files exist. So it creates a trivial, empty project.spec. And the following build.spec\nNote that tmake --genie has identified that api.c is library source and needs to be built\ninto a library. The current directory name is used as the default library name, thus \"api\".\nNext we see that tmake --genie noticed that test-api.c has main() and begins with \"test\" so\nis likely a test. Therefore it builds the executable with \"--test\".\nFinally we see that api.h may need to be a published as a public header file, but this\nis commented out. We can uncomment this. And removing the comments at the top, here is our final build.spec\nOne of the hallmarks of tmake is the compact build descriptions with no boiler plate, quoting or other noise. Let's build it.\nBy default, tmake builds the all target of the current directory. Executable and Lib targets are automatically added\nas dependencies of the all target, so libapi.a and test-api are built by default. Unit tests are not run by default, but we can\nrun them now.\nNo output means the test succeeded. Now what has been produced?\nWe see that everything is built into the objdir directory (this is the default)\nleaving the source directory unchanged. Like all modern build systems it is important\nto keep the build artifacts and the sources separate. Let's look at how the outputs were arranged.\nWe can see that apart from the objdir/publish directory, everything\nmirrors the source directory, except with the objdir directory.\nThe publish directory acts as a common staging area for include\nfiles and libraries that are shared between directories so that we\ncan change the source location easily without affecting other parts\nof the project.  We can also see the detailed commands that tmake\nran for the build.  First let's clean out the build.\nAnd build again with -v\nNow we can see the commands that were used.  So what if we want to\ndo a debug build? We can add some flags to the C compiler with\nCFlags\nBy adding CFlags at the top of the file, these flags apply to any\nsubsequent rules in this build.spec Now if we build again, tmake\nnotices that the build commands have change and so runs the appropriate\nrules.\nNow let's dig into the rules that are driving the build.\nWe are using the high level build commands from the built-in\nrulebase.default in our build specification. Taking a look at one of these rules:\nWe can see that Executable takes a number of options and parameters\nthat determine how the low level target rules are created. Let's\nuse tmake --targets and tmake --find to see what it generated.\nFirst let's see all the final (non-phony) targets that tmake knows\nabout.\nThese are all the targets that can be built in objdir/. So let's examine the test-api target:\nHere we can see that Executable has generated a low level target rule to build test-api,\nwith dependencies on test-api.o and libapi.a and the command line:\nHere, $target becomes test-api and $inputs becomes test-api.o. The\nvariables CCLD, LD_FLAGS, PROJLIBS and SYSLIBS are \"bound\" variables.\nThis means that the target rule captures the values of these variables\nwhen the rule is defined.  By contrast, LDFLAGS is an \"unbound\"\nvariable. It is a global variable that has the same value across\nall rules.\nNow imagine that we would like to restructure our project to move api.c and api.h\ninto their own subdirectory, lib/, and test-api.c into it's own directory, tests.\nHow would this affect the build rules?  First let's move the sources.\nNow let's create lib/build.spec\nThis is just the relevant lines moved to lib/.  Similarly for\ntests/build.spec. Here the only change we need to make here is that\ntests needs to be told to use libapi. Previously this was automatically\nhandled because the library was defined earlier in the build.spec.\nSo:\nWe now have:\nNow let's build:\nAnd the outputs were created:\nNotice how we didn't need to do a clean or remove\nany existing files. tmake noticed that the previous targets,\ntest-api, test-api.o, libapi.a and api.o were no longer\ntargets and so these outputs were automatically removed.\nIn their place were build tests/test-api.o, tests/test-api,\nlib/libapi.a and lib/api.o\nAlso notice that now publish/lib/libapi.a has been created.\nIn order for test-api to find the library, it is published\ninto the known location, publish/lib directory. This is what\nthe --publish option to Lib did.\nNow a couple of other things we can do.\nImagine we are working on test-api.c. Let's cd into the tests directory.\nAnd now we simulate changing api.c\nLet's rebuild. What will happen?\ntmake notices that lib/api.a is required by test-api and lib/api.a depends\non lib/api.c, so that is automatically recompiled, followed by recreating the library\nand finally tests-api is relinked.\nBy default, tmake will build the all target in the current directory, but if this\ndepends on targets in other directories, those will be automatically built as required.\nWe can also use one of the various debug flags to follow along and understand\nwhy tmake is building each target. If we had done the following and used tmake -dg we would see.\nInitially we see that the default target is tests/all, and by following dependencies, there is ultimately\na dependency on lib/api.o via the chain:\nlib/api.o depends on lib/api.c which has changed, and so lib/api.o is rebuilt.\nThis process contains where now lib/libapi.a depends on lib/api.o which has changed and so it is rebuilt.\nThis continues until the initial target is finally built.\nAn alternative approach is to use tmake -dG. Instead of only showing the reasons why targets were build,\nthis shows each target as it is attempted via the dependency tree.\nLet's also take a look at a phony target. Targets line all and clean are phony targets.\nThey are like \"actions\" that can have dependencies but don't have any corresponding outputs.\nTest targets are an example of phony targets.\nFirst let's look at the local test target.\nWe see that tests/test is a phony target that depends on test/tests#1.\nLet's look at that one.\nThis is the test target that was generated by Executable --test.\nWe can see that it depends on tests/test-api (the executable) and\nhas the bound variable testcommand=objdir/tests/test-api.\nThus the command that will be run is:\nThis is part of the default rulebase (rulebase.default).\nWe can find out more about this command with:\nAnd searching for run-test-command we see:\nIn fact, Executable --test prog prog.c is shorthand for:\nAs a final note, let's see how publish libraries are handled.\nHere we see that there are two rules associated with libapi.a\nThe first creates lib/libapi.a from lib/api.o\nSecondly, publish/lib/libapi.a depends on lib/libapi.a and\nthis rule creates a symlink to the library.\nAlso note that the library as the \"alias\" api.\nThis alias means that the UseLibs command can add a dependency on api\nand this will automatically resolve to publish/lib/libapi.a which in turn\ndepends on lib/libapi.a\nUsing this approach with aliases makes it easy to change between shared\nand archive libraries along with some other features. These will be covered\nin a later topic on aliases.\n"});