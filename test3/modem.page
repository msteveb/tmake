label "Modems"
title "Modem Status"
help {Displays the current status of the modems}

accesslevel status

storage none

bar "Modems Status"

text {
	display {
		package require table
		package require gmstatus
		set base [root]/supervisory

		proc map_if_afc {value} {
			config_load
			# XXX: Modems might have different channel widths!
			# What about hot standby mode?
			set channelwidth [config_get modem${::MODEM}.channelwidth]
			# XXX: Should these symbol rates be somewhere common?
			set symbolrate [dict get {6875 5 13750 10 27500 20 40000 32 55000 40} $channelwidth]
			expr {$value * $symbolrate}
		}

		foreach i {1 2} {
			set exists($i) [expr {[config_get modem${i}.enabled] && [readfile $base/modem$i/valid 0]}]
		}

		# XXX: There is a lot of overlap here. Do the same as the overview page
		#      and use gmstatus

		# Variables under above path which we are interested in displaying.
		# Each variable is defined with an enum list.
		set tablespec {
			frame_lock			{"Frame Lock" {enum {0 "Not Locked" 1 Locked}} 1}
			timing_lock			{"Timing Lock" {enum {0 "Not Locked" 1 Locked}} 1}
			phase_lock			{"Tx Phase Lock" {enum {0 "Not Locked" 1 Locked}} 1}
			tx_lo_lock			{"Tx LO Lock" {enum {0 "Not Locked" 1 Locked}} 1}
			if_loopback_enab	{"IF Loopback" {enum {0 Disabled 1 Enabled}} 0}
			tx_modulation		{"Tx Modulation" {eval {map_modulation $value}}}
			rx_modulation		{"Rx Modulation" {eval {map_modulation $value}}}
			rx_signal_qual		{"Rx Signal Quality"}
			temperature			{"Temperature" {format "%d\xc2\xb0C"}}
			n48vdc_input1		{"-48VDC Input 1" {expr {$value/1000.0} format "%.1fV"}}
			n48vdc_input2		{"-48VDC Input 2" {expr {$value/1000.0} format "%.1fV"}}
			n48vdc_input3		{"-48VDC Input 3" {expr {$value/1000.0} format "%.1fV"}}
			fan1_running		{"Fan 1 Running" {enum {0 No 1 Yes}} 1}
			fan2_running		{"Fan 2 Running" {enum {0 No 1 Yes}} 1}
		}
		if {[cgi auth role] in {factory support}} {
			lappend tablespec {*}{
				firmware_type		{"FPGA Firmware Type"}
				timing_loop			{"Timing Loop Voltage" {expr {$value/1000.0} format "%.1fV"}}
				lo_loop				{"LO Loop Voltage" {expr {$value/1000.0} format "%.1fV"}}
				rx_if_agc			{"Receive IF Cable AGC" {expr {$value/1000.0} format "%.1fV"}}
				tx_clock_sel		{"Transmit Clock"}
				rx_clock_sel		{"Receive Clock"}
				rx_if_afc			{"Receive IF AFC" {eval {map_if_afc $value} format "%dkHz"}}
				rx_adc_alc			{"Receive ADC ALC"}
				1v2rail_ok			{"1.2V Rail OK"}
				2v5rail_ok			{"2.5V Rail OK"}
				3v3rail1_ok			{"3.3V Rail #1 OK"}
				3v3rail2_ok			{"3.3V Rail #2 OK"}
			}
		}

		# Populate the table data as a list of label, attrs, class, value, attrs
		set tabledata {}
		foreach {field spec} $tablespec {
			lassign $spec label mapping expected

			lappend tabledata $label

			# Iterate over each modem
			foreach i {1 2} {
				set ::MODEM $i
				if {$exists($i)} {
					if {[string match ".*" $field]} {
						# A synthetic value
						set val $i
					} else {
						set val [readfile $base/modem$i/$field -]
					}
				} else {
					set val -
				}
				set attrs {}
				if {$val ne "-"} {
					if {$expected ne "" && $val ne $expected} {
						lappend attrs class=alarmon
					}
					set val [mapvalue $val $mapping]
				}

				lappend tabledata $val $attrs
			}
		}

		# Now display the table
		set tb [table class=anytable]

		$tb hdr
		$tb val "" class=attribute
		$tb val "Modem 1" class=rounded
		$tb val "Modem 2" class=rounded

		foreach {label val1 attrs1 val2 attrs2} $tabledata {
			$tb dat class=[expr {[incr rownum] % 2 ? "row1" : "row2"}]
			$tb val $label class=label
			$tb val $val1 {*}$attrs1
			$tb val $val2 {*}$attrs2
		}
		$tb write
	}
}

auto_refresh_page

# vim: se ts=4 sw=4 noet:
