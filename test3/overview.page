label "Overview"
title "Overview"
summary "Overview"

accesslevel status

storage none

bar "System Overview"

init {
	proc is_valid_field {list dict} {
		foreach l $list {
			if {$dict($l) == 0} {
				return 0
			}
		}
		return 1
	}
}

field name {
	storagename system.id
	storage custom
	label "Site Name"
	type text
	default "Unknown"
}

field version {
	label "Firmware Version"
	display {
		cgi set $field [readfile [root]/etc/version ?]
	}
}

field time {
	label "Time"
	display {
		set val [clock format [clock seconds]]
		lassign [readfile [root]/proc/uptime 0] uptime loadavg

		lassign [decompose_int [expr {int($uptime)}] {60 60 24}] secs mins hours days

		if {$days} {
			set uptimestr [format "%d days, %2d:%02d" $days $hours $mins]
		} elseif {$hours} {
			set uptimestr [format "%2d:%02d" $hours $mins]
		} elseif {$mins > 1} {
			set uptimestr [format "%d mins" $mins]
		} elseif {$mins == 1} {
			set uptimestr "1 min"
		} else {
			set uptimestr [format "%d secs" $secs]
		}

		cgi set $field "$val (up $uptimestr)"
	}

	default unknown
}

bar -std "Link Overview"

text {
	display {
		package require table
		package require gmstatus

		set tablespec {
			{config modem.mode} {
				"Link Mode" {enum {0 "Hot Standby" 1 "Independent"}}
			}
			{file /supervisory/modctrl/comms_ok} {
				"Supervisory Comms" {eval {map_show_alarm $value 1} enum {0 "Not Established" 1 "Established"}}
			}
			{modem -} {
				"Modem Status" {eval {map_modem_status $value}}
			}
			{status rfvalid modemvalid} {
				"ODU Status" {eval {map_show_alarm $value 1} enum {0 "Comms Failure" 1 OK -1 "Mismatch"}}
			}
			{modem - modemvalid} {
				"Tx Status" {eval {map_tx_status $value}}
			}
			{status txpower {modemvalid modemactive} rfvalid} {
				"Tx Power" {format "%.1fdBm"}
			}
			{status txmod {modemvalid modemactive}} {
				"Tx Modulation" {eval {map_modulation $value}}
			}
			{modem - modemvalid} {
				"Rx Status" {eval {map_rx_status $value}}
			}
			{status rxpower modemvalid rfvalid} {
				"Rx Power" {format "%.1fdBm"}
			}
			{status rxmod {modemvalid modemactive}} {
				"Rx Modulation" {eval {map_modulation $value}}
			}
			{status ber {modemvalid modemactive}} {
				"BER Estimate" {}
			}
			{file /supervisory/errors/per} {
				"PER" {}
			}
		}

		set ms(1) [get_modem_status 1]
		set ms(2) [get_modem_status 2]

		# Create a new table
		set tb [table class=anytable]

		$tb hdr
		$tb val "" class=attribute
		$tb val "Link 1 (Left)" class=rounded
		$tb val "Link 2 (Right)" class=rounded

		foreach {fieldinfo spec} $tablespec {
			lassign $fieldinfo type field dep_ignore dep_fail
			lassign $spec label mapping
			$tb dat class=[expr {[incr rownum] % 2 ? "row1" : "row2"}]
			$tb val $label class=label

			# Iterate over each link
			foreach i {1 2} {
				map_attr_init

				set d $ms($i)
				set val "-"
				switch $type \
					file {
						set val [readfile [root]$field -]
					} \
					status {
						if {[info exists d($field)]} {
							set val $d($field)
						}
					} \
					config {
						set val [config_get $field]
					} \
					modem {
						set val $i
					}

				if {![is_valid_field $dep_ignore $d]} {
					# Ignore this field
					set val "-"
				}

				set val [mapvalue $val $mapping]
				if {$val ne "-" && ![is_valid_field $dep_fail $d]} {
					map_attr_add failed
				}

				if {$type ne "modem" && $type ne "status"} {
					# Global values stretch across both columns
					$tb val $val {*}[map_attr_get class] colspan=2
					break
				}
				$tb val $val {*}[map_attr_get class]
			}
		}
		# Now write the table
		$tb write
	}
}

auto_refresh_page

# vim: se ts=4:
