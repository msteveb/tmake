label "Plans"
title "Channel Plans"
help {View standard channel plans and configure custom plans}

accesslevel install

storage none

head {
<style>
tr.elemtable th { white-space: normal; }
tr.elemtable td { white-space: nowrap; }
</style>
}

init {
	set base [root]
	package require common
	package require channels
	set freqfmt "%g"
	set freqscale 1000000.0
	set chanscale 1000.0
	set baseconf $base/etc/channels.conf
	set custconf $base/etc/config/channels-custom.conf

	# Delete a channel plan
	proc delete_plan {} {
		global custconf
		# Delete the selected plan
		channels_load $custconf
		set id [cgi get id]
		set plan $::channels_by_id($id)
		unset ::channels_by_id($id)
		channels_save $custconf
		cgi success "Plan \"$plan(name)\" deleted"
		cgi vars discard
	}

	# Add a channel plan
	proc add_plan {id plan} {
		global custconf
		set plan(id) $id
		channels_clear
		catch {channels_load $custconf}
		set added 0

		# Test if new plan or existing
		if {[lsearch $::channels_id $id] < 0} {
			lappend ::channels_id $id
			set added 1
		}

		set ::channels_by_id($id) $plan
		channels_save $custconf

		if {$added} {
			cgi success "Plan \"$plan(name)\" added"
		} else {
			cgi success "Plan \"$plan(name)\" modified"
		}
	}

	# Set custom plan with a highlighted row
	proc setrowstatus {field want_edit_mode} {
		if {[cgi mode std]} {
			if {[cgi get type] ne ""} {
				cgi addattrs -container class="customplan"
			}
		} elseif {$want_edit_mode} {
			display_field_help
		}
	}
}

bar "Channel Plans"

text {
	display display_page_help
}

table {
	field id {
		label "Id"
		stdmode hidden
		editmode hidden
	}
	field type {
		label "Type"
		stdmode hidden
		editmode hidden
	}
	field name {
		label "Channel Plan Name"
		help "Name of the plan"
		editmode size=80
		display {
			setrowstatus $field 1
		}
	}
	field rfutype {
		label "RFU Type"
		help "Type of RFU this plan applies to"
		display {
			if {[cgi mode std]} {
				setrowstatus $field 1
			} else {
				display_field_help display {
					html eval div class=elemvalue {
						cgi_select_list $field [cgi get $field] $rfutypes
					}
				}
			}
		}
	}
	field nomwidth {
		label "Nominal Width (MHz)"
		help "Nominal frequency width (MHz)"
		display {
			if {[cgi mode std]} {
				setrowstatus $field 1
			} else {
				display_field_help display {
					html eval div class=elemvalue {
						cgi_select_list $field [cgi get $field] $nomwidths
					}
				}
			}
		}
	}
	field freq {
		label "Frequency (GHz)"
		help "Frequency (GHz)"
		display {
			setrowstatus $field 1
		}
	}
	field width {
		label "Channel Width (MHz)"
		help "Frequency width (MHz)"
		display {
			setrowstatus $field 1
		}
	}
	field first {
		label "First Channel"
		help "First channel number"
		display {
			setrowstatus $field 1
		}
	}
	field num {
		label "# of Channels"
		help "Number of channels after first"
		display {
			setrowstatus $field 1
		}
	}
	field sep {
		label "Tx/Rx Separation (Mhz)"
		help "Frequency separation (MHz)"
		display {
			setrowstatus $field 1
		}
	}
	button copy {
		label Copy
		editmode none
		stdmode image
		display {
			if {[cgi auth access $page] < 2} {
				cgi return done
			}
			setrowstatus $field 0
		}
		submit {
			# Copy the selected plan
			channels_load $baseconf
			catch {channels_load $custconf}
			set plan $::channels_by_id([cgi get id])

			# Chop off any custom portion from the name
			regsub { *custom-[0-9]*$} $plan(name) {} plan(name)

			# Make new custom id and add new plan
			set id "custom-[expr [cgi get hi_id] + 1]"
			append plan(name) " $id"
			add_plan $id $plan
		}
	}
	button modify {
		label Edit
		editmode none
		stdmode image
		setmode edit
		display {
			if {[cgi get type] eq "" || [cgi auth access $page] < 2} {
				cgi return done
			}
			setrowstatus $field 0
		}
	}
	button delete {
		label Delete
		editmode none
		stdmode image
		display {
			if {[cgi get type] eq "" || [cgi auth access $page] < 2} {
				cgi return done
			}
			setrowstatus $field 0
		}
		submit {
			delete_plan
		}
	}
}

button submit {
	label Submit
	stdmode none
	submit {
		# Valid plan name
		set name [cgi get name]

		if {$name eq ""} {
			cgi error "Must enter a plan name" name
		}

		# Valid RFU Type
		set rfutype [cgi get rfutype]
		set band -1
		set subband -1

		if {$rfutype eq ""} {
			cgi error "Must enter a RFU type" rfutype
		} else {
			foreach {type rfuname} $::rfu_types {
				if {$rfuname eq $rfutype} {
					lassign [split $type ,] band subband
				}
			}

			if {$band < 0} {
				cgi error "Unknown RFU Type \"$rfutype\"" rfutype
			}
		}

		set plan(name) $name
		set plan(band) $band
		set plan(subband) $subband

		proc validate {field type value loval hival scale fmt} {
			if {[catch {set value [format $fmt $value]}]} {
				cgi error "Value must be a $type number" $field
				return 0
			}

			if {$loval ne "-" && $value <= $loval} {
				cgi error "Value must be > [format $fmt $loval]" $field
				return 0
			}

			if {$hival ne "-" && $value > $hival} {
				cgi error "Value must <= [format $fmt $hival]" $field
				return 0
			}

			cgi set $field [expr {int($value * $scale)}]
			return 1
		}

		# Validate other fields
		foreach f [lrange $::channels_fields 4 end] {
			switch $f {
				nomwidth {lassign "float $chanscale $freqfmt" type scale fmt}
				freq {lassign "float $freqscale $freqfmt" type scale fmt}
				width {lassign "float $chanscale $freqfmt" type scale fmt}
				sep {lassign "float $chanscale $freqfmt" type scale fmt}
				default {lassign "int 1 %d" type scale fmt}
			}

			validate $f $type [cgi get $f] 0 - $scale $fmt
			set plan($f) [cgi get $f]
		}

		if {[cgi get id] eq ""} {
			# Adding a new channel, so give it a unique id
			cgi set id "custom-[expr {[cgi get hi_id] + 1}]"
		}


		# Only store if no errors
		if {![cgi inerror]} {
			add_plan [cgi get id] $plan
		}
	}
}

button deleteplan {
	label Delete
	stdmode none
	display {
		if {[cgi get add]} {
			cgi return done
		}
	}
	submit {
		delete_plan
	}
}

button cancel {
	label Cancel
	stdmode none
}

field hi_id {
	storage page
	stdmode hidden
	editmode hidden
}

field add {
	storage page
	stdmode hidden
	editmode hidden
}

button new {
	label "New Plan"
	editmode none
	setmode edit
	submit {
		cgi set add 1
	}
}

display {

	# Scale a given value to given format for display
	proc scalefmt {value scale format} {
		return [format $format [expr $value/$scale]]
	}

	if {[cgi mode edit]} {

		# Build select list for RFU types
		foreach {type rfuname} $::rfu_types {
			lappend rfutypes $rfuname $rfuname
		}

		# Build select list for nominal frequency widths
		channels_load $baseconf

		foreach {id info} $::channels_by_id {
			set val [scalefmt $info(nomwidth) $chanscale $freqfmt]
			set wnames($val) $id
		}

		# Sort comparison function for floats
		proc sortfloat {val1 val2} {
			return [expr int($val1 - $val2)]
		}

		foreach width [lsort -command sortfloat [array names wnames]] {
			lappend nomwidths $width $width
		}

		channels_clear
		return
	}

	proc loadchans {fname} {{row -1}} {
		global chanscale freqscale freqfmt
		channels_clear
		cgi set hi_id 0
		if {[catch {channels_load $fname}]} {
			return
		}

		if {![regsub {^.*-(.*)\..*$} $fname {\1} type]} {
			set type ""
		}

		set hi_id 0
		foreach {id info} $::channels_by_id {
			cgi row [incr row]
			cgi set type $type
			cgi set id $id

			set rfutype "-unknown-"
			catch {set rfutype $::rfu_types($info(band),$info(subband))}
			cgi set rfutype $rfutype

			foreach f [lrange $::channels_fields 3 end] {
				cgi set $f [switch $f {
					nomwidth {format [scalefmt $info($f) $chanscale $freqfmt]}
					freq {format [scalefmt $info($f) $freqscale $freqfmt]}
					width {format [scalefmt $info($f) $chanscale $freqfmt]}
					sep {format [scalefmt $info($f) $chanscale $freqfmt]}
					default {format $info($f)}
				}]
			}

			if {[regsub {^custom-} $id {} idnum]} {
				if {$idnum > $hi_id} {
					set hi_id $idnum
				}
			}
		}

		cgi set hi_id $hi_id
	}

	loadchans $baseconf
	loadchans $custconf
	cgi set add 0
}
