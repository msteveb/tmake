label "RF/ODU"
title "RF/ODU Status"
help {Displays the current status of the RF Outdoor Units}

accesslevel status

storage none

bar "RF/ODU Status"

text {
	display {
		package require table
		set base [root]/var

		proc map_lock {value} {
			set result {}
			foreach {i name} {1 tx 2 rx 4 if} {
				if {($value & $i) == 0} {
					lappend result $name
				}
			}
			if {$result eq ""} {
				lappend ::attrs class=alarmon
				return "- unlocked -"
			}
			join $result " "
		}

		# REVISIT: Should map band, subband based on channels.conf, but for now hard code them here
		# REVISIT: Should also show tpc_set or rf?.txpower.tmp (if set)
		set tablespec {
			swserial		{"Firmware Version"}
			hwserial		{"Hardware Serial #"}
			lock			{"VCO Lock" {eval {map_lock $value}}}
			tx_power		{"TX Power" {append "dBm"}}
			rx_power		{"RX Power" {append "dBm"}}
			odu_temp		{"Temperature" {append "\xc2\xb0C"}}
			rx_ifbw			{"Filter" {append MHz}}
			hw_freq_band    {"Freq Band" {enum {0 8GHz 1 11GHz 2 18GHz 3 22GHz 4 10.5GHz}}}
			hw_sub_band     {"Freq Sub Band"}
			hw_tx_lohi      {"TX High/Low"}
			hw_polarisation {"Polarisation"}
		}
		if {[cgi auth role] in {factory support}} {
			lappend tablespec {*}{
				mpcf			{"Modulation PCF" {append "dB"}}
				tx_alc_voltage	{"TX IF Cable ALC" {append "mV"}}
				rx_synth_lv		{"RX Loop Voltage" {append "mV"}}
				tx_synth_lv		{"TX Loop Voltage" {append "mV"}}
				tx_atten		{"TX Attenuator" {append "mV"}}
				hpaserial		{"HPA Serial #"}
			}
		}

		# Create a new table
		set tb [table class=anytable]

		$tb hdr
		$tb val "" class=attribute
		$tb val "ODU 1" class=rounded
		$tb val "ODU 2" class=rounded

		# Special handling of first row
		$tb dat class=[expr {[incr rownum] % 2 ? "row1" : "row2"}]
		$tb val "ODU Comms Status" class=label
		package require gmstatus
		foreach i {1 2} {
			map_attr_init
			set d [get_modem_status $i]
			set data($i) $d
			set val $d(rfvalid)
			if {$d(modemvalid) ne "1"} {
				set val -
			}

			set val [mapvalue $val {eval {map_show_alarm $value 1} enum {0 "Comms Failure" 1 OK -1 "Mismatch"}}]

			$tb val $val {*}[map_attr_get class]
		}

		# Now the remaining rows
		foreach {field spec} $tablespec {
			lassign $spec label mapping expected
			$tb dat class=[expr {[incr rownum] % 2 ? "row1" : "row2"}]
			$tb val $label class=label

			# Iterate over each ODU
			foreach i {1 2} {
				set val [readfile $base/odu$i/$field -]
				set attrs {}
				if {$val ne "-"} {
					set d $data($i)
					if {$d(rfvalid) ne "1"} {
						lappend attrs class=failed
					} elseif {$expected ne "" && $val ne $expected} {
						lappend attrs class=alarmon
					}
					set val [mapvalue $val $mapping]
				}
				$tb val $val {*}$attrs
			}
		}

		# Now write the table
		$tb write
	}
}

auto_refresh_page

# vim: se ts=4 sw=4 noet:
