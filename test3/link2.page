label "Link 2"
title "Link 2 Modem and RF/ODU Settings"
help {Link 2 Modem and RF/ODU configuration}

# NOTE: DO NOT MANUALLY EDIT link2.page.
# The link2 page is generated automatically from the 1 page by the script
# make_page2. The script is invoked by a dependency in the Makefile.
head {
<style>
div.elemlabel {
	width: 14em;
}
</style>
}

accesslevel link

ifmodified_message

init {
	package require modulations
	package require channels
	set base [root]

	channels_load $base/etc/channels.conf
	catch {channels_load $base/etc/config/channels-custom.conf}
	if {[cgi auth role] eq "factory"} {
		catch {channels_load $base/etc/channels-debug.conf}
	}

	set txpowerscale 10.0
	set txpowerfmt "%.1f"
	set freqscale 1000000.0
	set freqfmt "%g"
	set channelscale 1000.0

	set valid [readfile $base/var/odu2/valid 0]

	if {$valid} {
		set band [readfile $base/var/odu2/hw_freq_band -]
		set subband [readfile $base/var/odu2/hw_sub_band -]
		set txhi [readfile $base/var/odu2/hw_tx_lohi -]
		set txpower_lo [readfile $base/var/odu2/tx_power_min 0]
		set txpower_hi [readfile $base/var/odu2/tx_power_max 30]

		set txhi [switch $txhi {
			low {format 0}
			high {format 1}
			default {format -}
		}]
	} else {
		set band -
		set subband -
		set txhi -
		set txpower_lo 0
		set txpower_hi 30
	}

	set channels_filt [list]
	# Build a list of channels filtered by band + subband
	foreach {id chandata} $::channels_by_id {
		if {$band eq "-" || $subband eq "-"} {
			# Nothing attached, so allow all
		} elseif {$chandata(band) != $band || $chandata(subband) != $subband} {
			# Not correct band/subband
			continue
		}
		lappend channels_filt $chandata(name) $id
	}

	# And build a list of modulation names and codes for the select list
	# Omit QPSK-LOCK from the list
	foreach n $modn_names {
		if {$n ne "QPSK-LOCK"} {
			lassign $modn_by_name($n) code label
			lappend modn_name_by_code $code $label
			lappend modn_code_by_name $label $code
		}
	}

	set rfutype "-unknown-"
	catch {set rfutype $::rfu_types($band,$subband)}

	# Calculate displayed frequency in GHz given channel data, channel and
	# whether tx is hi.
	proc dispfreq {chandata chan txhi} {
		global freqfmt freqscale
		set freq [expr {$chandata(freq) + ($chan - 1) * $chandata(width)}]

		if {$txhi} {
			set freq [+ $freq $chandata(sep)]
		}

		return [format $freqfmt [expr $freq/$freqscale]]
	}
}

bar "Link 2 Modem and RF/ODU Settings"

text {
	display {
		if {$band eq "-" || $subband eq "-"} {
			html eval div class=warningmsg {
				html str h2 "Warning - No RFU Detected"
				html str p "Enabling all bands for configuration"
				if {[cgi mode edit]} {
					html eval p {
						html puts "Select a valid configuration and click <b>Submit</b>"
					}
				}
			}
		} elseif {$band != [cgi get band] || $subband != [cgi get subband] || $txhi != [cgi get txhi]} {
			html eval div class=warningmsg {
				html str h2 "Warning - Different RFU Detected"
				html str p "Configuration does not match current RFU"
				if {[cgi mode edit]} {
					html eval p {
						html puts "Select a valid configuration and click <b>Submit</b>"
					}
				}
			}
		}
	}
}

text {
	display display_page_help
}

field plan {
	label "Channel Plan"
	storagename rf2.plan
	default "-undefined-"
	help "Link 2 channel plan"
	display {
		display_field_help display {
			if {[cgi mode std]} {
				set value "-undefined-"
				catch {
					set chandata $::channels_by_id([cgi get $field])
					set value $chandata(name)
				}
				cgi setdisplay value $value
				cgi display stdvalue
			} else {
				html eval div class=elemvalue {
					cgi_select_list $field [cgi get $field] \
					$channels_filt onchange=javascript:set_channel()
				}
			}
		}
	}
}

field channel {
	label "Channel (Tx Freq)"
	help "Specific channel and Transmit center frequency within the above plan"
	storagename rf2.channel
	default -
	display {
		display_field_help display {
			if {[cgi mode std]} {

				set chan [cgi get $field]
				if {![catch {set chandata $::channels_by_id([cgi get plan])}]} {
					if {[cgi get txhi_ui] == "0"} {
						set chan "$chan - [dispfreq $chandata $chan 0] GHz"
					} else {
						set chan "$chan' - [dispfreq $chandata $chan 1] GHz"
					}
				}

				cgi setdisplay value $chan
				cgi display stdvalue
			} else {
				html eval div class=elemvalue {
					set val [cgi get $field]
					cgi_select_list $field $val "$val $val"
				}
			}
		}
	}
}

field adaption {
	label "Tx Modulation Adaption"
	help "Transmit modulation adaption"
	storagename modem2.adaption
	type {enum 0 1 2}
	stdmode {enum 0 Auto 1 Fixed 2 Capped}
	default 0
	editmode {select 1 Fixed 2 Capped}
	display {
		if {[cgi auth role] ni {factory support}} {
			# Normal users can't set this field - always capped
			cgi return done
		} else {
			display_field_help
		}
	}
}

field modulation {
	label "Tx Modulation"
	help "Highest transmit modulation. <b>Note</b> 256QAM-RS will run at an increased error rate."
	storagename modem2.modulation
	default 0
	display {
		display_field_help display {
			if {[cgi mode std]} {
				cgi setdisplay value $modn_name_by_code([cgi get $field])
				cgi display stdvalue
			} else {
				html eval div class=elemvalue {
					cgi_select_list $field [cgi get $field] $::modn_code_by_name
				}
			}
		}
	}
}

field txpower {
	storagename rf2.txpower
	stdmode hidden
	editmode hidden
	default 0
}

field txpower_ui {
	label "Tx Power (dBm)"
	help "Transmit power"
	storage none
	display {
		if {![cgi inerror]} {
			cgi set $field [format $txpowerfmt [expr {[cgi get txpower] / $txpowerscale}]]
		}

		set lo [format $txpowerfmt $txpower_lo]
		set hi [format $txpowerfmt $txpower_hi]
		display_field_help help "$lo - $hi"
	}
}

field apc {
	type boolean
	label "Tx Power APC"
	help "Tx Automatic Power Control Enable"
	storagename modem2.txapc
	default 0
	display display_field_help
}

button edit {
	label Edit
	editmode none
	setmode edit
}

bar -std "Link 2 Modem and RF/ODU External Status"

field rfutype {
	label "Connected RFU Type"
	help "The band + subband type of connected RFU"
	storage none
	editmode none
	display {
		if {[cgi mode std]} {
			if {$band != [cgi get band] || $subband != [cgi get subband]} {
				# Mismatch, so highlight this field
				cgi addattrs -container alarm="on"
			}
			display_field_help modes std class elemrowfirst display {
				cgi setdisplay value $rfutype
				cgi display stdvalue
			}
		}
	}
}

field txhi_ui {
	label "Tx High/Low"
	help "RFU Transmit Frequency is High or Low"
	storage none
	editmode hidden
	display {
		# Don't display in edit mode if we read the value from the ODU
		if {[cgi mode std]} {
			if {$txhi ne [cgi get txhi]} {
				# Mismatch, so highlight this field
				cgi addattrs -container alarm="on"
			}
			display_field_help display {
				set val [cgi get $field]
				if {$val ne "-"} {
					set val [lindex "Low High" $val]
				}
				cgi setdisplay value $val
				cgi display stdvalue
			}
		} elseif {[cgi mode edit] && $txhi eq "-"} {
			display_field_help display {
				html eval div class=elemvalue {
					cgi_select_list $field [cgi get $field] {Low 0 High 1} \
					onchange=javascript:set_channel()
				}
			}
		}
	}
}

field txhi {
	storagename rf2.txhi
	stdmode hidden
	editmode hidden
}

button submit {
	label Submit
	stdmode none
	submit {
		proc validate {field value loval hival fmt} {
			if {[catch {set value [format $fmt $value]}]} {
				cgi error "Value must be a number"
				return 0
			}

			if {$value < $loval || $value > $hival} {
				cgi error "Value must be between [format $fmt $loval] and [format $fmt $hival]" $field
				return 0
			}

			return 1
		}

		# Validate Tx power
		set value [cgi get txpower_ui]
		set txhi_ui [cgi get txhi_ui]

		if {[validate txpower_ui $value $txpower_lo $txpower_hi $txpowerfmt]} {
			cgi set txpower [expr {int($value * $txpowerscale)}]
		}

		# Get selected channel plan
		set chandata $::channels_by_id([cgi get plan])

		# And then fill the config data for this plan
		set lofreq [expr {$chandata(freq) + ([cgi get channel] - 1) * $chandata(width)}]
		set hifreq [+ $lofreq $chandata(sep)]
		if {$txhi_ui eq "1"} {
			cgi set txfreq $hifreq
			cgi set rxfreq $lofreq
		} else {
			cgi set txfreq $lofreq
			cgi set rxfreq $hifreq
		}
		cgi set nominalwidth $chandata(nomwidth)
		cgi set band $chandata(band)
		cgi set subband $chandata(subband)
		cgi set txhi $txhi_ui

		save_config
	}
}

button cancel {
	label Cancel
	stdmode none
}

bar -std "Link 2 Modem and RF/ODU Selected Configuration"

field txfreq {
	label "Tx Frequency (GHz)"
	help "Transmit Frequency"
	storagename rf2.txfreq
	editmode none
	display {
		display_field_help modes std class elemrowfirst display {
			set value 0
			catch {set value [expr [cgi get $field]/$freqscale]}
			set value [format $freqfmt $value]
			cgi setdisplay value $value
			cgi display stdvalue
		}
	}
}

field rxfreq {
	label "Rx Frequency (GHz)"
	help "Receive Frequency"
	storagename rf2.rxfreq
	editmode none
	display {
		display_field_help modes std display {
			set value 0
			catch {set value [expr [cgi get $field]/$freqscale]}
			set value [format $freqfmt $value]
			cgi setdisplay value $value
			cgi display stdvalue
		}
	}
}

field channelwidth {
	label "Channel Width (MHz)"
	help "Channel Width"
	storage none
	editmode none
	display {
		display_field_help modes std display {
			set value 0
			catch {
				set chandata $::channels_by_id([cgi get plan])
				set value [expr $chandata(nomwidth)/$channelscale]
			}
			set value [format $freqfmt $value]
			cgi setdisplay value $value
			cgi display stdvalue
		}
	}
}

field nominalwidth {
	storagename modem2.channelwidth
	stdmode hidden
	editmode hidden
}

field band {
	storagename rf2.band
	stdmode hidden
	editmode hidden
}

field subband {
	storagename rf2.subband
	stdmode hidden
	editmode hidden
}

text {
	display {
		if {[cgi mode std]} {
			return
		}

		set plan [cgi get plan]
		set channel [cgi get channel]

		# Build javascript map of possible channel numbers versus plan ID.
		foreach {name id} $channels_filt {
			set chandata $::channels_by_id($id)
			set chan1 $chandata(first)
			set chann [expr $chan1 + $chandata(num)]
			set l_lo {}
			set l_hi {}
			foreach chan [range $chan1 $chann] {
				# Calculate and format the lo and hi frequencies for this
				# channel + plan
				set f_lo [dispfreq $chandata $chan 0]
				set f_hi [dispfreq $chandata $chan 1]

				lappend l_lo $chan "$chan - $f_lo GHz"
				lappend l_hi $chan "$chan' - $f_hi GHz"
			}

			lappend chanmap_lo $id $l_lo
			lappend chanmap_hi $id $l_hi
		}

		package require json
		set chanmap_lo [json.encode $chanmap_lo {obj * list}]
		set chanmap_hi [json.encode $chanmap_hi {obj * list}]

		html eval script type=text/javascript {

			# Set the state of the channel field based on the plan
			html puts "\nvar chanmap_lo = $chanmap_lo;"
			html puts "\nvar chanmap_hi = $chanmap_hi;"
			html puts {
				function set_channel() {
					var plan = document.getElementById('plan');
					var chan = document.getElementById('channel');
					var selected = chan.children[chan.selectedIndex].value;
					if (document.form.txhi_ui.value == "0") {
						set_select_options(chan, selected, chanmap_lo[plan.value]);
					} else {
						set_select_options(chan, selected, chanmap_hi[plan.value]);
					}
				}
				set_channel();
			}
		}
	}
}

display {
	if {$page eq "link2" && (![cgi storage get mode.mode] ||
							 ![cgi storage get mode.modem2])} {
	   puts {<div class="infobox"><b>Link 2 is disabled by the current <a href=mode>Mode Settings</a>.</b></div>}
	   cgi return done
	}

	# If we could not read the external txhi status then prime our state from
	# the recorded value.
	if {$txhi ne "-"} {
		cgi set txhi_ui $txhi
	} else {
		cgi set txhi_ui [cgi get txhi]
	}
}

# vim: se ts=4:
