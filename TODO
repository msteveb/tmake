TODO
====

Tracking External Dependencies
------------------------------
Consider caching the size, location and timestamp of
any commands which are run via exec.

If any of these change, dependent commands need to be re-run.
This can be done in 'proc run', but means that we need to be able to interpret
that PATH and determine if something is really executable.

This is done. The result is stored in tmakecache under the 'exec' key.
However it isn't perfect.

- An external command may simply be a front end to another command that has actually changed.
  (e.g. ccache which calls the actual compiler later in the path)
- It only covers commands run via 'proc run'

Local vs non-local
------------------
It is hard to chain (e.g.) Objects, Link, Executable if the input is local but the result is non-local.

Also, Depends and Phony currently use non-local specifications for -depends and -inputs.
Is there some way to allow local names to be easily used?

I think that all names should be considered local, unless explicitly qualified as /global.
Needs some rethinking of how 'target' works'

Cleaning files from the source tree
-----------------------------------

Sometimes rules will create files in the source tree.
e.g. a ctags rule

There is no easy way to clean those files

We can now do Clean/DistClean --source

Integrating foreign projects
----------------------------
autotools-based, make-based

We can just add a call to make or something similar,
but what if the external project builds libraries, etc.
which we need? We kind of want a "prebuild" dependency
which will be built before any of the given targets.
But what if we are just building clean or some local target?
What is the scope of this external dependency?

We have ExternalBuild so far

Combining tmake-based projects
------------------------------
Adding a tmake project as a subproject

automake
--------
Explain how to do automake-like things.
Also migration from automake

Installation
------------
It is useful to be able to install different classes of things.
install-docs, install-bin, install-dev, install-runtime, etc.

Propagating Defines
-------------------
While all defined variables propagate from project.spec to subdirs,
no variables defined in build.spec do so.
It would be nice to be able to propagate selected defines to subdirs.

Perhaps (although I don't like the name):

  define-propagate name1 name2 ...

In process-build-spec-file, the value of these variables
need to be captured at the end of 'Scope'. Then they can be set
for each subdir 'Scope'

Alternatively, recognise that non-local settings need to be set in project.spec
Either as a define or a proc. e.g.

  Option 1
  --------

  -- project.spec --
  define ENABLE_ABC
  -- build.spec --
  ifconfig ENABLE_ABC {
	CFlags -Dtesting=123
  }

  Option 2
  --------

  -- project.spec --
  define ABC_SPECIAL_CFLAGS -Dtesting=123
  -- build.spec --
  CFlags $ABC_SPECIAL_CFLAGS

  Option 3
  --------

  -- project.spec --
  proc EnableAbc {} {
	CFlags -Dtesting=123
  }
  -- build.spec --
  EnableAbc

tmake TODO
----------
* Does it make sense to support "IncludePaths /abc" to add paths
  relative to TOPDIR? IncludePaths should never really refer to
  dirs outside the tree, so it should be OK.
* It is hard to do 'tmake clean' if settings.conf
  is required but hasn't been created yet.
  We don't want to required settings.conf to exist
  in order to clean, but things like "UseSystemLibs $LIBS" will fail
  if LIBS isn't defined.
  Can we require the use of something like: "UseSystemLibs [var LIBS]"
  when vars are used outside of rule commands? This would solve several
  problems at the cost of being a bit ugly.
  Ideally we could have a trace callback on access to an undefined variable.
  But Tcl can't do this anyway :-(
* Properly manage/document the precedence of vars:
  - command line => make these as "fixed"
  - environment => these need to be made fixed with 'import'
  - Load settings.conf => use define to override everything which is not "fixed"
  - Defaults in rulebase.* => use define? as a last resort
* I think I plan to set all variables and execute rules in a separate interpreter
  - But what about parsing of rules? Currently we rely on having access to variables
    in build.spec and rulebase.
* Alternatively, do it all in a namespace
* Consider "real" getopt processing for the tmake command line
  - actually, option handling has improved greatly
* Load should probably load values into a ::tmake(config) dictionary and
  ifconfig should look there
  - Perhaps it is possible to also import certain of these settings (by glob)
    as global variables
* archive libraries uses a pretty simple format.
  we could parse these libraries for timestamps directly in Tcl if required
* We have --warnings, but does it make sense to also capture errors and avoid
  rebuilding if nothing has changes, and just outputting the previously captured errors?
  I'm inclined not to since ccache already does a good job of this and I don't
  think it's big use case to keep recompiling with no changes.
