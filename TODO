Reloading build definitions
---------------------------
It's possible to run a command which updates the build definition,
probably via Load.

The idea is to detect when one of these files is modified and
reload the build definition and restart.

Publish
-------
The idea here is that normally any files referred to in a build.spec
relate to files found in that directory.

But sometimes files need to be shared across directories.
Typically this will be:
- Header files
- Host executables and scripts
- Libraries

Instead of having each command which needs these things refer
to the various directories which contain them, we "publish" these
shared files to a top level directory, such as _publish
Ideally we do this with hard links (if supported) so that
if an error occurs (say in a header file) and the file is edited,
it will be the original file which is edited.
If hard links aren't supported, soft links or simply copying will work too.

Unlike Install where the installed files are never dependencies, these
published files become the dependency via the chain:

  dir2/target.o <- publish/include/file.h <- dir1/file.h

A typical scenario is where a library and some header files need to be exported
from a directory. build.spec would look something like this.

  PublishIncludes public1.h public2.h
  # Private header files are not published
  Lib --publish my file1.c file2.c file3.c

This will publish publish/include/{public1,public2}.h and publish/lib/libmy.a where
they will be available for other directories.

To publish an executable (say, needed during the build):

  HostExecutable --publish generate generate.c

Now the directory which uses these published files does something like:

  # Note that published header files are found automatically

  Generate table.c [FindBin generate] input.txt {
    run $script $inputs >$target
  }
  Executable xyz main.c table.c [FindLib my]

Here FindBin and FindLib return the path to the published files.

Currently it isn't done this way.
One of the reasons is that the appropriate build.spec may not have been parsed,
so it's not clear where to search.
Instead, Generate assumes that if the file or target isn't found locally it
must be in publish/bin, and non-local libs are always searched in publish/lib.

This may be a problem when we have both shared and archive libs.
In that case, we will need to create a dependency on (.e.g publish/lib/libname.stamp)
but link with -Lpublish/lib -llibname

So currently we have:

  Generate table.c generate input.txt {
    run $script $inputs >$target
  }
  UseLibs my
  Executable xyz main.c table.c

Out of tree build
-----------------
Builds occur in a separate tree.
Source files are located and the full or relative path is used in rules.
($target in build dir, $inputs in either source or build dir)

Install
-------
Explain the install philosophy

Build from any directory within the tree
----------------------------------------
Stub makefiles, search for project.spec

Integrating foreign projects
----------------------------
autotools-based, make-based

Combining tmake-based projects
------------------------------
Adding a tmake project as a subproject

automake
--------
Explain how to do automake-like things.
Also migration from automake

tmake TODO
----------
* Does .makecache and tmake(cache) ever need to be cleaned up?
  - Should record the real mtime as well as the virtual mtime.
    If the real mtime changes (or the file disappears) we need to flush the entry
* Add support for per-directory rules. Probably need something like Jam's <grist>
  - except I will probably use "path/from/top" as the grist
* Read project.spec and build.spec in subdirs
* Have a 'tmake -init' which will generate stub Makefiles (if they don't exist)
  - This should probably be run by configure
* Allow detection of build rule dependencies (project.spec, build.spec, settings.conf)
  and reload rules.
* Work out a good arrangement for the distribution of:
  - low level rules
  - high level rules
  - default rule base
  - local customisations
* Add parallel build support.
  - With exec &, and os.wait
* Support Test
* Support shared libraries
* Do proper getopt processing for the tmake command line
* Record commands used to build targets in a cache
* Need support for host executables with (at least):
  - HostExecutable
  - HostCFlags
  - Use CC_FOR_BUILD
* rename the project to autoproj or autoproject when it is nearing the capabilities
  for automake (although there are projects by both of those names)
* Load should probably load values into a ::tmake(config) dictionary and
  ifconfig should look there
  - Perhaps it is possible to also import certain of these settings (by glob)
    as global variables
* archive libraries uses a pretty simple format.
  we could parse these libraries for timestamps directly in Tcl if required

Done
----
* Add a version number and --version
* Add --help
* Add getopt and use it like automf for Executable --test --install=/blah ...
* Need a way to specify that a single command creates multiple targets.
  - something like: target {t1 t2 t3} ...
  - then create an "aliases" table which points to the target: aliases(t1) -> targets(t1 t2 t3)
  - when an alias needs to be built, lookup the rule
* Use source location even when unable to build something to show what rules
  were used to determine that something was needed. Perhaps look back along
  tmake(current). This is done, but could be formatted better.
* Scan for header file dependencies
  - How to only notice headers we care about?
  - Just before building abc.c, scan for headers
  - If we have a rule for making a found header, mark it as a dependency
  - Otherwise ignore it
  - Note that Jam uses NOCARE to ignore these dependencies if they file doesn't exist
    - But that causes problems when the headers are generated...
* header scan should take include path(s) into consideration
* Add user errors and internal errors like autosetup/automf
* Modify to support jimsh, bootstrap jimsh and Tcl8.5
* Support Publish* and --publish
* How to add rules for new Object types?
  - ObjectCFlags
* Publish includes, libs, bins to a dir as ungristed
* There is a problem in handling rules which run but don't update the target because
  nothing has changed. Ideally we would record the fact that the rule had run in
  a cache file along with the time that the rule ran. See .makecache

Subdirectories
--------------

Note that Jam allows the rule to capture per-rule flags.
e.g.

    CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) $(OPTIM) ;

tmake does something similar with C_FLAGS and CCFLAGS.
