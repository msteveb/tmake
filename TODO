Subdirectories
--------------

Note that Jam allows the rule to capture per-rule flags.
e.g.

    CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) $(OPTIM) ;

Why can't we do the same? I think the problem is that OBJRULE()
is a simple rule. Perhaps it needs to be a proc which returns
-vars and other args to target

Publish
-------
The idea here is that normally any files referred to in a build.spec
relate to files found in that directory.

But sometimes files need to be shared across directories.
Typically this will be:
- Header files
- Host executables and scripts
- Libraries

Instead of having each command which needs these things refer
to the various directories which contain them, we "publish" these
shared files to a top level directory, such as _publish
Ideally we do this with hard links (if supported) so that
if an error occurs (say in a header file) and the file is edited,
it will be the original file which is edited.
If hard links aren't supported, soft links or simply copying will work too.

Unlike Install where the installed files are never dependencies, these
published files become the dependency via the chain:

  dir2/target.o <- _publish/include/file.h <- dir1/file.h

A typical scenario is where a library and some header files need to be exported
from a directory. build.spec would look something like this.

  PublishIncludes public1.h public2.h
  # Private header files are not published
  Lib --publish my file1.c file2.c file3.c

This will publish publish/include/{public1,public2}.h and publish/lib/libmy.a where
they will be available for other directories.

To publish an executable (say, needed during the build):

  HostExecutable --publish generate generate.c

Now the direction which uses these published files does something like:

  # Note that published header files are found automatically

  Generate table.c input.txt [FindBin generate] {
    run $script $inputs >$target
  }
  Executable xyz main.c table.c [FindLib my]

Here FindBin and FindLib return the path to the published files

Out of tree build
-----------------
Builds occur in a separate tree.
Source files are located and the full or relative path is used in rules.
($target in build dir, $inputs in either source or build dir)

Install
-------
Explain the install philosophy

Build from any directory within the tree
----------------------------------------
Stub makefiles, search for project.spec

Integrating foreign projects
----------------------------
autotools-based, make-based

Combining tmake-based projects
------------------------------
Adding a tmake project as a subproject

automake
--------
Explain how to do automake-like things.
Also migration from automake

tmake TODO
----------
* Does .makecache and tmake(cache) ever need to be cleaned up?
* Add support for per-directory rules. Probably need something like Jam's <grist>
  - except I will probably use "path/from/top" as the grist
* Read project.spec and build.spec in subdirs
* Have a 'tmake -init' which will generate stub Makefiles (if they don't exist)
  - This should probably be run by configure
* Allow detection of build rule dependencies (project.spec, build.spec, settings.conf)
  and reload rules.
* Work out a good arrangement for the distribution of:
  - low level rules
  - high level rules
  - default rule base
  - local customisations
* Add parallel build support.
  - With exec &, and os.wait
* Support Test
* Support shared libraries
* Do proper getopt processing for the tmake command line
* Record commands used to build targets in a cache
* Need support for host executables with (at least):
  - HostExecutable
  - HostCFlags
  - Use CC_FOR_BUILD
* rename the project to autoproj or autoproject when it is nearing the capabilities
  for automake (although there are projects by both of those names)
* Load should probably load values into a ::tmake(config) dictionary and
  ifconfig should look there
  - Perhaps it is possible to also import certain of these settings (by glob)
    as global variables

Done
----
* Add a version number and --version
* Add --help
* Add getopt and use it like automf for Executable --test --install=/blah ...
* Need a way to specify that a single command creates multiple targets.
  - something like: target {t1 t2 t3} ...
  - then create an "aliases" table which points to the target: aliases(t1) -> targets(t1 t2 t3)
  - when an alias needs to be built, lookup the rule
* Use source location even when unable to build something to show what rules
  were used to determine that something was needed. Perhaps look back along
  tmake(current). This is done, but could be formatted better.
* Scan for header file dependencies
  - How to only notice headers we care about?
  - Just before building abc.c, scan for headers
  - If we have a rule for making a found header, mark it as a dependency
  - Otherwise ignore it
  - Note that Jam uses NOCARE to ignore these dependencies if they file doesn't exist
    - But that causes problems when the headers are generated...
* header scan should take include path(s) into consideration
* Add user errors and internal errors like autosetup/automf
* Modify to support jimsh, bootstrap jimsh and Tcl8.5
* Support Publish* and --publish
* How to add rules for new Object types?
  - ObjectCFlags
* Publish includes, libs, bins to a dir as ungristed
* There is a problem in handling rules which run but don't update the target because
  nothing has changed. Ideally we would record the fact that the rule had run in
  a cache file along with the time that the rule ran. See .makecache
