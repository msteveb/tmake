# vim:set syntax=tcl:
# These are the built-in rules
#
# They can be replaced if necessary

# ==================================================================
# Default variable settings and rules
# ==================================================================

# XXX: If settings are loaded via Load, these should all be ignored
define? CCACHE ""
define? CC cc
define? CC_FOR_BUILD cc
define? CXX c++
define? AR ar
define? RANLIB ranlib
define? STRIP strip
define? ARFLAGS cr
define? SH_LINKFLAGS ""
define? CFLAGS ""
define? CXXFLAGS ""
define? LDFLAGS ""

define? SH_CFLAGS ""
define? SH_LDFLAGS ""
define? SHOBJ_CFLAGS ""
define? SHOBJ_LDFLAGS ""


define? LOCAL_LIBS ""
define? DESTDIR ""
define? OBJCFLAGS ""
define? INCPATHS ""

# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
set C_FLAGS ""
set CXX_FLAGS ""
set LD_FLAGS ""

# XXX Should be $TOP/publish
set PUBLISH publish

set PROJLIBS ""
set SYSLIBS ""

proc ObjectRule.c {obj src} {
	# Capture the current value of C_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note Cc $target} -getvars C_FLAGS INCPATHS -do {
		run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS $HDRPATTERN
	}
}

proc ObjectRule.cpp {obj src} {
	# Capture the current value of CXX_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note C++ $target} -getvars CXX_FLAGS INCPATHS -do {
		run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS $HDRPATTERN
	}
}

set HDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

set SHAREDOBJRULE {run $CC $SHOBJ_LDFLAGS -o $target $inputs $SYSLIBS}

lappend tmake(subdirvars) C_FLAGS CXX_FLAGS LD_FLAGS LOCAL_LIBS PROJLIBS SYSLIBS INCPATHS

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc BuildSpecProlog {} {
	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			Phony $t
			target $parentprefix$t -phony -depends [make-local $t]
		}
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}
	IncludePaths .
	define testid 0
}

proc BuildSpecEpilog {} {
	global tmake

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	array set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	if {$tmake(localmakefile) ni {none -none}} {
		set makefile [make-local $tmake(localmakefile)]
		if {[info exists tmake(build)]} {
			# Create stub makefiles in srcdir, not builddir
			set makefile [file-join $tmake(topsrcdir) $makefile]
			# XXX: Makefiles will not be deleted by distclean here!
		}
		if {![file exists $makefile]} {
			set tmakeargs "\"--mflags=\$(MFLAGS)\" \"--gnumakeflags=\$(MAKEFLAGS)\" \"--bsdmakeflags=\$(.MAKEFLAGS)\""
			if {[info exists tmake(build)]} {
				append tmakeargs " --build=$tmake(build)"
			} else {
				# Set -C before -P
				if {[local-dir] ne "."} {
					append tmakeargs " -C [join [lrepeat [llength [split [local-dir] /]] ..] /]"
				}
				if {$tmake(topsrcdir) ne "."} {
					append tmakeargs " -P $tmake(topsrcdir)"
				}
			}
			append tmakeargs " SUBDIR=[local-dir]"

			set lines {}
			lappend lines "# Stub makefile generated by tmake v$tmake(version)"
			lappend lines ".PHONY: \$(.TARGETS) \$(MAKECMDGOALS) _all"
			lappend lines "_all:"
			lappend lines "\t+@$tmake(exe) $tmakeargs [local-prefix]all"
			lappend lines "\$(.TARGETS) \$(MAKECMDGOALS):"
			lappend lines "\t+@$tmake(exe) $tmakeargs [local-prefix]\$@"
			writefile $makefile [join $lines \n]\n
		}
		DistClean $tmake(localmakefile)
	}
}

# ==================================================================
# HELPERS
# ==================================================================
proc expand-wildcard-braces {arglist} {
	set result {}
	foreach pattern $arglist {
		if {[string match {*{*}*} $pattern]} {
			regexp {^(.*)\{(.*)\}(.*)$} $pattern -> before alts after
			foreach i [split $alts ,] {
				lappend result $before$i$after
			}
		} else {
			lappend result $pattern
		}
	}
	#puts "$arglist => $result"
	return $result
}

# Returns a list of pairs: src dest
# The src is a local path, while the dest is relative.
# so ssl/*.h might return: {axtls/ssl/file.h ssl/file.h}
#
proc expand-wildcards {arglist {warn 0} {keepdir 1}} {
	set pairs {}
	foreach i $arglist {
		if {[string match {*[{}*?]*} $i]} {
			set count 0
			foreach ii [expand-wildcard-braces $i] {
				# ii=ssl/*.h
				# destdir=ssl
				set destdir [file dirname $ii]
				# srcdir=axtls/ssl
				if {$destdir eq "."} {
					set srcdir [local-dir]
				} else {
					set srcdir [make-local $destdir]
				}
				# globdir=../axtls/ssl
				set globdir [file-src $srcdir]
				if {![file isdir $globdir]} {
					puts "Warning: $globdir does not exist"
					continue
				}
				# pattern=*.h
				set pattern [file tail $ii]
				foreach j [readdir $globdir] {
					if {[string match $pattern $j]} {
						incr count
						# Need to return axtls/ssl/crypto.h ssl/crypto.h
						if {$keepdir} {
							lappend pairs [file-join $srcdir $j] [file-join $destdir $j]
						} else {
							lappend pairs [file-join $srcdir $j] [file tail $j]
						}
					}
				}
			}
			if {$warn && $count == 0} {
				puts "Warning: No matches for [make-local $i]"
			}
		} elseif {[string match *=* $i]} {
			lassign [split $i =] target src
			lappend pairs [make-local $src] $target
		} elseif {$i ne ""} {
			if {$keepdir} {
				lappend pairs [make-local $i] $i
			} else {
				lappend pairs [make-local $i] [file tail $i]
			}
		}
	}
	#puts "expand-wildcards [make-local $arglist] => $pairs"
	return $pairs
}

proc Glob {args} {
	#getopt {--tail args} args
	set result {}
	foreach pattern $args {
		foreach {i j} [expand-wildcards $pattern] {
			lappend result $j
		}
	}
	lsort $result
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

proc Executable {args} {
	show-this-rule
	getopt {--test --nobuild --publish --strip --install: target args} args
	if {$publish} {
		# Revisit: --publish=newname?
		Publish bin $target
	}
	set localtarget [make-local $target]
	Link $target {*}[Objects {*}[join $args]] {*}$::LOCAL_LIBS {*}$::PROJLIBS
	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags strip
		}
		InstallFile [file-join $install $target] $localtarget $flags
	}
	if {$test} {
		Test --chdir $target
	} elseif {!$nobuild} {
		Phony all $localtarget
	}
}

# Link an executable from objects
proc Link {target args} {
	show-this-rule

	define? CCLD $::CC

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target [make-local $target] -inputs {*}$args -msg {note Link $target} -getvars CCLD LD_FLAGS SYSLIBS -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $SYSLIBS
	}
	Clean $target
}

proc publish-one-file {dest src} {
	hard-link [file join $::PUBLISH $dest] $src -vars dest $dest -msg {note Publish $dest}
}

proc Publish {args} {
	show-this-rule
	getopt {--keepdir dir args} args

	foreach {src dst} [expand-wildcards $args 1 $keepdir] {
		publish-one-file $dir/$dst $src
	}
}

proc ArchiveLib {args} {
	show-this-rule
	getopt {--publish --install: basename args} args

	set libname lib$basename.a

	set target [make-local $libname]
	target $target -inputs {*}[Objects {*}[join $args]] -msg {note Ar $target} -do {
		file delete $target
		run $AR $ARFLAGS $target $inputs
		run $RANLIB $target
	}
	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $target
	Clean $libname
	define-append LOCAL_LIBS $target

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $target
	}
	if {$publish} {
		Publish lib $libname
	}
}

alias Lib ArchiveLib

proc SharedObject {args} {
	show-this-rule

	getopt {--install: sharedobj args} args

	# XXX: Should build objects with -fpic, etc.
	# Use -vars/ObjectCFlags to do this
	SharedObjectLink $sharedobj {*}[Objects {*}[join $args]]

	set sharedobj [make-local $sharedobj]

	Phony all $sharedobj
	if {[info exists install]} {
		Install --bin $install $sharedobj
	}
}

# Link an executable from objects
proc SharedObjectLink {target args} {
	show-this-rule
	# Note that we only link against local shared libs, not archive libs
	target [make-local $target] -inputs {*}$args -do $::SHAREDOBJRULE -msg {note SharedObject $target}
	Clean $target
}

# Create an object file from each source file
# Uses $OBJSRULES(.ext) to determine the build rule
# Returns a list of objects
# Accepts object files (.o) in addition to source files
# and simply returns them
proc Objects {args} {
	show-this-rule
	set objs {}
	foreach src $args {
		lappend objs [Object [change-ext .o $src] $src]
	}
	return $objs
}

proc Object {target src} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		set extra {}
		if {[info procs ObjectRule$ext] eq ""} {
			dev-error "Don't know how to build Object from $src"
		}
		ObjectRule$ext $obj $src
		Clean $target
	}
	return $obj
}

# Add object-specific CFLAGS
proc ObjectCFlags {srcs args} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

proc CFlags {args} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

proc C++Flags {args} {
	define-append CXX_FLAGS {*}$args
}

proc LinkFlags {args} {
	define-append LD_FLAGS {*}$args
}

proc Linker {linker} {
	define CCLD $linker
}

proc UseLibs {args} {
	foreach lib $args {
		# REVISIT: If we are to support linking against project shared libs, PROJLIBS
		#          needs to be just a list of libs which will then be resolved to actual
		#          targets (archive or shared) at deferred resolution time
		define-append PROJLIBS [file join $::PUBLISH lib lib$lib.a]
	}
}

proc IncludePaths {args} {
	show-this-rule
	foreach dir $args {
		foreach prefix [list [local-dir] $::tmake(topsrcdir)] {
			set dir [file-join $prefix $dir]
			if {$dir ni $::INCPATHS} {
				define-append INCPATHS $dir
				CFlags [prefix -I $dir]
				C++Flags [prefix -I $dir]
			}
		}
	}
}

proc load-config-file {filename} {
	# All lines look like one of:
	#CONFIG_BOOL_VALUE=y (or m)
	#CONFIG_STR_VALUE="string value"
	#CONFIG_INT_VALUE=123
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			#puts "define $name $value"
			define $name $value
		} else {
			puts "$filename:$n: Warning: Failed to parse $line"
		}
	}
}

proc Load {args} {
	show-this-rule

	getopt {--nocare --config filename} args
	# XXX: Should we allow loading an out-of-tree file?
	set filename [make-local $filename]
	if {[file exists $filename]} {
		if {$config} {
			load-config-file $filename
		} else {
			uplevel #0 [list source $filename]
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	lappend ::tmake(projfiles) $filename $nocare
}

proc UseSystemLibs {args} {
	define-append SYSLIBS {*}$args
}

proc PublishIncludes {args} {
	getopt {--keepdir args} args

	foreach {src dst} [expand-wildcards $args 1 $keepdir] {
		publish-one-file include/$dst $src
	}
}

proc Test {args} {
	show-this-rule

	getopt {--interp: --chdir --quiet command args} args
	set testid test#[incr ::testid]
	set depends {}
	set command $command
	set localcommand [make-local $command]

	set opts {}

	if {$chdir} {
		# XXX: Will -chdir mess up the path to interp and command?
		lappend opts -chdir
	}
	if {!$quiet} {
		lappend opts -msg [list note "Test $localcommand"]
	}

	set testcommand {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp $chdir] dep filename
		lappend opts -depends $dep
		lappend testcommand $filename 
	}
	lassign [find-project-bin $command $chdir] dep filename
	lappend opts -depends $dep
	lappend testcommand $filename

	lappend testcommand {*}$args

	target [make-local $testid] -phony -vars testcommand $testcommand {*}$opts -do {
		incr ::tmake(testruncount)
		run $testcommand
		incr ::tmake(testpasscount)
	}
	Phony test [make-local $testid]

	return $testid
}

proc CopyFile {dest source} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg "note Copy $dest" -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

proc hard-link {args} {
	show-this-rule

	getopt {--fallback dest source args} args

	# XXX: If the platform doesn't support hard links
	# and --fallback is set, fall back to soft links
	# and then to file copy
	# Want to depend on the existence of the dir, not the time
	target $dest -inputs $source -do {
		file delete $target
		exec ln $inputs $target
	} {*}$args
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# Helper for installing files
proc install-file {target source bin} {
	vputs "Copy $source $target"
	file copy -force $source $target
}

proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

proc strip-file {target} {
	vputs "Strip $target"
	exec $::STRIP $target
}


proc InstallFile {dest src {flags {}}} {
	show-this-rule

	#puts "InstallFile $dest $src"

	set destfile $::DESTDIR$dest
	if {[is-target? $destfile]} {
		user-notice [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}
	target $destfile -nocache -inputs $src -vars dest $dest flags $flags -msg {note "Install $dest"} -do {
		install-file $target $inputs $flags
		if {"bin" in $flags} { chmodx-file $target }
		if {"strip" in $flags} { strip-file $target }
	}
	target install -depends $destfile

	# This file also needs to be uninstalled
	add-clean uninstall $destfile
}

proc Install {args} {
	show-this-rule

	getopt {--bin --strip --keepdir destdir args} args
	set flags {}
	if {$bin} {
		lappend flags bin
	}
	if {$strip} {
		lappend flags strip
	}

	set srcs {}
	foreach {src dst} [expand-wildcards $args 1 $keepdir] {
		lappend srcs $src
		InstallFile [file-join $destdir $dst] $src $flags
	}
	return $srcs
}

proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# Helper to clean files (and any empty directories)
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# This creates the clean target of the given type, e.g. clean, distclean
#
proc clean-target {type msg} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" -do {
		clean-files $cleanfiles
	}
}

proc Clean {args} {
	if {[lindex $args 0] in {clean distclean}} {
		dev-error "fix call to Clean"
	}
	add-clean [make-local clean] [make-local {*}[join $args]]
	# DistClean also cleans these files
	DistClean {*}$args
}

proc DistClean {args} {
	add-clean [make-local distclean] [make-local {*}[join $args]]
}

# This adds files to be cleaned for the given type
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	#Depends [make-local $type] -vars cleanfiles [join $args]
	target-add-var $type cleanfiles $filelist
}

# Returns a list of {dependency filename}
#
proc find-project-bin {bin {chdir 0}} {
	set localbin [make-local $bin]
	if {[is-target? $localbin]} {
		dputs m "[find-source-location]: find-project-bin: $localbin is a local target"
		if {$chdir} {
			return [list $localbin $bin]
		} else {
			return [list $localbin [local-dir]/$bin]
		}
	} elseif {[file-src-exists $localbin]} {
		dputs m "[find-source-location]: find-project-bin: $localbin exists as source"
		if {$chdir} {
			# cd to local build dir, but file is relative to the top of the src dir
			set src [file-src-relative $localbin [file dirname $localbin]]
			return [list $localbin ./$src]
		} else {
			return [list $localbin [file-src $localbin]]
		}
	} else {
		dputs m "[find-source-location]: find-project-bin: $bin assumed to be published"
		set publishbin $::PUBLISH/bin/$bin
		if {$chdir} {
			# cd to local build dir, but file is relative to top of the build dir
			set src [relative-path $publishbin [file dirname $localbin]]
			return [list $localbin $src]
		} else {
			return [list $publishbin $publishbin]
		}
	}
}

proc Generate {args} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $target} {*}$args
	Clean $target
}

proc Depends {target args} {
	target [make-local {*}$target] -depends {*}$args
}

proc Phony {target args} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	set ::tmake(localmakefile) $name
}

# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans
Depends test clean-orphans

Phony clean-orphans -do {
	clean-files [get-orphan-targets] "orphan targets"
	discard-orphan-targets
}

# XXX: Use an official API for this
lappend tmake(deferred) {
	IncludePaths $PUBLISH/include
}
