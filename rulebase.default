# vim:set syntax=tcl:
# These are the built-in rules
#
# They can be replaced if necessary

# @synopsis:
#
# rulebase.default is the default tmake rulebase...
#
# The following environment variables are used if set:
#
## CC       - C compiler
## CXX      - C++ compiler
## ...

use getopt glob

# ==================================================================
# Default variable settings and rules
# ==================================================================

# If settings are loaded via Load, these should all be ignored
# Thus we use define?
define? CCACHE ""
define? CC cc
define? CXX c++
define? AR ar
define? RANLIB ranlib
define? STRIP strip
define? ARFLAGS cr
define? CFLAGS ""
define? CXXFLAGS ""
define? LDFLAGS ""
define? EXEEXT ""

define? SH_CFLAGS ""
define? SH_LDFLAGS ""
define? SH_LINKFLAGS ""
define? SH_SOEXT .so
define? SHOBJ_CFLAGS ""
define? SHOBJ_LDFLAGS ""

define? CC_FOR_BUILD cc
define? HOST_CFLAGS ""
define? HOST_EXEEXT ""

define? LOCAL_LIBS ""
define? DESTDIR ""
define? OBJCFLAGS ""
define? INCPATHS ""

# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
define C_FLAGS ""
define CXX_FLAGS ""
define LD_FLAGS ""

define PUBLISH publish

define PROJLIBS ""
define SYSLIBS ""
define HOST_SYSLIBS ""

# Default header pattern for C and C++ dynamic dependencies
#
# All globals variables for rulebase.default are kept in the $::tmakedrb array
set ::tmakedrb {
	testruncount 0
	testpasscount 0
	testid 0
	setuptestenv 0
	objmap {}
}

# ==================================================================
# Help Overview
# ==================================================================
rule-overview {
This is rulebase.default, the default tmake rulebase. Note the following conventions:

File specifications for Install and Publish rules support the following forms:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (e.g. *.png)

For rules that set variables/flags, those definitions apply to rules later in the file.
For example, when setting C_FLAGS with CFlags, those flags are used by subsequent
Object and Executable rules, but not earlier rules.

Note: Scope can be used to limit the lifetime of definitions.

The following global phony targets are created:

  all:       Builds the 'all' targets from all subdirectories
  test:      Runs the 'test' targets from all subdirectories
  clean:     Runs the 'clean' targets from all subdirectories
  distclean: Runs the 'distclean' targets from all subdirectories
  install:   Runs all install rules
  uninstall: Runs all uninstall rules

  Note that these global targets can be accessed from within a subdirectory
  by using a / prefix. e.g. /all

The following per-directory phony targets are created:
  all:       Builds executables and shared objects in the current directory
             (or libraries if there are no executables or shared objects)
  test:      Runs all tests in the current directory
  clean:     Removes all build products, including Clean targets, in the current directory
  distclean: Runs 'clean', removes DistClean targets in the current directory,
             and cleans all orphan objects
  install:   A convenience alias for /install
  uninstall: A convenience alias for /uninstall

Note that by default, Lib is an alias for ArchiveLib. This can be changed with:
  alias Lib SharedLib
}

# ==================================================================
# BUILT-IN Object Rules
# ==================================================================

define CHDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

# @ObjectRule.<ext> object source
#
# Rule for creating 'object' from source file 'source' with the
# extentions 'ext'.
#
# The appropriate ObjectRule.<ext> is invoked from Object
# (and hence Objects, Executable and Lib) based on the extension.

rule ObjectRule.c {obj src} {
ObjectRule.c object source

Generates an object file from a C source file

Imported variables: CC, C_FLAGS (from CFlags, ObjectCFlags), INCPATHS (from IncludePaths)
Used variables: CFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	# Capture the current value of CC, C_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note Cc $targetname} -getvars CC C_FLAGS INCPATHS -do {
		run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

rule ObjectRule.cpp {obj src} {
ObjectRule.cpp object source

Generates an object file from a C++ source file

Imported variables: CXX, CXX_FLAGS (from C++Flags), INCPATHS (from IncludePaths)
Used variables: CXXFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	# Capture the current value of CXX, CXX_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note C++ $targetname} -getvars CXX CXX_FLAGS INCPATHS -do {
		run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc BuildSpecProlog {} {
	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			set localtarget [make-local $t]
			target $localtarget -phony
			target $parentprefix$t -phony -depends $localtarget
		}
		Phony install install
		Phony uninstall uninstall
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}

	# XXX: Is there ever a reason to *not* include the current directory?
	IncludePaths .
}

proc BuildSpecEpilog {} {
	global tmake

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	# Ensure that even directories with no targets are removed
	Clean __dummy__
}

# ==================================================================
# UTILTY PROCS
# ==================================================================

# @target-alias target targetexe
#
# On some systems, executables are identified with an extension (e.g. .exe)
# For cross-platform compatibility, rules omit this extension and an alias is used
# to link to the actual filename.
#
# This command checks the rule name (e.g. abc) and the executable name (e.g. abc.exe)
# and if they are the same, returns an appropriate target alias for the executable
# (e.g. -alias abc). Otherwise an empty list is returned.
#
proc target-alias {target targetexe} {
	if {$target ne $targetexe} {
		return [list -alias [make-local $target]]
	}
	return ""
}

# @publish-path dir
#
# Returns the path to the given 'publish' subdirectory,
# e.g. [publish-path include] returns something like objdir/.publish/include
#
proc publish-path {dir} {
	file-build [file-join [get-define PUBLISH] $dir]
}

# @publish-dir dir
#
# Returns the path to the given 'publish' subdirectory relative to the build directory
# e.g. [publish-dir include] returns something like .publish/include
#
proc publish-dir {dir} {
	file-join [get-define PUBLISH] $dir
}

# @publish-prefix dir
#
# Like publish-dir, but returns the value suitable to be used as a prefix
#
proc publish-prefix {dir} {
	make-prefix [publish-dir $dir]
}

# @publish-one-file dest src
#
# Creates a rule to publish $src as $dest (build relative name) by creating a hard link.
# e.g. publish-one-file include/header.h header.h
#
proc publish-one-file {dest src} {
	#puts "publish-one-file: dest=$dest, src=$src, realdest=[publish-dir $dest]"
	hard-link [publish-dir $dest] $src -msg {note Publish $targetname}
}

# @publish-lib libname alias
#
# Creates a rule to publish an archive library, $libname, to the $PUBLISH/lib directory.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-lib {libname alias} {
	hard-link [publish-prefix lib]$libname [make-local $libname] -msg {note Publish $targetname} -alias $alias
}

# @make-shlib-symlinks first alias...
#
# Create symlinks such that each of the given aliase is a symlink to $first.
# All paths/names should be in the same directory
# The alias targets must not exist.
#
proc make-shlib-symlinks {first args} {
	foreach alias $args {
		file-link -sym $alias [file tail $first]
	}
}

# @publish-shared-lib names source alias
#
# Creates a rule to publish a shared library, $source, with the given names to the
# $PUBLISH/lib directory.
# This includes creating appropriate symlinks.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-shared-lib {names source alias} {
	set published [prefix [publish-prefix lib] {*}$names]

	target $published -inputs $source -msg {note Publish [lindex $targetname 0]} -do {
		file delete {*}$target
		file-link [lindex $target 0] $inputs
		make-shlib-symlinks {*}$target
	} -vars libname [lindex $names 0] -alias $alias
	add-clean [make-local clean] $published
	add-clean [make-local distclean] $published
}

# @install-shared-lib dest names source flags
#
# Creates a rule to install a shared library, $source, to install directory $dest
# This includes creating appropriate symlinks.
# $flags are passed to install-file and should either be empty, or "striplib".
proc install-shared-lib {dest names source flags} {
	set installed [prefix [make-prefix [get-define DESTDIR]$dest] $names]

	target $installed -nocache -inputs $source -msg {note Install $libname} -do {
		file delete {*}$target
		install-file [lindex $target 0] $inputs $flags
		make-shlib-symlinks {*}$target
	} -vars flags $flags libname [file-join $dest [lindex $names 0]]

	target install -depends {*}$installed
	add-clean uninstall $installed
}

# @expand-filespec dir filelist keepdir
#
# Implements target renaming/globbing for Publish and Install
#
# $dir is the target directory
# $filelist is the file specification
# $keepdir is a boolean which indicates whether to keep the source dir in the target name
#
# The file specification may include:
# - Regular filenames
# - Renaming rules of the form: target=src
# - Glob patterns
#
# Returns a list of the form: target1 source1 target2 source2 ...
proc expand-filespec {dir filelist keepdir} {
	set result {}

	foreach spec $filelist {
		if {$spec eq ""} {
			continue
		}
		if {[string match *=* $spec]} {
			lassign [split $spec =] target src
			lappend result [file-join $dir $target] [make-local $src]
			continue
		}
		if {[string match {*[{}*?]*} $spec]} {
			set srcs [Glob --all $spec]
		} else {
			set srcs $spec
		}
		foreach src $srcs {
			if {$keepdir} {
				lappend result [file-join $dir $src] [make-local $src]
			} else {
				lappend result [file-join $dir [file tail $src]] [make-local $src]
			}
		}
	}
	#puts "expand-filespec: $filelist => $result"
	return $result
}

# @expand-objects objs
#
# Expands a list of objects which may contain library aliases of the form <lib>$basename
# Each library alias is expanded into the list of objects for that library.
# (Note that SharedLib and ArchiveLib create an object list when creating libraries)
# Any non-aliases are left unchanged.
# 
# Returns the expanded object list.
proc expand-objects {objs} {
	set result {}
	foreach obj $objs {
		if {[string match <lib>* $obj]} {
			if {![dict exists $::tmakedrb(objmap) $obj]} {
				build-error "Error: Unable to find objects for unknown lib $obj"
				return -code break
			}
			# XXX: How to guarantee that $SH_CFLAGS are set on these objects?
			# (Either directly via ObjectCFlags or with a top-level CFlags)
			#
			lappend result {*}[file-build [dict get $::tmakedrb(objmap) $obj]]
		} else {
			lappend result $obj
		}
	}
	#puts "expand-objects $objs =>\n$result"
	return $result
}

# @load-config-file filename
#
# Reads a configuration file of the form:
#
## CONFIG_BOOL_VALUE=y (or m)
## CONFIG_STR_VALUE="string value"
## CONFIG_INT_VALUE=123
#
# Each matching value is loaded as a corresponding variable definition
# where if the value is "y", it is changed to "1", and if the value
# is a quoted string, the quotes are removed.
proc load-config-file {filename} {
	# All lines look like one of:
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			dputs c "define $name $value"
			define $name $value
		} else {
			user-notice purple "$filename:$n: Warning: Failed to parse $line"
		}
	}
	if {$n == 0} {
		user-notice purple "Warning: $filename contains no configuration"
	}
}

# @setup-test-env
#
# Prepares the environment for running tests.
# Currently appends (the absolute path of) $PUBLISH/lib to LD_LIBRARY_PATH
# in the environment to allow published shared libraries to be loaded
proc setup-test-env {} {
	# XXX some platforms use a different name
	set ldlibpath [get-define LD_LIBRARY_PATH]
	if {$ldlibpath ne ""} {
		set path [getenv $ldlibpath ""]
		# Must use a full path here since some tests do chdir
		set addlib [file-join [get-define TOPBUILDDIR] [publish-dir lib]]
		append-with-space path $addlib $::tcl_platform(pathSeparator)
		setenv $ldlibpath $path
	}
}

# @get-test-id
#
# Returns a unique test id of the form 'test#nnn'
# Used to help identify Test targets since they don't have
# a natural target name.
proc get-test-id {} {
	return test#[incr ::tmakedrb(testid)]
}

# @run-test-command testcommand
#
# This is a help for running test commands.
# The environment is set up with setup-test-env
# Then SRCDIR and TOPBUILDDIR 
# The given command
# Note that we don't pass SRCDIR explictly to keep the
# 'tmake -n' output clean
proc run-test-command {testcommand} {
	setup-test-env

	# Get this value from the calling scope and set in the environment
	uplevel 1 {setenv SRCDIR $SRCDIR}
	incr ::tmakedrb(testruncount)
	run $testcommand
	incr ::tmakedrb(testpasscount)
}

# @hard-link dest source ?target-args...?
#
# Creates a rule to link $dest to $source
# Additional arguments may be passed and are added to the target rule.
# 
proc hard-link {args} {
	#show-this-rule

	getopt {dest source args} args

	# XXX: If the platform doesn't support hard links,
	# consider falling back to soft links and then to file copy
	target $dest -inputs $source -do {
		file delete $target
		file-link $target $inputs
	} {*}$args

	# Note that we can't use Clean here because $dest is already
	# a local name
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# @install-file target source flags
#
# Helper for installing files
# Copies the file from $source to $target, then performs zero or more actions
# depending upon the flags (which is a list)
#
# bin      - make the target executable with chmodx-file
# strip    - strips the target with strip-file $STRIPFLAGS
# striplib - strips the target with strip-file $STRIPLIBFLAGS
proc install-file {target source flags} {
	vputs "Copy $source $target"
	file copy -force $source $target
	if {"bin" in $flags} { chmodx-file $target }
	if {"strip" in $flags} { strip-file [get-define STRIPFLAGS {}] $target }
	if {"striplib" in $flags} { strip-file [get-define STRIPLIBFLAGS {}] $target }
}

# @chmodx-file target
#
# Makes the given file executable with chmod +x
proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

# @strip-file flags target
#
# Invokes '$STRIP $flags $target' to strip the given executable
#
# If $STRIP is not set, does nothing
proc strip-file {flags target} {
	vputs "Strip $target"
	exec {*}[get-define STRIP true] {*}$flags $target
}

# @remove-empty-directories filename-list
#
# Considers the set of directories containing each filename in the list.
# Removes any of those directories that are empty.
proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# @clean-files filename-list ?msg?
#
# Helper to clean files (and any empty directories)
#
# Removes the list of files, and then any directories that contain those
# files which have become empty.
#
# If $msg is provided, it is printed via 'note', otherwise a default
# message is printed.
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# @clean-target type msg
#
# Create the phony clean target of the given type and message.
# The created target invokes clean-files
#
# Additional files can be added to the target with 'add-clean'
#
proc clean-target {type msg} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" -do {
		clean-files $cleanfiles
	}
}

# @add-clean type filename-list
#
# Adds the given files to the list to be removed for the given type (target)
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	target-add-var $type cleanfiles [file-build $filelist]
}

# @find-project-bin binfile ?-chdir 0|1? ?-optional 0|1?
#
# Searches for the given binary file as follows:
# 1. If $binfile is a known target, the result is the target
# 2. If $binfile is of the form <bin>name, the result is the published binary
# 3. If the file exists in the local directory, the result is the file
# 4. Otherwise, if optional=1, the file is assumed to be an external binary
# 5. Otherwise an error is raised.
#
# The result is a list of two values: {dependency filename}
#
# The first value is a build dependency for the file. (Empty for an external binary)
# The second value is the path to the file suitable for executing it, taking
# into account the setting of 'chdir'.
proc find-project-bin {bin args} {
	set opts [list -chdir 0 -optional 0 {*}$args]

	set localbin [make-local $bin]

	if {[is-target? $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin is a local target}
		if {$opts(-chdir)} {
			set result [list $localbin ./$bin]
		} else {
			# Note: Use [build-dir] here rather than [file-build] to retain ./
			#       if building in-tree
			set result [list $localbin [build-dir]/$localbin]
		}
	} elseif {[regexp {^<bin>(.*)} $bin -> basename]} {
		dputxs l {[find-source-location]: find-project-bin: $bin is a publish target}
		set publishbin [publish-prefix bin]$basename
		if {$opts(-chdir)} {
			# We will be running in [file-build [local-dir]],
			# while the executable to run is in [file-build $PUBLISH/bin]
			# So calculate a relative path
			set curdir [file-build [local-dir]]
			set builddir [publish-path bin]
			# It can't hurt to create the $PUBLISH/bin here and it makes relative-path always work
			file mkdir $builddir
			set reldir [relative-path $builddir $curdir]

			set result [list $bin $reldir/$basename]
		} else {
			set result [list $bin [file-build $publishbin]]
		}
	} elseif {[file exists $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin exists as source}
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			set result [list $localbin [file-src-relative $localbin]]
		} else {
			set result [list $localbin $localbin]
		}
	} elseif {$opts(-optional)} {
		dputxs l {[find-source-location]: find-project-bin: $bin is assumed to be external}
		set result [list "" $bin]
	} else {
		# Not found
		dev-error "$bin is neither a local nor a published (<bin>) target"
	}
	dputxs l {[find-source-location]: find-project-bin returning $result}
	return $result
}

add-deferred-action {
	# Need to add $PUBLISH/include to the include paths
	IncludePaths --build [publish-dir include]
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

rule Executable {args} {
Executable --test --chdir --nobuild --publish --strip --install=<dir> target sources...

Builds an executable from one or more source files. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the executable.

Imported variables: CCLD (from Linker), LD_FLAGS (from LinkFlags), PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS

The following options are supported:
  --test              Marks the executable as a test (see Test)
  --chdir             This options is passed to Test if --test is also specified.
  --nobuild           Don't make this executable dependent on phony 'all', which is otherwise the default
  --publish           Publishes the executable (see PublishBin)
  --install=<dir>     Install the executable to the given directory (see InstallFile)
  --strip             Marks the executable to be stripped when installed (see InstallFile)
} {
	show-this-rule
	getopt {--test --chdir --nobuild --publish --strip --install: target args} args

	set localtarget [make-local $target]
	set targetexe $target[get-define EXEEXT]
	set localtargetexe $localtarget[get-define EXEEXT]

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	define? CCLD [get-define CC]

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target $localtargetexe -inputs {*}$objects [get-define LOCAL_LIBS] -depends [get-define PROJDEPS] -msg {note Link $targetname} -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $PROJLIBS $SYSLIBS
	} -getvars CCLD LD_FLAGS PROJLIBS SYSLIBS {*}[target-alias $target $targetexe]
	Clean $targetexe

	if {$publish} {
		PublishBin $target
	}

	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags strip
		}
		InstallFile [file-join $install $targetexe] $localtargetexe $flags
	}
	if {$test} {
		if {$chdir} {
			Test --chdir $target
		} else {
			Test $target
		}
	} elseif {!$nobuild} {
		Phony all $localtargetexe
	}
}

rule PublishBin {args} {
PublishBin ?--script? name ...

Publishes one or more executables (either binaries or scripts)
Unless --script is specified, the executable extension (e.g. .exe) is used.

Note that 'name' can be 'target=src' to rename a file when published.
ObjectRule.cpp object source
} {
	show-this-rule

	getopt {--script args} args

	set destdir [publish-dir bin]

	if {$script} {
		set exe ""
	} else {
		set exe [get-define EXEEXT]
	}


	foreach {dest src} [expand-filespec $destdir $args 0] {
		hard-link $dest$exe $src$exe -vars dest bin/$dest -msg {note Publish $targetname} -alias <bin>[file tail $dest]
	}
}

rule Publish {args} {
Publish ?--keepdir? dir name...

Publishes one or more files to directory $PUBLISH/$dir

Accepts the following file names:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (.e.g *.img)

Normally files are publish directly into $PUBLISH/$dir, but if --keepdir is
specified, the relative source directory is kept and replicated under $PUBLISH/$dir

Note: Libraries and Binaries should not be published with this rule.
Rather Publishlib and PublishBin should be used.
} {
	show-this-rule
	getopt {--keepdir dir args} args

	if {$dir eq "bin"} {
		user-notice purple [warning-location "Warning: Use PublishBin to publish binaries"]
	}
	if {$dir eq "lib" && [string match lib* $args]} {
		user-notice purple [warning-location "Warning: Use Lib --publish to publish libraries"]
	}

	foreach {dest src} [expand-filespec $dir $args $keepdir] {
		publish-one-file $dest $src
	}
}

rule ArchiveLib {args} {
ArchiveLib ?--publish? ?--install=<dir>? basename sources...

Creates an archive library from the given sources
XXX
} {
	show-this-rule
	getopt {--publish --install: basename args} args

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set libname lib$basename.a
	set libalias <lib>$basename

	set locallibname [make-local $libname]
	target $locallibname -inputs {*}$objects -msg {note Ar $targetname} -do {
		file delete $target
		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target
	}

	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $locallibname
	Clean $libname
	define-append LOCAL_LIBS $locallibname

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $locallibname
	}
	if {$publish} {
		publish-lib $libname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects
	}
}

rule SharedLib {args} {
SharedLib ?--publish? ?--strip? ?--version=<vers>? ?--install=<dir> basename source...

Creates a shared library ...
XXX
} {
	show-this-rule
	getopt {--publish --strip --version: --install: basename args} args

	if {![info exists version]} {
		set version 0
	}

	set n 0
	foreach part [split $version .] {
		if {![string is integer -strict $part]} {
			set n -1
			break
		}
		incr n
	}
	if {$n < 0 || $n > 3} {
		dev-error "Not a valid shared library version number: $version"
	}

	# What names may our shared lib have?
	set nameinfo [list [get-define SH_SOEXTVER] $version %s [get-define SH_SOEXT]]
	if {$n > 1} {
		lappend nameinfo [get-define SH_SOEXTVER] [lindex [split $version .] 0]
	}

	set names {}
	set libname {}

	foreach {fmt version} $nameinfo {
		if {$fmt eq ""} {
			continue
		}
		set name lib$basename[format $fmt $version]
		if {$libname eq {}} {
			set libname $name
		}
		if {$name ni $names} {
			lappend names $name
		}
	}

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set locallibname [make-local $libname]
	set srcs [join $args]
	set libalias <lib>$basename
	ObjectCFlags $srcs [get-define SH_CFLAGS]

	set setsoname {}
	if {[get-define SH_SOPREFIX ""] ne ""} {
		set setsoname [get-define SH_SOPREFIX][file tail $libname]
	}

	define? CCLD [get-define CC]

	# Note: Do not link against local archive libs (LOCAL_LIBS)
	# XXX: Here we use $LDFLAGS to capture any user-specied link flags (.e.g. -mbig-endian).
	#      Assume that these are required both for shared libs and for executables.
	#      Is it necessary to separate these two?
	#      Also, is LinkFlags/LD_FLAGS also required?

	target $locallibname -inputs {*}$objects -depends [get-define PROJDEPS] -msg {note SharedLib $targetname} -do {
		run $CCLD $SH_LDFLAGS $LDFLAGS -o $target $setsoname {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS -vars setsoname $setsoname
	Clean $locallibname

	# Only the fully versioned named is built in the local dir
	Phony libs $locallibname
	Clean $libname

	# Note: --publish is dummy. Shared libs always need to be published to be used
	incr publish

	if {$publish} {
		# Publish along with the various symlinks and create an alias
		publish-shared-lib $names $locallibname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects

		# Local executables only link against this lib if it is published
		# The reason is that it gets difficult to manage LD_LIBRARY_PATH or equalivalent.
		# If the shared lib is published, a single definition of LD_LIBRARY_PATH=$PUBLISH/lib will work for all shared libs
		# Thus UseLibs here rather than adding to LOCAL_LIBS

		UseLibs $basename
	}
	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags striplib
		}

		install-shared-lib $install $names $locallibname $flags
	}
}

# If desired, this can be aliased to SharedLib in project.spec
alias Lib ArchiveLib

rule SharedObject {args} {
SharedObject ?--install=<dir>? target sources...

Builds a dynamically loadable shared object from the given sources.
For each source, the appropriate ObjectRule is used to generate the object file,
and these files are linked (along with any libraries) to create the loadable object.

Imported variables: CCLD (from Linker), SHOBJ_LDFLAGS (must be set appropriately),
                    PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS, SHOBJ_CFLAGS (must be set appropriately)

Note that sources are marked to be built with SHOBJ_CFLAGS via ObjectCFlags.

The following options are supported:
  --install=<dir>     Install the shared object to the given directory (see InstallFile)
} {
	show-this-rule

	getopt {--install: target args} args

	set srcs [join $args]

	define? CCLD [get-define CC]

	# Must build objects with -fpic, etc.
	ObjectCFlags $srcs [get-define SHOBJ_CFLAGS]

	set localtarget [make-local $target]

	target $localtarget -inputs {*}[Objects $srcs] -depends [get-define PROJDEPS] -msg {note SharedObject $targetname} -do {
		run $CCLD $SHOBJ_LDFLAGS -o $target {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS
	Clean $target
	Phony all $localtarget

	if {[info exists install]} {
		Install --bin $install $target
	}
}

rule Objects {args} {
Objects source...

Create an object file from each source file
Uses $OBJSRULES(.ext) to determine the build rule
Returns a list of objects
Accepts object files (.o) in addition to source files
and simply returns them
} {
	show-this-rule
	set args [join $args]
	set objs {}
	foreach src $args {
		if {[string match <lib>* $src]} {
			lappend objs $src
		} else {
			lappend objs [Object [change-ext .o $src] $src]
		}
	}
	return $objs
}

rule Object {target src} {
Object obj src

Creates object $target from source $src by using the appropriate ObjectRule
} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		if {[info commands ObjectRule$ext] eq ""} {
			dev-error "Don't know how to build Object from $src"
		}
		ObjectRule$ext $obj $src
		Clean $target
	}
	return $obj
}

rule ObjectCFlags {srcs args} {
ObjectCFlags srcs ...

Like CFlags, but instead of adding C_FLAGS for all subsequent rules, adds
C_FLAGS only to the objects created from the given sources.

$srcs is a list of source files
} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

rule CFlags {args} {
CFlags ...

Add the given flags to C_FLAGS (used in ObjectRule.c)
e.g.  CFlags -DABC=7

Note that to pass a string value, it generally sufficient to quote it normally:

  CFlags -DVERSION="v1.0"

However if the value contains spaces, quote with a double backslash:

  CFlags -DVERSION="prog\\ v1.0"
} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

rule C++Flags {args} {
C++Flags ...

Add the given flags to CXX_FLAGS (used in ObjectRule.cpp)

See CFlags
} {
	define-append CXX_FLAGS {*}$args
}

rule LinkFlags {args} {
LinkFlags ...

Add the given flags to LD_FLAGS (used in Executable and SharedLib)
} {
	define-append LD_FLAGS {*}$args
}

rule Linker {linker} {
Linker prog

Defines the linker to use for subsequent Executable and SharedLib.
By default $CC is used. For C++ applications, it is typical to set:

  Linker $CXX
} {
	define CCLD $linker
}

rule UseLibs {args} {
UseLibs ...

XXX
} {
	# Create/append to PROJLIBS (the link line)
	if {[get-define PROJLIBS] eq ""} {
		define PROJLIBS "-L[publish-path lib]"
	}
	define-append PROJLIBS [prefix -l $args]

	# Now the dependencies
	define-append PROJDEPS [prefix <lib> $args]
}

rule IncludePaths {args} {
IncludePaths ?--build? ?--source? paths...

XXX
} {
	show-this-rule

	getopt {--build --source args} args

	if {!$build && !$source} {
		# No options means both
		incr build
		incr source
	}

	set srcdir [local-dir]
	set builddir [file-build [local-dir]]

	foreach dir $args {
		set srcpath [file-join $srcdir $dir]
		set buildpath [file-join $builddir $dir]

		if {$srcpath in [get-define INCPATHS]} {
			dputs m "IncludePaths: Ignoring duplicate $srcpath"
			# Already have this one added, so ignore it
			continue
		}
		define-append INCPATHS $srcpath
		if {$source} {
			CFlags [prefix -I $srcpath]
			C++Flags [prefix -I $srcpath]
		}
		if {$build} {
			CFlags [prefix -I $buildpath]
			C++Flags [prefix -I $buildpath]
		}
	}
}

rule Load {args} {
Load ...

XXX
} {
	show-this-rule

	getopt {--nocare --config filename} args

	# XXX: Should we allow loading an out-of-tree file?

	if {[is-target? $filename]} {
		set f [file-build $filename]
		dputs m "Load: $filename is a target => $f"
	} elseif {[file exists $filename]} {
		dputs m "Load: $filename is source"
		set f $filename
		lappend result $f
	} elseif {![is-cleaning?] && !$nocare} {
		build-error [warning-location "Error: Load $filename does not exist and is not a target"]
		tmake-exit 1
	}

	if {[info exists f] && [file exists $f]} {
		if {$config} {
			dputs m "load-config-file $f"
			load-config-file $f
		} else {
			dputs m "source $f"
			source $f
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	add-project-file $filename $nocare
}

rule UseSystemLibs {args} {
UseSystemLibs ...

XXX
} {
	define-append SYSLIBS {*}$args
}

rule PublishIncludes {args} {
PublishIncludes ...

XXX
} {
	show-this-rule
	getopt {--keepdir args} args
	set args [join $args]

	foreach {dest src} [expand-filespec include $args $keepdir] {
		publish-one-file $dest $src
	}
}

# Run an executable test
# The executable must be built in the current dir
#
rule Test {args} {
Test --interp=<interp> --chdir --quiet command args

XXX
} {
	show-this-rule

	getopt {--interp: --chdir --quiet command args} args
	set testid [get-test-id]
	set depends {}
	set localcommand [make-local $command]

	set opts {}
	set deps {}
	set vars {}
	set testcommand {}

	if {$chdir} {
		lappend opts -chdir
	}
	if {!$quiet} {
		lappend opts -msg [list note Test $localcommand]
	}

	# If there is an interpreter, find it
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir -optional 1] dep filename

		# In this case, the command is a script - find it
		lassign [find-project-bin $command -chdir $chdir -optional 0] cmddep scriptpath
		lappend vars testcommand [list $filename $scriptpath {*}$args]

		if {$dep ne ""} {
			lappend deps $dep
		}

	} else {
		# Find the local or published command and add it to the command and deps
		lassign [find-project-bin $command -chdir $chdir -optional 0] dep filename

		lappend vars testcommand [list $filename {*}$args]
		lappend deps $dep
	}

	# set up srcpath to allow the test command/script to find resources
	if {$chdir} {
		# We are in objdir/... and we need to find [local-dir] from src
		lappend vars SRCDIR [file-src-relative [local-dir]]
	} else {
		lappend vars SRCDIR [local-dir]
	}

	target [make-local $testid] -phony -depends $deps -vars {*}$vars {*}$opts -do {
		run-test-command $testcommand
	}
	Phony test [make-local $testid]

	return $testid
}

rule CopyFile {dest source} {
CopyFile dest source

XXX
} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg [list note Copy $dest] -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

rule InstallFile {dest src {flags {}}} {
InstallFile dest src ?flags?

XXX Installs the 
} {
	show-this-rule

	#puts "InstallFile $dest $src"

	set destfile [get-define DESTDIR]$dest

	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}
	# Note that we pass variable $dest purely so we can show a nice path in the message
	target $destfile -nocache -inputs $src -vars dest $dest flags $flags -msg {note Install $dest} -do {
		install-file $target $inputs $flags
	}
	target install -depends $destfile

	# This file also needs to be uninstalled
	add-clean uninstall $destfile

	return $destfile
}

rule Install {args} {
Install ?--bin? ?--strip? ?--keepdir? destdir file-spec...

A convenience wrapper around InstallFile to allow multiple files to be installed at once.
See InstallFile for more details.

The following arguments are supported:
  --bin               Adds 'bin' to the InstallFile flags
  --strip             Adds 'strip' to the InstallFile flags
  --keepdir           Passes --keepdir to InstallFile
  destdir             Installs to the given directory
  file-spec...        A file specification for files to be installed. See 'File specifications' above.
} {
	show-this-rule

	getopt {--bin --strip --keepdir destdir args} args
	set args [join $args]
	set flags {}
	if {$bin} {
		lappend flags bin
	}
	if {$strip} {
		lappend flags strip
	}

	set srcs {}
	foreach {dest src} [expand-filespec $destdir $args $keepdir] {
		lappend srcs $src
		InstallFile $dest $src $flags
	}
	return $srcs
}

rule Clean {args} {
Clean target ...

Adds the given targets to the list of files to be removed on 'tmake clean'
} {
	# DistClean also cleans these files
	DistClean {*}$args

	set args [join $args]

	add-clean [make-local clean] [make-local {*}$args]
}

rule DistClean {args} {
DistClean target ...

Adds the given targets to the list of files to be removed on 'tmake distclean'
} {
	set args [join $args]

	add-clean [make-local distclean] [make-local {*}$args]
}

rule Generate {args} {
Generate ?--interp=<interp>? ?--chdir? target generator inputs rules target-args...

A general purpose rule to create a target via a generator (program or script).
The arguments are as follows:
  --interp   Optional built or external program required to run the generator. Available as $interp
  --chdir    If specified, the generator runs from the local directory
  target     The target to generator. May be a list of one or more targets. Available as $target
  generator  The generator program or script. May be a local built target, a published built target
             (in which case the <bin> prefix is used), or empty for none. Available as $script
  inputs     Local files that are inputs to the generator. Available as $inputs
  rules      A -do script that generates the target
  target-args  Additional arguments to 'target'

The following is an example of a local, built generator.

  Executable mkindex mkindex.c
  Generate page_index.h mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex' were created in another directory and published with 'Executable --publish'
or 'PublishBin', we would use the following:

  Generate page_index.h <bin>mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex.rb' were a script that used a locally built version of 'ruby' to run, we would use:

  Generate --interp=<bin>ruby page_index.h mkindex.rb *.c {
    run $interp $script -o $target $inputs
  }

} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: --chdir target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script -chdir $chdir] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	if {$chdir} {
		lappend args -chdir
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $targetname} {*}$args
	Clean $target
}

rule Depends {target args} {
Depends target target-args...

Creates a local target with the given additional target arguments.
} {
	target [make-local {*}$target] -depends {*}$args
}

rule Phony {target args} {
Phony target target-args...

Creates a Phony, local target with the given additional target arguments.
} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	user-notice purple [warning-location "Warning: LocalMakefile is deprecated and ignored"]
}

rule DefaultTarget {name} {
DefaultTarget target

Sets the default (local) target.
i.e. when tmake is invoked with no options.
The default is 'all'
} {
	show-this-rule
	set-default-target $name
}

rule HostLibs {args} {
HostLibs ...

Like UseSystemLibs, but for host builds with HostExecutable.
Adds the given arguments to HOST_SYSLIBS
} {
	define-append HOST_SYSLIBS {*}$args
}

rule HostExecutable {target args} {
HostExecutable target sources ...

A very simple version of Executable for building host (as opposed to target) applications.

Imported variables: HOST_CFLAGS, HOST_SYSLIBS (from HostLibs)
Used variables: CC_FOR_BUILD (default to cc)

Note: HostExecutable and HostLibs are stopgaps until separate build contexts are fully support
} {
	set localtarget [make-local $target]

	set localtargetexe $localtarget[get-define HOST_EXEEXT]
	set targetexe $target[get-define HOST_EXEEXT]

	target $localtargetexe -inputs {*}[make-local {*}$args] -msg {note HostExecutable $targetname} -getvars HOST_CFLAGS HOST_SYSLIBS -do {
		run $CC_FOR_BUILD $HOST_CFLAGS -o $target $inputs $HOST_SYSLIBS
	} -dyndep {
		header-scan-regexp-recursive $local "" $CHDRPATTERN
	} {*}[target-alias $target $targetexe]

	PublishBin $target
	Clean $targetexe

	return $localtarget
}

# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans

DistClean .makecache

# Invoked manually
Phony clean-orphans -do {
	clean-files [get-orphan-targets] "orphan targets"
	discard-orphan-targets
	if {[file exists .trash]} {
		note Clean .trash
		file delete -force .trash
	}
}

# @delete-orphan-files files ...
#
# This callback is invoked to delete orphans
# This version replaces the builtin version.
# Instead of deleting files immediately, orphans are moved into
# the .trash directory. This directory is only removed via the
# 'clean', 'distclean' or 'clean-orphans' targets.
proc delete-orphan-files {args} {
	file mkdir .trash
	foreach file $args {
		if {[file exists $file]} {
			file rename -force $file .trash/[string map {/ _} $file]
		}
	}
}
