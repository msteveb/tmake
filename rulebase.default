# vim:set syntax=tcl:
# These are the built-in rules
#
# They can be replaced if necessary

# @synopsis:
#
# rulebase.default is the default tmake rulebase...
#
# The following environment variables are used if set:
#
## CC       - C compiler
## CXX      - C++ compiler
## ...

use getopt glob

# ==================================================================
# Default variable settings and rules
# ==================================================================

# If settings are loaded via Load, these should all be ignored
# Thus we use define?
define? CCACHE ""
define? CC cc
define? CXX c++
define? AR ar
define? RANLIB ranlib
define? STRIP strip
define? ARFLAGS cr
define? CFLAGS ""
define? CXXFLAGS ""
define? LDFLAGS ""
define? EXEEXT ""

define? SH_CFLAGS ""
define? SH_LDFLAGS ""
define? SH_LINKFLAGS ""
define? SH_SOEXT .so
define? SHOBJ_CFLAGS ""
define? SHOBJ_LDFLAGS ""

define? CC_FOR_BUILD cc
define? HOST_CFLAGS ""
define? HOST_EXEEXT ""

define? LOCAL_LIBS ""
define? DESTDIR ""
define? OBJCFLAGS ""
define? INCPATHS ""

# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
define C_FLAGS ""
define CXX_FLAGS ""
define LD_FLAGS ""

define PUBLISH publish

define PROJLIBS ""
define SYSLIBS ""
define HOST_SYSLIBS ""

# Default header pattern for C and C++ dynamic dependencies
#
# All globals variables for rulebase.default are kept in the $::tmakedrb array
set ::tmakedrb {
	testruncount 0
	testpasscount 0
	testid 0
	setuptestenv 0
	objmap {}
}

# ==================================================================
# Help Overview
# ==================================================================
rule-overview {
This is rulebase.default, the default tmake rulebase. Note the following conventions:

File specifications for Install and Publish rules support the following forms:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (e.g. *.png)

For rules that set variables/flags, those definitions apply to rules later in the file.
For example, when setting C_FLAGS with CFlags, those flags are used by subsequent
Object and Executable rules, but not earlier rules.

(Note: When Scope is implemented, it will allow explicitly limiting the scope of these definitions)

Note that by default, Lib is an alias for ArchiveLib. This can be changed with:
  alias Lib SharedLib
}

# ==================================================================
# BUILT-IN Object Rules
# ==================================================================

define CHDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

# @ObjectRule.<ext> object source
#
# Rule for creating 'object' from source file 'source' with the
# extentions 'ext'.
#
# The appropriate ObjectRule.<ext> is invoked from Object
# (and hence Objects, Executable and Lib) based on the extension.

rule ObjectRule.c {obj src} {
ObjectRule.c object source

Generates an object file from a C source file

Imported variables: CC, C_FLAGS (from CFlags, ObjectCFlags), INCPATHS (from IncludePaths)
Used variables: CFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	# Capture the current value of CC, C_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note Cc $targetname} -getvars CC C_FLAGS INCPATHS -do {
		run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

rule ObjectRule.cpp {obj src} {
ObjectRule.cpp object source

Generates an object file from a C++ source file

Imported variables: CXX, CXX_FLAGS (from C++Flags), INCPATHS (from IncludePaths)
Used variables: CXXFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	# Capture the current value of CXX, CXX_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note C++ $targetname} -getvars CXX CXX_FLAGS INCPATHS -do {
		run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc BuildSpecProlog {} {
	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			set localtarget [make-local $t]
			target $localtarget -phony
			target $parentprefix$t -phony -depends $localtarget
		}
		Phony install install
		Phony uninstall uninstall
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}
}

proc BuildSpecEpilog {} {
	global tmake

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	# Ensure that even directories with no targets are removed
	Clean __dummy__
}

# ==================================================================
# UTILTY PROCS
# ==================================================================

# @target-alias target targetexe
#
# On some systems, executables are identified with an extension (e.g. .exe)
# For cross-platform compatibility, rules omit this extension and an alias is used
# to link to the actual filename.
#
# This command checks the rule name (e.g. abc) and the executable name (e.g. abc.exe)
# and if they are the same, returns an appropriate target alias for the executable
# (e.g. -alias abc). Otherwise an empty list is returned.
#
proc target-alias {target targetexe} {
	if {$target ne $targetexe} {
		return [list -alias [make-local $target]]
	}
	return ""
}

# @publish-path dir
#
# Returns the path to the given 'publish' subdirectory,
# e.g. [publish-path include] returns something like objdir/.publish/include
#
proc publish-path {dir} {
	file-build [file-join [get-define PUBLISH] $dir]
}

# @publish-dir dir
#
# Returns the path to the given 'publish' subdirectory relative to the build directory
# e.g. [publish-dir include] returns something like .publish/include
#
proc publish-dir {dir} {
	file-join [get-define PUBLISH] $dir
}

# @publish-prefix dir
#
# Like publish-dir, but returns the value suitable to be used as a prefix
#
proc publish-prefix {dir} {
	make-prefix [publish-dir $dir]
}

# @publish-one-file dest src
#
# Creates a rule to publish $src as $dest (build relative name) by creating a hard link.
# e.g. publish-one-file include/header.h header.h
#
proc publish-one-file {dest src} {
	#puts "publish-one-file: dest=$dest, src=$src, realdest=[publish-dir $dest]"
	hard-link [publish-dir $dest] $src -msg {note Publish $targetname}
}

# @publish-lib libname alias
#
# Creates a rule to publish an archive library, $libname, to the $PUBLISH/lib directory.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-lib {libname alias} {
	hard-link [publish-prefix lib]$libname [make-local $libname] -msg {note Publish $targetname} -alias $alias
}

# @make-shlib-symlinks first ...
#
# Create symlinks such that each of the given args is a symlink to $first.
# All paths/names should be in the same directory
#
proc make-shlib-symlinks {first args} {
	foreach alias $args {
		exec ln -s -f [file tail $first] $alias
	}
}

# @publish-shared-lib names source alias
#
# Creates a rule to publish a shared library, $source, with the given names to the
# $PUBLISH/lib directory.
# This includes creating appropriate symlinks.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-shared-lib {names source alias} {
	set published [prefix [publish-prefix lib] {*}$names]

	target $published -inputs $source -msg {note Publish [lindex $targetname 0]} -do {
		file delete {*}$target
		exec ln -f $inputs [lindex $target 0]
		make-shlib-symlinks {*}$target
	} -vars libname [lindex $names 0] -alias $alias
	add-clean [make-local clean] $published
	add-clean [make-local distclean] $published
}

# @install-shared-lib dest names source flags
#
# Creates a rule to install a shared library, $source, to install directory $dest
# This includes creating appropriate symlinks.
# $flags are passed to install-file and should either be empty, or "striplib".
proc install-shared-lib {dest names source flags} {
	set installed [prefix [make-prefix [get-define DESTDIR]$dest] $names]

	target $installed -nocache -inputs $source -msg {note Install $libname} -do {
		file delete {*}$target
		install-file [lindex $target 0] $inputs $flags
		make-shlib-symlinks {*}$target
	} -vars flags $flags libname [file-join $dest [lindex $names 0]]

	target install -depends {*}$installed
	add-clean uninstall $installed
}

# @expand-filespec dir filelist keepdir
#
# Implements target renaming/globbing for Publish and Install
#
# $dir is the target directory
# $filelist is the file specification
# $keepdir is a boolean which indicates whether to keep the source dir in the target name
#
# The file specification may include:
# - Regular filenames
# - Renaming rules of the form: target=src
# - Glob patterns
#
# Returns a list of the form: target1 source1 target2 source2 ...
proc expand-filespec {dir filelist keepdir} {
	set result {}

	foreach spec $filelist {
		if {$spec eq ""} {
			continue
		}
		if {[string match *=* $spec]} {
			lassign [split $spec =] target src
			lappend result [file-join $dir $target] [make-local $src]
			continue
		}
		if {[string match {*[{}*?]*} $spec]} {
			set srcs [Glob --all $spec]
		} else {
			set srcs $spec
		}
		foreach src $srcs {
			if {$keepdir} {
				lappend result [file-join $dir $src] [make-local $src]
			} else {
				lappend result [file-join $dir [file tail $src]] [make-local $src]
			}
		}
	}
	#puts "expand-filespec: $filelist => $result"
	return $result
}

# @expand-objects objs
#
# Expands a list of objects which may contain library aliases of the form <lib>$basename
# Each library alias is expanded into the list of objects for that library.
# (Note that SharedLib and ArchiveLib create an object list when creating libraries)
# Any non-aliases are left unchanged.
# 
# Returns the expanded object list.
proc expand-objects {objs} {
	set result {}
	foreach obj $objs {
		if {[string match <lib>* $obj]} {
			if {![dict exists $::tmakedrb(objmap) $obj]} {
				build-error "Error: Unable to find objects for unknown lib $obj"
				return -code break
			}
			# XXX: How to guarantee that $SH_CFLAGS are set on these objects?
			# (Either directly via ObjectCFlags or with a top-level CFlags)
			#
			lappend result {*}[file-build [dict get $::tmakedrb(objmap) $obj]]
		} else {
			lappend result $obj
		}
	}
	#puts "expand-objects $objs =>\n$result"
	return $result
}

# @load-config-file filename
#
# XXX explain how config files are loaded...
proc load-config-file {filename} {
	# All lines look like one of:
	#CONFIG_BOOL_VALUE=y (or m)
	#CONFIG_STR_VALUE="string value"
	#CONFIG_INT_VALUE=123
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			dputs c "define $name $value"
			define $name $value
		} else {
			user-notice purple "$filename:$n: Warning: Failed to parse $line"
		}
	}
	if {$n == 0} {
		user-notice purple "Warning: $filename contains no configuration"
	}
}

# @setup-test-env
#
# XXX helper for Test
proc setup-test-env {} {
	# Set up LD_LIBRARY_PATH (or equivalent) for tests
	set ldlibpath [get-define LD_LIBRARY_PATH]
	if {$ldlibpath ne ""} {
		set path [getenv $ldlibpath ""]
		# Must use a full path here since tests do chdir
		set addlib [file-join [get-define TOPBUILDDIR] [publish-dir lib]]
		append-with-space path $addlib $::tcl_platform(pathSeparator)
		setenv $ldlibpath $path
	}
}

# @get-test-id
#
# XXX helper for Test
proc get-test-id {} {
	return test#[incr ::tmakedrb(testid)]
}

# @run-test-command
#
# XXX helper for Test
# Note that we don't pass SRCDIR explictly to keep the
# 'tmake -n' output clean
proc run-test-command {testcommand} {
	setup-test-env
	setenv SRCDIR [uplevel 1 set SRCDIR]
	setenv TOPBUILDDIR [uplevel 1 set TOPBUILDDIR]
	incr ::tmakedrb(testruncount)
	run $testcommand
	incr ::tmakedrb(testpasscount)
}

# @hard-link ?--fallback? dest source ?options...?
#
# XXX
proc hard-link {args} {
	#show-this-rule

	getopt {--fallback dest source args} args

	# XXX: If the platform doesn't support hard links
	# and --fallback is set, fall back to soft links
	# and then to file copy
	# Want to depend on the existence of the dir, not the time
	target $dest -inputs $source -do {
		file delete $target
		exec ln $inputs $target
	} {*}$args
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# @install-file target source flags
#
# XXX
# Helper for installing files
proc install-file {target source flags} {
	vputs "Copy $source $target"
	file copy -force $source $target
	if {"bin" in $flags} { chmodx-file $target }
	if {"strip" in $flags} { strip-file [get-define STRIPFLAGS {}] $target }
	if {"striplib" in $flags} { strip-file [get-define STRIPLIBFLAGS {}] $target }
}

# @chmodx-file target
#
# Makes the given file executable with chmod +x
proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

# @strip-file flags target
#
# Invokes '$STRIP $flags $target' to strip the given executable
#
# If $STRIP is not set, does nothing
proc strip-file {flags target} {
	vputs "Strip $target"
	exec {*}[get-define STRIP true] {*}$flags $target
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

rule Executable {args} {
Executable --test --chdir --nobuild --publish --strip --install=<dir> target sources...

Builds an executable from one or more source files. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the executable.

Imported variables: CCLD (from Linker), LD_FLAGS (from LinkFlags), PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS

The following options are supported:
  --test              Marks the executable as a test (see Test)
  --chdir             This options is passed to Test if --test is also specified.
  --nobuild           Don't make this executable dependent on phony 'all', which is otherwise the default
  --publish           Publishes the executable (see PublishBin)
  --install=<dir>     Install the executable to the given directory (see InstallFile)
  --strip             Marks the executable to be stripped when installed (see InstallFile)
} {
	show-this-rule
	getopt {--test --chdir --nobuild --publish --strip --install: target args} args

	set localtarget [make-local $target]
	set targetexe $target[get-define EXEEXT]
	set localtargetexe $localtarget[get-define EXEEXT]

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	define? CCLD [get-define CC]

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target $localtargetexe -inputs {*}$objects [get-define LOCAL_LIBS] -depends [get-define PROJDEPS] -msg {note Link $targetname} -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $PROJLIBS $SYSLIBS
	} -getvars CCLD LD_FLAGS PROJLIBS SYSLIBS {*}[target-alias $target $targetexe]
	Clean $targetexe

	if {$publish} {
		PublishBin $target
	}

	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags strip
		}
		InstallFile [file-join $install $targetexe] $localtargetexe $flags
	}
	if {$test} {
		if {$chdir} {
			Test --chdir $target
		} else {
			Test $target
		}
	} elseif {!$nobuild} {
		Phony all $localtargetexe
	}
}

rule PublishBin {args} {
PublishBin ?--script? name ...

Publishes one or more executables (either binaries or scripts)
Unless --script is specified, the executable extension (e.g. .exe) is used.

Note that 'name' can be 'target=src' to rename a file when published.
ObjectRule.cpp object source
} {
	show-this-rule

	getopt {--script args} args

	set destdir [publish-dir bin]

	if {$script} {
		set exe ""
	} else {
		set exe [get-define EXEEXT]
	}


	foreach {dest src} [expand-filespec $destdir $args 0] {
		hard-link $dest$exe $src$exe -vars dest bin/$dest -msg {note Publish $targetname} -alias <bin>[file tail $dest]
	}
}

rule Publish {args} {
Publish ?--keepdir? dir name...

Publishes one or more files to directory $PUBLISH/$dir

Accepts the following file names:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (.e.g *.img)

Normally files are publish directly into $PUBLISH/$dir, but if --keepdir is
specified, the relative source directory is kept and replicated under $PUBLISH/$dir

Note: Libraries and Binaries should not be published with this rule.
Rather Publishlib and PublishBin should be used.
} {
	show-this-rule
	getopt {--keepdir dir args} args

	if {$dir eq "bin"} {
		user-notice purple [warning-location "Warning: Use PublishBin to publish binaries"]
	}
	if {$dir eq "lib" && [string match lib* $args]} {
		user-notice purple [warning-location "Warning: Use Lib --publish to publish libraries"]
	}

	foreach {dest src} [expand-filespec $dir $args $keepdir] {
		publish-one-file $dest $src
	}
}

rule ArchiveLib {args} {
ArchiveLib ?--publish? ?--install=<dir>? basename sources...

Creates an archive library from the given sources
XXX
} {
	show-this-rule
	getopt {--publish --install: basename args} args

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set libname lib$basename.a
	set libalias <lib>$basename

	set locallibname [make-local $libname]
	target $locallibname -inputs {*}$objects -msg {note Ar $targetname} -do {
		file delete $target
		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target
	}

	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $locallibname
	Clean $libname
	define-append LOCAL_LIBS $locallibname

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $locallibname
	}
	if {$publish} {
		publish-lib $libname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects
	}
}

rule SharedLib {args} {
SharedLib ?--publish? ?--strip? ?--version=<vers>? ?--install=<dir> basename source...

Creates a shared library ...
XXX
} {
	show-this-rule
	getopt {--publish --strip --version: --install: basename args} args

	if {![info exists version]} {
		set version 0
	}

	set n 0
	foreach part [split $version .] {
		if {![string is integer -strict $part]} {
			set n -1
			break
		}
		incr n
	}
	if {$n < 0 || $n > 3} {
		dev-error "Not a valid shared library version number: $version"
	}

	# What names may our shared lib have?
	set nameinfo [list [get-define SH_SOEXTVER] $version %s [get-define SH_SOEXT]]
	if {$n > 1} {
		lappend nameinfo [get-define SH_SOEXTVER] [lindex [split $version .] 0]
	}

	set names {}
	set libname {}

	foreach {fmt version} $nameinfo {
		if {$fmt eq ""} {
			continue
		}
		set name lib$basename[format $fmt $version]
		if {$libname eq {}} {
			set libname $name
		}
		if {$name ni $names} {
			lappend names $name
		}
	}

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set locallibname [make-local $libname]
	set srcs [join $args]
	set libalias <lib>$basename
	ObjectCFlags $srcs [get-define SH_CFLAGS]

	set setsoname {}
	if {[get-define SH_SOPREFIX ""] ne ""} {
		set setsoname [get-define SH_SOPREFIX][file tail $libname]
	}

	define? CCLD [get-define CC]

	# Note: Do not link against local archive libs (LOCAL_LIBS)
	# XXX: Here we use $LDFLAGS to capture any user-specied link flags (.e.g. -mbig-endian).
	#      Assume that these are required both for shared libs and for executables.
	#      Is it necessary to separate these two?
	#      Also, is LinkFlags/LD_FLAGS also required?

	target $locallibname -inputs {*}$objects -depends [get-define PROJDEPS] -msg {note SharedLib $targetname} -do {
		run $CCLD $SH_LDFLAGS $LDFLAGS -o $target $setsoname {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS -vars setsoname $setsoname
	Clean $locallibname

	# Only the fully versioned named is built in the local dir
	Phony libs $locallibname
	Clean $libname

	# Note: --publish is dummy. Shared libs always need to be published to be used
	incr publish

	if {$publish} {
		# Publish along with the various symlinks and create an alias
		publish-shared-lib $names $locallibname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects

		# Local executables only link against this lib if it is published
		# The reason is that it gets difficult to manage LD_LIBRARY_PATH or equalivalent.
		# If the shared lib is published, a single definition of LD_LIBRARY_PATH=$PUBLISH/lib will work for all shared libs
		# Thus UseLibs here rather than adding to LOCAL_LIBS

		UseLibs $basename
	}
	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags striplib
		}

		install-shared-lib $install $names $locallibname $flags
	}
}

# If desired, this can be aliased to SharedLib in project.spec
alias Lib ArchiveLib

# Build a dynamically loadable shared object from objects
rule SharedObject {args} {
SharedObject ?--install=<dir> basename sources...

} {
	show-this-rule

	getopt {--install: target args} args

	set srcs [join $args]

	define? CCLD [get-define CC]

	# Must build objects with -fpic, etc.
	ObjectCFlags $srcs [get-define SHOBJ_CFLAGS]

	set localtarget [make-local $target]

	target $localtarget -inputs {*}[Objects $srcs] -depends [get-define PROJDEPS] -msg {note SharedObject $targetname} -do {
		run $CCLD $SHOBJ_LDFLAGS -o $target {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS
	Clean $target
	Phony all $localtarget

	if {[info exists install]} {
		Install --bin $install $target
	}
}

rule Objects {args} {
Objects source...

Create an object file from each source file
Uses $OBJSRULES(.ext) to determine the build rule
Returns a list of objects
Accepts object files (.o) in addition to source files
and simply returns them
} {
	show-this-rule
	set args [join $args]
	set objs {}
	foreach src $args {
		if {[string match <lib>* $src]} {
			lappend objs $src
		} else {
			lappend objs [Object [change-ext .o $src] $src]
		}
	}
	return $objs
}

rule Object {target src} {
Object obj src

Creates object $target from source $src by using the appropriate ObjectRule
} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		if {[info commands ObjectRule$ext] eq ""} {
			dev-error "Don't know how to build Object from $src"
		}
		ObjectRule$ext $obj $src
		Clean $target
	}
	return $obj
}

rule ObjectCFlags {srcs args} {
ObjectCFlags srcs ...

Like CFlags, but instead of adding C_FLAGS for all subsequent rules, adds
C_FLAGS only to the objects created from the given sources.

$srcs is a list of source files
} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

rule CFlags {args} {
CFlags ...

Add the given flags to C_FLAGS (used in ObjectRule.c)
e.g.  CFlags -DABC=7

Note that to pass a string value, it generally sufficient to quote it normally:

  CFlags -DVERSION="v1.0"

However if the value contains spaces, quote with a double backslash:

  CFlags -DVERSION="prog\\ v1.0"
} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

rule C++Flags {args} {
C++Flags ...

Add the given flags to CXX_FLAGS (used in ObjectRule.cpp)

See CFlags
} {
	define-append CXX_FLAGS {*}$args
}

rule LinkFlags {args} {
LinkFlags ...

Add the given flags to LD_FLAGS (used in Executable and SharedLib)
} {
	define-append LD_FLAGS {*}$args
}

rule Linker {linker} {
Linker prog

Defines the linker to use for subsequent Executable and SharedLib.
By default $CC is used. For C++ applications, it is typical to set:

  Linker $CXX
} {
	define CCLD $linker
}

rule UseLibs {args} {
UseLibs ...

XXX
} {
	# Create/append to PROJLIBS (the link line)
	if {[get-define PROJLIBS] eq ""} {
		define PROJLIBS "-L[publish-path lib]"
	}
	define-append PROJLIBS [prefix -l $args]

	# Now the dependencies
	define-append PROJDEPS [prefix <lib> $args]
}

rule IncludePaths {args} {
IncludePaths ...

XXX
} {
	show-this-rule
	foreach dir $args {
		foreach prefix [list [local-dir] [build-dir]] {
			set dir [file-join $prefix $dir]
			if {$dir ni [get-define INCPATHS]} {
				define-append INCPATHS $dir
				CFlags [prefix -I $dir]
				C++Flags [prefix -I $dir]
			}
		}
	}
}

rule Load {args} {
Load ...

XXX
} {
	show-this-rule

	getopt {--nocare --config filename} args

	# XXX: Should we allow loading an out-of-tree file?

	if {[is-target? $filename]} {
		set f [file-build $filename]
		dputs m "Load: $filename is a target => $f"
	} elseif {[file exists $filename]} {
		dputs m "Load: $filename is source"
		set f $filename
		lappend result $f
	} elseif {![is-cleaning?] && !$nocare} {
		build-error [warning-location "Error: Load $filename does not exist and is not a target"]
		tmake-exit 1
	}

	if {[info exists f] && [file exists $f]} {
		if {$config} {
			dputs m "load-config-file $f"
			load-config-file $f
		} else {
			dputs m "source $f"
			source $f
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	lappend ::tmake(projfiles) $filename $nocare
}

rule UseSystemLibs {args} {
UseSystemLibs ...

XXX
} {
	define-append SYSLIBS {*}$args
}

rule PublishIncludes {args} {
PublishIncludes ...

XXX
} {
	show-this-rule
	getopt {--keepdir args} args
	set args [join $args]

	foreach {dest src} [expand-filespec include $args $keepdir] {
		publish-one-file $dest $src
	}
}

# Run an executable test
# The executable must be built in the current dir
#
rule Test {args} {
Test --interp=<interp> --chdir --quiet command args

XXX
} {
	show-this-rule

	getopt {--interp: --chdir --quiet command args} args
	set testid [get-test-id]
	set depends {}
	set localcommand [make-local $command]

	set opts {}
	set deps {}
	set vars {}
	set testcommand {}

	if {$chdir} {
		lappend opts -chdir
	}
	if {!$quiet} {
		lappend opts -msg [list note Test $localcommand]
	}

	# If there is an interpreter, find it
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir -optional 1] dep filename

		# In this case, the command is a script - find it
		lassign [find-project-bin $command -chdir $chdir -optional 0] cmddep scriptpath
		lappend vars testcommand [list $filename $scriptpath {*}$args]

		if {$dep ne ""} {
			lappend deps $dep
		}

	} else {
		# Find the local or published command and add it to the command and deps
		lassign [find-project-bin $command -chdir $chdir -optional 0] dep filename

		lappend vars testcommand [list $filename {*}$args]
		lappend deps $dep
	}

	# set up srcpath to allow the test command/script to find resources
	if {$chdir} {
		# We are in objdir/... and we need to find [local-dir] from src
		lappend vars SRCDIR [file-src-relative [local-dir]]
	} else {
		lappend vars SRCDIR [local-dir]
	}

	target [make-local $testid] -phony -depends $deps -vars {*}$vars {*}$opts -do {
		run-test-command $testcommand
	}
	Phony test [make-local $testid]

	return $testid
}

rule CopyFile {dest source} {
CopyFile dest source

XXX
} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg [list note Copy $dest] -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

rule InstallFile {dest src {flags {}}} {
	show-this-rule

	#puts "InstallFile $dest $src"

	set destfile [get-define DESTDIR]$dest

	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}
	target $destfile -nocache -inputs $src -vars dest $dest flags $flags -msg {note Install $dest} -do {
		install-file $target $inputs $flags
	}
	target install -depends $destfile

	# This file also needs to be uninstalled
	add-clean uninstall $destfile

	return $destfile
}

rule Install {args} {
	show-this-rule

	getopt {--bin --strip --keepdir destdir args} args
	set args [join $args]
	set flags {}
	if {$bin} {
		lappend flags bin
	}
	if {$strip} {
		lappend flags strip
	}

	set srcs {}
	foreach {dest src} [expand-filespec $destdir $args $keepdir] {
		lappend srcs $src
		InstallFile $dest $src $flags
	}
	return $srcs
}

proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# Helper to clean files (and any empty directories)
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# This creates the clean target of the given type, e.g. clean, distclean
#
proc clean-target {type msg} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" -do {
		clean-files $cleanfiles
	}
}

rule Clean {args} {
	# DistClean also cleans these files
	DistClean {*}$args

	getopt {--src args} args
	set args [join $args]

	if {$src} {
		add-clean [make-local clean] [prefix [local-src-prefix] $args]
	} else {
		add-clean [make-local clean] [make-local {*}$args]
	}
}

rule DistClean {args} {
	getopt {--src args} args
	set args [join $args]

	if {$src} {
		add-clean [make-local distclean] [prefix [local-src-prefix] $args]
	} else {
		add-clean [make-local distclean] [make-local {*}$args]
	}
}

# This adds files to be cleaned for the given type
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	#Depends [make-local $type] -vars cleanfiles [file-build $filelist]
	target-add-var $type cleanfiles [file-build $filelist]
}

# Returns a list of {dependency filename}
#
proc find-project-bin {bin args} {
	set opts [list -chdir 0 -optional 0 {*}$args]

	set localbin [make-local $bin]

	if {[is-target? $localbin]} {
		dputxs m {[find-source-location]: find-project-bin: $localbin is a local target}
		if {$opts(-chdir)} {
			set result [list $localbin ./$bin]
		} else {
			# Note: Use [build-dir] here rather than [file-build] to retain ./
			#       if building in-tree
			set result [list $localbin [build-dir]/$localbin]
		}
	} elseif {[regexp {^<bin>(.*)} $bin -> basename]} {
		dputxs m {[find-source-location]: find-project-bin: $bin is a publish target}
		set publishbin [publish-prefix bin]$basename
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			#puts "localbin=$localbin, file-build-relative $publishbin => [file-build-relative $publishbin]"
			#puts "localbin=$localbin, file-build $publishbin => [file-build $publishbin]"
			set result [list $bin ./$publishbin]
		} else {
			set result [list $bin [file-build $publishbin]]
		}
	} elseif {[file exists $localbin]} {
		dputxs m {[find-source-location]: find-project-bin: $localbin exists as source}
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			set result [list $localbin [file-src-relative $localbin]]
		} else {
			set result [list $localbin $localbin]
		}
	} elseif {$opts(-optional)} {
		dputxs m {[find-source-location]: find-project-bin: $bin is assumed to be external}
		set result [list "" $bin]
	} else {
		# Not found
		dev-error "$bin is neither a local nor a published (<bin>) target"
	}
	dputxs m {[find-source-location]: find-project-bin returning $result}
	return $result
}

rule Generate {args} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: --chdir target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script -chdir $chdir] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	if {$chdir} {
		lappend args -chdir
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $targetname} {*}$args
	Clean $target
}

rule Depends {target args} {
	target [make-local {*}$target] -depends {*}$args
}

rule Phony {target args} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	user-notice purple [warning-location "Warning: LocalMakefile is deprecated and ignored"]
}

rule DefaultTarget {name} {
	show-this-rule
	set ::tmake(defaulttarget) $name
}

# XXX: Only useful for simple cases of building a host executable from C sources
# 
rule HostLibs {args} {
	define-append HOST_SYSLIBS {*}$args
}

rule HostExecutable {target args} {
	set localtarget [make-local $target]

	# Hmmm, EXEEXT may be different on the host
	set localtargetexe $localtarget[get-define HOST_EXEEXT]
	set targetexe $target[get-define HOST_EXEEXT]

	target $localtargetexe -inputs {*}[make-local {*}$args] -msg {note HostExecutable $targetname} -getvars HOST_CFLAGS HOST_SYSLIBS -do {
		run $CC_FOR_BUILD $HOST_CFLAGS -o $target $inputs $HOST_SYSLIBS
	} -dyndep {
		header-scan-regexp-recursive $local "" $CHDRPATTERN
	} {*}[target-alias $target $targetexe]

	PublishBin $target
	Clean $targetexe

	return $localtarget
}

proc add-publish-include {} {
	# Can't use IncludePaths here because we only want build paths
	set dir [publish-dir include]
	set path [publish-path include]
	if {$dir ni [get-define INCPATHS]} {
		define-append INCPATHS $dir
		CFlags [prefix -I $path]
		C++Flags [prefix -I $path]
	}
}

# XXX: Use an official API for this
lappend ::tmake(deferred) {
	add-publish-include
}
# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans

DistClean .makecache

# Invoked manually
Phony clean-orphans -do {
	clean-files [get-orphan-targets] "orphan targets"
	discard-orphan-targets
	if {[file exists .trash]} {
		note Clean .trash
		file delete -force .trash
	}
}

# Automatic invocation, so move files to trash
# (This overrides the built-in version which simply deletes)
# .trash will be deleted on 'make clean-orphans' (and thus clean and distclean)
proc delete-orphan-files {args} {
	file mkdir .trash
	foreach file $args {
		if {[file exists $file]} {
			file rename -force $file .trash/[string map {/ _} $file]
		}
	}
}
