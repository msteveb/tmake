# vim:set syntax=tcl:
# These are the built-in rules
#
# They can be replaced if necessary

# @synopsis:
#
# rulebase.default is the default tmake rulebase...
#
# The following environment variables are used if set:
#
## CC       - C compiler
## CXX      - C++ compiler
## ...

use getopt glob

# ==================================================================
# Default variable settings and rules
# ==================================================================

# If settings are loaded via Load, these should all be ignored
# Thus we use define?
define? CCACHE ""
define? CC cc
define? CXX c++
define? AR ar
define? RANLIB ranlib
define? STRIP strip
define? ARFLAGS cr
define? CFLAGS ""
define? CXXFLAGS ""
define? LDFLAGS ""
define? EXEEXT ""

define? SH_CFLAGS ""
define? SH_LDFLAGS ""
define? SH_LINKFLAGS ""
define? SH_SOEXT .so
define? SHOBJ_CFLAGS ""
define? SHOBJ_LDFLAGS ""

define? CC_FOR_BUILD cc
define? HOST_CFLAGS ""
define? HOST_EXEEXT ""

define? LOCAL_LIBS ""
define? DESTDIR ""
define? OBJCFLAGS ""
define? INCPATHS ""

# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
define C_FLAGS ""
define CXX_FLAGS ""
define LD_FLAGS ""

define PUBLISH publish

define PROJLIBS ""
define SYSLIBS ""
define HOST_SYSLIBS ""

# Default header pattern for C and C++ dynamic dependencies
#
# All globals variables for rulebase.default are kept in the $::tmakedrb array
set ::tmakedrb {
	testruncount 0
	testpasscount 0
	testid 0
	setuptestenv 0
	objmap {}
}

# ==================================================================
# BUILT-IN Object Rules
# ==================================================================

define CHDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

# @ObjectRule.<ext> object source
#
# Rule for creating 'object' from source file 'source' with the
# extentions 'ext'.
#
# Allows ...
rule ObjectRule.c {obj src} {
ObjectRule.c object source

Generates an object file from a C source file
} {
	# Capture the current value of CC, C_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note Cc $targetname} -getvars CC C_FLAGS INCPATHS -do {
		run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

rule ObjectRule.cpp {obj src} {
ObjectRule.cpp object source

Generates an object file from a C++ source file
} {
	# Capture the current value of CXX, CXX_FLAGS and INCPATHS
	target $obj -inputs $src -msg {note C++ $targetname} -getvars CXX CXX_FLAGS INCPATHS -do {
		run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
	} -dyndep {
		header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
	}
}

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc BuildSpecProlog {} {
	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			set localtarget [make-local $t]
			target $localtarget -phony
			target $parentprefix$t -phony -depends $localtarget
		}
		Phony install install
		Phony uninstall uninstall
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}
}

proc BuildSpecEpilog {} {
	global tmake

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	# Ensure that even directories with no targets are removed
	Clean __dummy__
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

proc target-alias {target targetexe} {
	if {$target ne $targetexe} {
		list -alias [make-local $target]
	}
}

rule Executable {args} {
Executable --test --chdir --nobuild --publish --strip --install=<dir> target sources...

...
} {
	show-this-rule
	getopt {--test --chdir --nobuild --publish --strip --install: target args} args

	set localtarget [make-local $target]
	set targetexe $target[get-define EXEEXT]
	set localtargetexe $localtarget[get-define EXEEXT]

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	define? CCLD [get-define CC]

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target $localtargetexe -inputs {*}$objects [get-define LOCAL_LIBS] -depends [get-define PROJDEPS] -msg {note Link $targetname} -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $PROJLIBS $SYSLIBS
	} -getvars CCLD LD_FLAGS PROJLIBS SYSLIBS {*}[target-alias $target $targetexe]
	Clean $targetexe

	if {$publish} {
		PublishBin $target
	}

	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags strip
		}
		InstallFile [file-join $install $targetexe] $localtargetexe $flags
	}
	if {$test} {
		if {$chdir} {
			Test --chdir $target
		} else {
			Test $target
		}
	} elseif {!$nobuild} {
		Phony all $localtargetexe
	}
}

proc publish-path {dir} {
	file-build [file-join [get-define PUBLISH] $dir]
}

proc publish-dir {dir} {
	file-join [get-define PUBLISH] $dir
}

proc publish-prefix {dir} {
	make-prefix [publish-dir $dir]
}

proc publish-one-file {dest src} {
	#puts "publish-one-file: dest=$dest, src=$src, realdest=[publish-dir $dest]"
	hard-link [publish-dir $dest] $src -vars dest $dest -msg {note Publish $targetname}
}

proc make-shlib-symlinks {first args} {
	foreach alias $args {
		exec ln -s -f [file tail $first] $alias
	}
}

proc publish-shared-lib {names source alias} {
	set published [prefix [publish-prefix lib] {*}$names]

	target $published -inputs $source -msg {note Publish [lindex $targetname 0]} -do {
		file delete {*}$target
		exec ln -f $inputs [lindex $target 0]
		make-shlib-symlinks {*}$target
	} -vars libname [lindex $names 0] -alias $alias
	add-clean [make-local clean] $published
	add-clean [make-local distclean] $published
}

# XXX: very similar to publish-shared-lib
proc install-shared-lib {dest names source flags} {
	set installed [prefix [make-prefix [get-define DESTDIR]$dest] $names]

	target $installed -nocache -inputs $source -msg {note Install $libname} -do {
		file delete {*}$target
		install-file [lindex $target 0] $inputs $flags
		make-shlib-symlinks {*}$target
	} -vars flags $flags libname [file-join $dest [lindex $names 0]]

	target install -depends {*}$installed
	add-clean uninstall $installed
}

proc expand-filespec {dir filelist keepdir} {
	set result {}

	foreach spec $filelist {
		if {$spec eq ""} {
			continue
		}
		if {[string match *=* $spec]} {
			lassign [split $spec =] target src
			lappend result [file-join $dir $target] [make-local $src]
			continue
		}
		if {[string match {*[{}*?]*} $spec]} {
			set srcs [Glob --all $spec]
		} else {
			set srcs $spec
		}
		foreach src $srcs {
			if {$keepdir} {
				lappend result [file-join $dir $src] [make-local $src]
			} else {
				lappend result [file-join $dir [file tail $src]] [make-local $src]
			}
		}
	}
	#puts "expand-filespec: $filelist => $result"
	return $result
}

rule PublishBin {args} {
PublishBin ?--script? name ...

Publishes one or more executables (either binaries or scripts)
Unless --script is specified, the executable extension (e.g. .exe) is used.

Note that 'name' can be 'target=src' to rename a file when published.
ObjectRule.cpp object source
} {
	show-this-rule

	getopt {--script args} args

	set destdir [publish-dir bin]

	if {$script} {
		set exe ""
	} else {
		set exe [get-define EXEEXT]
	}


	foreach {dest src} [expand-filespec $destdir $args 0] {
		hard-link $dest$exe $src$exe -vars dest bin/$dest -msg {note Publish $targetname} -alias <bin>[file tail $dest]
	}
}

proc publish-lib {libname alias} {
	#show-this-rule

	hard-link [publish-prefix lib]$libname [make-local $libname] -vars dest lib/$libname -msg {note Publish $targetname} -alias $alias
}


rule Publish {args} {
Publish ?--keepdir? dir name...

Publishes one or more files
(Note re bin, lib)

Note that 'name' can be 'target=src' to rename a file when published.
} {
	show-this-rule
	getopt {--keepdir dir args} args

	if {$dir eq "bin"} {
		user-notice purple [warning-location "Warning: Use PublishBin to publish binaries"]
	}
	if {$dir eq "lib" && [string match lib* $args]} {
		user-notice purple [warning-location "Warning: Use Lib --publish to publish libraries"]
	}

	foreach {dest src} [expand-filespec $dir $args $keepdir] {
		publish-one-file $dest $src
	}
}

# Expands a list of objects which may contain library aliases of the form <lib>$basename
# which are then expanded to the list of objects for the library
# The list of objects is created by the ArchiveLib rule
proc expand-objects {objs} {
	set result {}
	foreach obj $objs {
		if {[string match <lib>* $obj]} {
			if {![dict exists $::tmakedrb(objmap) $obj]} {
				build-error "Error: Unable to find objects for unknown lib $obj"
				return -code break
			}
			# XXX: How to guarantee that $SH_CFLAGS are set on these objects?
			# (Either directly via ObjectCFlags or with a top-level CFlags)
			#
			lappend result {*}[file-build [dict get $::tmakedrb(objmap) $obj]]
		} else {
			lappend result $obj
		}
	}
	#puts "expand-objects $objs =>\n$result"
	return $result
}

rule ArchiveLib {args} {
ArchiveLib ?--publish? ?--install=<dir>? basename sources...

Creates an archive library from the given sources
} {
	show-this-rule
	getopt {--publish --install: basename args} args

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set libname lib$basename.a
	set libalias <lib>$basename

	set locallibname [make-local $libname]
	target $locallibname -inputs {*}$objects -msg {note Ar $targetname} -do {
		file delete $target
		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target
	}

	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $locallibname
	Clean $libname
	define-append LOCAL_LIBS $locallibname

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $locallibname
	}
	if {$publish} {
		publish-lib $libname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects
	}
}

rule SharedLib {args} {
SharedLib ?--publish? ?--strip? ?--version=<vers>? ?--install=<dir> basename source...

Creates a shared library ...
} {
	show-this-rule
	getopt {--publish --strip --version: --install: basename args} args

	if {![info exists version]} {
		set version 0
	}

	set n 0
	foreach part [split $version .] {
		if {![string is integer -strict $part]} {
			set n -1
			break
		}
		incr n
	}
	if {$n < 0 || $n > 3} {
		dev-error "Not a valid shared library version number: $version"
	}

	# What names may our shared lib have?
	set nameinfo [list [get-define SH_SOEXTVER] $version %s [get-define SH_SOEXT]]
	if {$n > 1} {
		lappend nameinfo [get-define SH_SOEXTVER] [lindex [split $version .] 0]
	}

	set names {}
	set libname {}

	foreach {fmt version} $nameinfo {
		if {$fmt eq ""} {
			continue
		}
		set name lib$basename[format $fmt $version]
		if {$libname eq {}} {
			set libname $name
		}
		if {$name ni $names} {
			lappend names $name
		}
	}

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set locallibname [make-local $libname]
	set srcs [join $args]
	set libalias <lib>$basename
	ObjectCFlags $srcs [get-define SH_CFLAGS]

	set setsoname {}
	if {[get-define SH_SOPREFIX ""] ne ""} {
		set setsoname [get-define SH_SOPREFIX][file tail $libname]
	}

	define? CCLD [get-define CC]

	# Note: Do not link against local archive libs (LOCAL_LIBS)
	# XXX: Here we use $LDFLAGS to capture any user-specied link flags (.e.g. -mbig-endian).
	#      Assume that these are required both for shared libs and for executables.
	#      Is it necessary to separate these two?
	#      Also, is LinkFlags/LD_FLAGS also required?

	target $locallibname -inputs {*}$objects -depends [get-define PROJDEPS] -msg {note SharedLib $targetname} -do {
		run $CCLD $SH_LDFLAGS $LDFLAGS -o $target $setsoname {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS -vars setsoname $setsoname
	Clean $locallibname

	# Only the fully versioned named is built in the local dir
	Phony libs $locallibname
	Clean $libname

	# Note: --publish is dummy. Shared libs always need to be published to be used
	incr publish

	if {$publish} {
		# Publish along with the various symlinks and create an alias
		publish-shared-lib $names $locallibname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects

		# Local executables only link against this lib if it is published
		# The reason is that it gets difficult to manage LD_LIBRARY_PATH or equalivalent.
		# If the shared lib is published, a single definition of LD_LIBRARY_PATH=$PUBLISH/lib will work for all shared libs
		# Thus UseLibs here rather than adding to LOCAL_LIBS

		UseLibs $basename
	}
	if {[info exists install]} {
		set flags bin
		if {$strip} {
			lappend flags striplib
		}

		install-shared-lib $install $names $locallibname $flags
	}
}

# If desired, this can be aliased to SharedLib in project.spec
alias Lib ArchiveLib

# Build a dynamically loadable shared object from objects
rule SharedObject {args} {
SharedObject ?--install=<dir> basename sources...

} {
	show-this-rule

	getopt {--install: target args} args

	set srcs [join $args]

	define? CCLD [get-define CC]

	# Must build objects with -fpic, etc.
	ObjectCFlags $srcs [get-define SHOBJ_CFLAGS]

	set localtarget [make-local $target]

	target $localtarget -inputs {*}[Objects $srcs] -depends [get-define PROJDEPS] -msg {note SharedObject $targetname} -do {
		run $CCLD $SHOBJ_LDFLAGS -o $target {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS
	Clean $target
	Phony all $localtarget

	if {[info exists install]} {
		Install --bin $install $target
	}
}

rule Objects {args} {
Objects source...

Create an object file from each source file
Uses $OBJSRULES(.ext) to determine the build rule
Returns a list of objects
Accepts object files (.o) in addition to source files
and simply returns them
} {
	show-this-rule
	set args [join $args]
	set objs {}
	foreach src $args {
		if {[string match <lib>* $src]} {
			lappend objs $src
		} else {
			lappend objs [Object [change-ext .o $src] $src]
		}
	}
	return $objs
}

rule Object {target src} {
Object obj src
} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		if {[info commands ObjectRule$ext] eq ""} {
			dev-error "Don't know how to build Object from $src"
		}
		ObjectRule$ext $obj $src
		Clean $target
	}
	return $obj
}

# Add object-specific CFLAGS
proc ObjectCFlags {srcs args} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

proc CFlags {args} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

proc C++Flags {args} {
	define-append CXX_FLAGS {*}$args
}

proc LinkFlags {args} {
	define-append LD_FLAGS {*}$args
}

proc Linker {linker} {
	define CCLD $linker
}

proc UseLibs {args} {
	# Create/append to PROJLIBS (the link line)
	if {[get-define PROJLIBS] eq ""} {
		define PROJLIBS "-L[publish-path lib]"
	}
	define-append PROJLIBS [prefix -l $args]

	# Now the dependencies
	define-append PROJDEPS [prefix <lib> $args]
}

proc IncludePaths {args} {
	show-this-rule
	foreach dir $args {
		foreach prefix [list [local-dir] [build-dir]] {
			set dir [file-join $prefix $dir]
			if {$dir ni [get-define INCPATHS]} {
				define-append INCPATHS $dir
				CFlags [prefix -I $dir]
				C++Flags [prefix -I $dir]
			}
		}
	}
}

proc load-config-file {filename} {
	# All lines look like one of:
	#CONFIG_BOOL_VALUE=y (or m)
	#CONFIG_STR_VALUE="string value"
	#CONFIG_INT_VALUE=123
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			dputs c "define $name $value"
			define $name $value
		} else {
			user-notice purple "$filename:$n: Warning: Failed to parse $line"
		}
	}
	if {$n == 0} {
		user-notice purple "Warning: $filename contains no configuration"
	}
}

proc Load {args} {
	show-this-rule

	getopt {--nocare --config filename} args

	# XXX: Should we allow loading an out-of-tree file?

	if {[is-target? $filename]} {
		set f [file-build $filename]
		dputs m "Load: $filename is a target => $f"
	} elseif {[file exists $filename]} {
		dputs m "Load: $filename is source"
		set f $filename
		lappend result $f
	} elseif {![is-cleaning?] && !$nocare} {
		build-error [warning-location "Error: Load $filename does not exist and is not a target"]
		tmake-exit 1
	}

	if {[info exists f] && [file exists $f]} {
		if {$config} {
			dputs m "load-config-file $f"
			load-config-file $f
		} else {
			dputs m "source $f"
			source $f
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	lappend ::tmake(projfiles) $filename $nocare
}

proc UseSystemLibs {args} {
	define-append SYSLIBS {*}$args
}

proc PublishIncludes {args} {
	show-this-rule
	getopt {--keepdir args} args
	set args [join $args]

	foreach {dest src} [expand-filespec include $args $keepdir] {
		publish-one-file $dest $src
	}
}

proc setup-test-env {} {
	# Set up LD_LIBRARY_PATH (or equivalent) for tests
	set ldlibpath [get-define LD_LIBRARY_PATH]
	if {$ldlibpath ne ""} {
		set path [getenv $ldlibpath ""]
		# Must use a full path here since tests do chdir
		set addlib [file-join [get-define TOPBUILDDIR] [publish-dir lib]]
		append-with-space path $addlib $::tcl_platform(pathSeparator)
		setenv $ldlibpath $path
	}
}

proc get-test-id {} {
	return test#[incr ::tmakedrb(testid)]
}

# Note that we don't pass SRCDIR explictly to keep the
# 'tmake -n' output clean
proc run-test-command {testcommand} {
	setup-test-env
	setenv SRCDIR [uplevel 1 set SRCDIR]
	setenv TOPBUILDDIR [uplevel 1 set TOPBUILDDIR]
	incr ::tmakedrb(testruncount)
	run $testcommand
	incr ::tmakedrb(testpasscount)
}

# Run an executable test
# The executable must be built in the current dir
#
proc Test {args} {
	show-this-rule

	getopt {--interp: --chdir --quiet --diff: command args} args
	set testid [get-test-id]
	set depends {}
	set localcommand [make-local $command]

	set opts {}
	set deps {}
	set vars {}
	set testcommand {}

	if {$chdir} {
		lappend opts -chdir
	}
	if {!$quiet} {
		lappend opts -msg [list note Test $localcommand]
	}

	# If there is an interpreter, find it
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir -optional 1] dep filename

		# In this case, the command is a script - find it
		lassign [find-project-bin $command -chdir $chdir -optional 0] cmddep scriptpath
		lappend vars testcommand [list $filename $scriptpath {*}$args]

		if {$dep ne ""} {
			lappend deps $dep
		}

	} else {
		# Find the local or published command and add it to the command and deps
		lassign [find-project-bin $command -chdir $chdir -optional 0] dep filename

		lappend vars testcommand [list $filename {*}$args]
		lappend deps $dep
	}

	# set up srcpath to allow the test command/script to find resources
	if {$chdir} {
		# We are in objdir/... and we need to find [local-dir] from src
		lappend vars SRCDIR [file-src-relative [local-dir]]
	} else {
		lappend vars SRCDIR [local-dir]
	}

	target [make-local $testid] -phony -depends $deps -vars {*}$vars {*}$opts -do {
		run-test-command $testcommand
	}
	Phony test [make-local $testid]

	return $testid
}

proc CopyFile {dest source} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg [list note Copy $dest] -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

proc hard-link {args} {
	#show-this-rule

	getopt {--fallback dest source args} args

	# XXX: If the platform doesn't support hard links
	# and --fallback is set, fall back to soft links
	# and then to file copy
	# Want to depend on the existence of the dir, not the time
	target $dest -inputs $source -do {
		file delete $target
		exec ln $inputs $target
	} {*}$args
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# Helper for installing files
proc install-file {target source flags} {
	vputs "Copy $source $target"
	file copy -force $source $target
	if {"bin" in $flags} { chmodx-file $target }
	if {"strip" in $flags} { strip-file [get-define STRIPFLAGS {}] $target }
	if {"striplib" in $flags} { strip-file [get-define STRIPLIBFLAGS {}] $target }
}

proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

proc strip-file {flags target} {
	vputs "Strip $target"
	exec {*}[get-define STRIP true] {*}$flags $target
}

proc InstallFile {dest src {flags {}}} {
	show-this-rule

	#puts "InstallFile $dest $src"

	set destfile [get-define DESTDIR]$dest

	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}
	target $destfile -nocache -inputs $src -vars dest $dest flags $flags -msg {note Install $dest} -do {
		install-file $target $inputs $flags
	}
	target install -depends $destfile

	# This file also needs to be uninstalled
	add-clean uninstall $destfile

	return $destfile
}

proc Install {args} {
	show-this-rule

	getopt {--bin --strip --keepdir destdir args} args
	set args [join $args]
	set flags {}
	if {$bin} {
		lappend flags bin
	}
	if {$strip} {
		lappend flags strip
	}

	set srcs {}
	foreach {dest src} [expand-filespec $destdir $args $keepdir] {
		lappend srcs $src
		InstallFile $dest $src $flags
	}
	return $srcs
}

proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# Helper to clean files (and any empty directories)
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# This creates the clean target of the given type, e.g. clean, distclean
#
proc clean-target {type msg} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" -do {
		clean-files $cleanfiles
	}
}

proc Clean {args} {
	# DistClean also cleans these files
	DistClean {*}$args

	getopt {--src args} args
	set args [join $args]

	if {$src} {
		add-clean [make-local clean] [prefix [local-src-prefix] $args]
	} else {
		add-clean [make-local clean] [make-local {*}$args]
	}
}

proc DistClean {args} {
	getopt {--src args} args
	set args [join $args]

	if {$src} {
		add-clean [make-local distclean] [prefix [local-src-prefix] $args]
	} else {
		add-clean [make-local distclean] [make-local {*}$args]
	}
}

# This adds files to be cleaned for the given type
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	#Depends [make-local $type] -vars cleanfiles [file-build $filelist]
	target-add-var $type cleanfiles [file-build $filelist]
}

# Returns a list of {dependency filename}
#
proc find-project-bin {bin args} {
	set opts [list -chdir 0 -optional 0 {*}$args]

	set localbin [make-local $bin]

	if {[is-target? $localbin]} {
		dputxs m {[find-source-location]: find-project-bin: $localbin is a local target}
		if {$opts(-chdir)} {
			set result [list $localbin ./$bin]
		} else {
			# Note: Use [build-dir] here rather than [file-build] to retain ./
			#       if building in-tree
			set result [list $localbin [build-dir]/$localbin]
		}
	} elseif {[regexp {^<bin>(.*)} $bin -> basename]} {
		dputxs m {[find-source-location]: find-project-bin: $bin is a publish target}
		set publishbin [publish-prefix bin]$basename
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			#puts "localbin=$localbin, file-build-relative $publishbin => [file-build-relative $publishbin]"
			#puts "localbin=$localbin, file-build $publishbin => [file-build $publishbin]"
			set result [list $bin ./$publishbin]
		} else {
			set result [list $bin [file-build $publishbin]]
		}
	} elseif {[file exists $localbin]} {
		dputxs m {[find-source-location]: find-project-bin: $localbin exists as source}
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			set result [list $localbin [file-src-relative $localbin]]
		} else {
			set result [list $localbin $localbin]
		}
	} elseif {$opts(-optional)} {
		dputxs m {[find-source-location]: find-project-bin: $bin is assumed to be external}
		set result [list "" $bin]
	} else {
		# Not found
		dev-error "$bin is neither a local nor a published (<bin>) target"
	}
	dputxs m {[find-source-location]: find-project-bin returning $result}
	return $result
}

proc Generate {args} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: --chdir target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script -chdir $chdir] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	if {$chdir} {
		lappend args -chdir
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $targetname} {*}$args
	Clean $target
}

proc Depends {target args} {
	target [make-local {*}$target] -depends {*}$args
}

proc Phony {target args} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	user-notice purple [warning-location "Warning: LocalMakefile is deprecated and ignored"]
}

proc DefaultTarget {name} {
	show-this-rule
	set ::tmake(defaulttarget) $name
}

# XXX: Only useful for simple cases of building a host executable from C sources
# 
proc HostLibs {args} {
	define-append HOST_SYSLIBS {*}$args
}

proc HostExecutable {target args} {
	set localtarget [make-local $target]

	# Hmmm, EXEEXT may be different on the host
	set localtargetexe $localtarget[get-define HOST_EXEEXT]
	set targetexe $target[get-define HOST_EXEEXT]

	target $localtargetexe -inputs {*}[make-local {*}$args] -msg {note HostExecutable $targetname} -getvars HOST_CFLAGS HOST_SYSLIBS -do {
		run $CC_FOR_BUILD $HOST_CFLAGS -o $target $inputs $HOST_SYSLIBS
	} -dyndep {
		header-scan-regexp-recursive $local "" $CHDRPATTERN
	} {*}[target-alias $target $targetexe]

	PublishBin $target
	Clean $targetexe

	return $localtarget
}

proc add-publish-include {} {
	# Can't use IncludePaths here because we only want build paths
	set dir [publish-dir include]
	set path [publish-path include]
	if {$dir ni [get-define INCPATHS]} {
		define-append INCPATHS $dir
		CFlags [prefix -I $path]
		C++Flags [prefix -I $path]
	}
}

# XXX: Use an official API for this
lappend ::tmake(deferred) {
	add-publish-include
}
# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans

DistClean .makecache

# Invoked manually
Phony clean-orphans -do {
	clean-files [get-orphan-targets] "orphan targets"
	discard-orphan-targets
	if {[file exists .trash]} {
		note Clean .trash
		file delete -force .trash
	}
}

# Automatic invocation, so move files to trash
# (This overrides the built-in version which simply deletes)
# .trash will be deleted on 'make clean-orphans' (and thus clean and distclean)
proc delete-orphan-files {args} {
	file mkdir .trash
	foreach file $args {
		if {[file exists $file]} {
			file rename -force $file .trash/[string map {/ _} $file]
		}
	}
}
