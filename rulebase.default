# vim:set syntax=tcl:
# These are the built-in rules
#
# They can be replaced if necessary

# @synopsis:
#
# rulebase.default is the default tmake rulebase...
#
# The following environment variables are used if set:
#
## CC       - C compiler
## CXX      - C++ compiler
## ...

use getopt glob

proc rulebase-invoke {cmd} {
	switch -exact -- $cmd {
		prolog {
			tailcall rulebase-prolog
		}
		epilog {
			tailcall rulebase-epilog
		}
		init {
			tailcall rulebase-init
		}
		default {
			dputs m "Rulebase does not implement rulebase-invoke $cmd"
		}
	}
}

# ==================================================================
# Default variable settings and rules
# ==================================================================

proc rulebase-init {} {
	# If settings are loaded via Load, these should all be ignored
	# Thus we use define?
	define? CCACHE ""
	define? CC gcc
	define? CXX g++
	define? AR ar
	define? RANLIB ranlib
	define? STRIP strip
	define? STRIPFLAGS ""
	define? STRIPLIBFLAGS ""
	define? ARFLAGS cr
	define? CFLAGS ""
	define? CXXFLAGS ""
	define? LDFLAGS ""
	if {[iswin]} {
		define? EXEEXT .exe
	} else {
		define? EXEEXT ""
	}

	define? SH_CFLAGS ""
	define? SH_LDFLAGS ""
	define? SH_LINKFLAGS ""
	define? SH_SOEXT .so
	define? SHOBJ_CFLAGS ""
	define? SHOBJ_LDFLAGS ""
	define? LD_LIBRARY_PATH ""

	define? CC_FOR_BUILD gcc
	define? HOST_CFLAGS ""
	if {[iswin]} {
		define? HOST_EXEEXT .exe
	} else {
		define? HOST_EXEEXT ""
	}

	define? LEX flex
	define? LFLAGS ""
	define? YACC bison
	define? YFLAGS -y

	define? LOCAL_LIBS ""
	define? DESTDIR ""
	define? OBJCFLAGS ""
	define? INCPATHS ""

	# These are set by the project via CFlags, ObjectCFlags, LinkFlags, etc.
	define C_FLAGS ""
	define CXX_FLAGS ""
	define LD_FLAGS ""

	define PUBLISH publish

	define PROJLIBS ""
	define SYSLIBS ""
	define HOST_SYSLIBS ""
	define PRECOMPILED_HEADER ""

	# Default header pattern for C and C++ dynamic dependencies
	#
	# All globals variables for rulebase.default are kept in the $::tmakedrb array
	set ::tmakedrb {
		testruncount 0
		testpasscount 0
		testid 0
		setuptestenv 0
		objmap {}
		objrules {}
	}
}

# ==================================================================
# Help Overview
# ==================================================================
rule-overview {
This is rulebase.default, the default tmake rulebase. Note the following conventions:

File specifications for Install and Publish rules support the following forms:
  - Regular filenames
  - Renaming rules of the form: target=source
  - Glob patterns (e.g. *.png)

For rules that set variables/flags, those definitions apply to rules later in the file.
For example, when setting C_FLAGS with CFlags, those flags are used by subsequent
Object and Executable rules, but not earlier rules.

Note: Scope can be used to limit the lifetime of definitions.

The following global phony targets are created:

  all:       Builds the 'all' targets from all subdirectories
  test:      Runs the 'test' targets from all subdirectories
  clean:     Runs the 'clean' targets from all subdirectories
  distclean: Runs the 'distclean' targets from all subdirectories
  install:   Runs all install rules
  uninstall: Runs all uninstall rules

  Note that these global targets can be accessed from within a subdirectory
  by using a / prefix. e.g. /all

The following per-directory phony targets are created:
  all:       Builds executables and shared objects in the current directory
             (or libraries if there are no executables or shared objects)
  test:      Runs all tests in the current directory
  clean:     Removes all build products, including Clean targets, in the current directory
  distclean: Runs 'clean', removes DistClean targets in the current directory,
             and cleans all orphan objects
  install:   A convenience alias for /install
  uninstall: A convenience alias for /uninstall

Note that by default, Lib is an alias for ArchiveLib. This can be changed with:
  alias Lib SharedLib
}

# ==================================================================
# BUILT-IN Object Rules
# ==================================================================

define CHDRPATTERN {^[\t ]*#[\t ]*include[\t ]*[<\"]([^\">]*)[\">]}

proc is-duplicate-obj-rule {obj src vars} {
	global tmakedrb

	# Build the info for the rule
	set info [list $src]
	foreach var $vars {
		lappend info $var [get-define $var]
	}

	if {[dict exists $tmakedrb objrules $obj]} {
		# Is it identical?
		dputs t "Ignoring identical duplicate object rule for $obj at [find-source-location]"

		set oldinfo [dict get $tmakedrb objrules $obj]
		if {$oldinfo ne $info} {
			build-error [warning-location "Error: Duplicate Object rule for $obj with different settings"]
		}
		return 1
	}

	dict set tmakedrb objrules $obj $info
	return 0
}

# @ObjectRule.<ext> object source
#
# Rule for creating 'object' from source file 'source' with the
# extentions 'ext'.
#
# The appropriate ObjectRule.<ext> is invoked from Object
# (and hence Objects, Executable and Lib) based on the extension.

rule ObjectRule.c {obj src} {
ObjectRule.c object source

Generates an object file from a C source file

Imported variables: CC, C_FLAGS (from CFlags, ObjectCFlags), INCPATHS (from IncludePaths)
Used variables: CFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	if {![is-duplicate-obj-rule $obj $src {CC C_FLAGS INCPATHS}]} {
		# Capture the current value of CC, C_FLAGS and INCPATHS
		target $obj -inputs $src -msg {note Cc $targetname} -getvars CC C_FLAGS INCPATHS -do {
			run $CCACHE $CC $C_FLAGS $CFLAGS -c $inputs -o $target
		} -dyndep {
			header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
		} -depends [get-define PRECOMPILED_HEADER]
	}
	return $obj
}

rule ObjectRule.cpp {obj src} {
ObjectRule.cpp object source

Generates an object file from a C++ source file

Imported variables: CXX, CXX_FLAGS (from C++Flags), INCPATHS (from IncludePaths)
Used variables: CXXFLAGS, CCACHE, CHDRPATTERN (for dynamic dependency generation)
} {
	if {![is-duplicate-obj-rule $obj $src {CXX CXX_FLAGS INCPATHS}]} {
		# Capture the current value of CXX, CXX_FLAGS and INCPATHS
		target $obj -inputs $src -msg {note C++ $targetname} -getvars CXX CXX_FLAGS INCPATHS -do {
			run $CCACHE $CXX $CXX_FLAGS $CXXFLAGS -c $inputs -o $target
		} -dyndep {
			header-scan-regexp-recursive $INCPATHS "" $CHDRPATTERN
		} -depends [get-define PRECOMPILED_HEADER]
	}
	return $obj
}

rule ObjectRule.l {obj src} {
ObjectRule.l object source

Generates an object file from a lexer source file
} {
	set base [file rootname $src]
	set targets [list $base.lex.c $base.lex.h]

	# Build the output files with lex/flex
	target $targets -inputs $src -msg {note Lex $targetname} -getvars LEX LFLAGS -do {
		run $LEX $LFLAGS --outfile=[lindex $target 0] --header-file=[lindex $target 1] $inputs
	}
	Clean $targets

	# And create the object through Object
	Object $base.lex.o $base.lex.c
}

rule ObjectRule.y {obj src} {
ObjectRule.y object source

Generates an object file from a yacc source file
} {
	set base [file rootname $src]
	set targets [list $base.tab.c $base.tab.h]

	# Build the output files with yacc/bison
	target $targets -inputs $src -msg {note Yacc $targetname} -getvars YACC YFLAGS -do {
		run $YACC $YFLAGS --output=[lindex $target 0] --defines=[lindex $target 1] $inputs
	}
	Clean $targets

	# And create the object through Object
	Object $base.tab.o $base.tab.c
}

# ==================================================================
# PROLOG/EPILOG HOOKS
# ==================================================================
proc rulebase-prolog {} {
	global tmakedrb

	show-this-rule [local-dir]

	# Local phony targets build from the current directory down
	if {[local-prefix] ne ""} {
		set parentprefix [make-prefix [file dirname [local-dir]]]
		foreach t {all clean distclean test} {
			set localtarget [make-local $t]
			target $localtarget -phony
			target $parentprefix$t -phony -depends $localtarget
		}
		Phony install install
		Phony uninstall uninstall
		clean-target [make-local clean] Clean
		clean-target [make-local distclean] DistClean
	}

	# Capture these variables
	foreach i {INCPATHS C_FLAGS CXX_FLAGS} {
		dict set tmakedrb $i [get-define $i]
	}

	# This can be removed with IncludePaths --reset
	IncludePaths .
}

proc rulebase-epilog {} {
	show-this-rule [local-dir]
	global tmake

	# Does subdir/all have any dependencies? If not, make it depend on subdir/libs (if that rule exists)
	set t [get-target-rule [make-local all]]
	if {[llength $t(depends)] == 0} {
		if {[is-rule? [make-local libs]]} {
			Depends all [make-local libs]
		}
	}

	# Ensure that even directories with no targets are removed
	Clean __dummy__
}

# ==================================================================
# UTILTY PROCS
# ==================================================================

# @target-alias target targetexe
#
# On some systems, executables are identified with an extension (e.g. .exe)
# For cross-platform compatibility, rules omit this extension and an alias is used
# to link to the actual filename.
#
# This command checks the rule name (e.g. abc) and the executable name (e.g. abc.exe)
# and if they are different, returns an appropriate target alias for the executable
# (e.g. -alias abc). Otherwise an empty list is returned.
#
proc target-alias {target targetexe} {
	if {$target ne $targetexe} {
		return [list -alias [make-local $target]]
	}
	return ""
}

# @publish-path dir
#
# Returns the path to the given 'publish' subdirectory,
# e.g. [publish-path include] returns something like objdir/.publish/include
#
proc publish-path {dir} {
	file-build [file-join [get-define PUBLISH] $dir]
}

# @publish-dir dir
#
# Returns the path to the given 'publish' subdirectory relative to the build directory
# e.g. [publish-dir include] returns something like .publish/include
#
proc publish-dir {dir} {
	file-join [get-define PUBLISH] $dir
}

# @publish-prefix dir
#
# Like publish-dir, but returns the value suitable to be used as a prefix
#
proc publish-prefix {dir} {
	make-prefix [publish-dir $dir]
}

# @publish-one-file dest src
#
# Creates a rule to publish $src as $dest (build relative name) by creating a hard link.
# e.g. publish-one-file include/header.h header.h
#
proc publish-one-file {dest src} {
	#dputs m "publish-one-file dest=$dest, src=$src, realdest=[publish-dir $dest]"
	hard-link [publish-dir $dest] $src -msg {note Publish $targetname}
}

# @publish-lib libname alias
#
# Creates a rule to publish an archive library, $libname, to the $PUBLISH/lib directory.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-lib {libname alias} {
	hard-link [publish-prefix lib]$libname [make-local $libname] -msg {note Publish $targetname} -alias $alias
}

# @make-shlib-symlinks first alias...
#
# Create symlinks such that each of the given aliase is a symlink to $first.
# All paths/names should be in the same directory
# The alias targets must not exist.
#
proc make-shlib-symlinks {first args} {
	foreach alias $args {
		file-link -sym $alias [file tail $first]
	}
}

# @publish-shared-lib names source alias
#
# Creates a rule to publish a shared library, $source, with the given names to the
# $PUBLISH/lib directory.
# This includes creating appropriate symlinks.
# $alias is the alias name of the library, e.g. <lib>blah
#
proc publish-shared-lib {names source alias} {
	set published [prefix [publish-prefix lib] {*}$names]

	target $published -inputs $source -msg {note Publish [lindex $targetname 0]} -do {
		file delete {*}$target
		file-link [lindex $target 0] $inputs
		make-shlib-symlinks {*}$target
	} -vars libname [lindex $names 0] -alias $alias
	add-clean [make-local clean] $published
	add-clean [make-local distclean] $published
}

# @install-shared-lib ?--striplib? dest names source flags
#
# Creates a rule to install a shared library, $source, to install directory $dest
# This includes creating appropriate symlinks.
# $flags are passed to install-file and should either be empty, or "striplib".
proc install-shared-lib {args} {
	getopt {--striplib dest names source} args

	set installed [prefix [make-prefix [get-define DESTDIR]$dest] $names]

	set installopts {}
	lappend installopts --bin
	if {$striplib} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPLIBFLAGS]"
	}
	target $installed -nocache -inputs $source -msg {note Install $libname} -do {
		file delete {*}$target
		install-file {*}$installopts [lindex $target 0] $inputs
		make-shlib-symlinks {*}$target
	} -vars installopts $installopts libname [file-join $dest [lindex $names 0]]

	target install -depends {*}$installed
	add-clean uninstall $installed
}

# @expand-filespec dir filelist keepdir
#
# Implements target renaming/globbing for Publish and Install
#
# $dir is the target directory
# $filelist is the file specification
# $keepdir is a boolean which indicates whether to keep the source dir in the target name
#
# The file specification may include:
# - Regular filenames
# - Renaming rules of the form: target=src
# - Glob patterns
#
# Returns a list of the form: target1 source1 target2 source2 ...
proc expand-filespec {dir filelist keepdir} {
	set result {}

	foreach spec $filelist {
		if {$spec eq ""} {
			continue
		}
		if {[string match *=* $spec]} {
			lassign [split $spec =] target src
			#dputs m "file renaming: dir=$dir, target=$target, src=$src => target=[file-join $dir $target] src=[make-local $src]"
			lappend result [file-join $dir $target] [make-local $src]
			continue
		}
		if {[string match {*[{}*?]*} $spec]} {
			set srcs [Glob --all $spec]
		} else {
			set srcs $spec
		}
		foreach src $srcs {
			if {$keepdir} {
				#dputs m "keepdir: dir=$dir, src=$src => target=[file-join $dir $src] src=[make-local $src]"
				lappend result [file-join $dir $src] [make-local $src]
			} else {
				#dputs m "no keepdir: dir=$dir, src=$src => target=[file-join $dir [file tail $src]] src=[make-local $src]"
				lappend result [file-join $dir [file tail $src]] [make-local $src]
			}
		}
	}
	#puts "expand-filespec: $filelist => $result"
	return $result
}

# @expand-objects objs
#
# Expands a list of objects which may contain library aliases of the form <lib>$basename
# Each library alias is expanded into the list of objects for that library.
# (Note that SharedLib and ArchiveLib create an object list when creating libraries)
# Any non-aliases are left unchanged.
#
# Returns the expanded object list.
proc expand-objects {objs} {
	set result {}
	foreach obj $objs {
		if {[string match <lib>* $obj]} {
			if {![dict exists $::tmakedrb(objmap) $obj]} {
				build-error [warning-location "Error: Unable to find objects for unknown lib $obj"]
				return -code break
			}
			# XXX: How to guarantee that $SH_CFLAGS are set on these objects?
			# (Either directly via ObjectCFlags or with a top-level CFlags)
			#
			lappend result {*}[file-build [dict get $::tmakedrb(objmap) $obj]]
		} else {
			lappend result $obj
		}
	}
	#puts "expand-objects $objs =>\n$result"
	return $result
}

# @load-config-file filename
#
# Reads a configuration file of the form:
#
## CONFIG_BOOL_VALUE=y (or m)
## CONFIG_STR_VALUE="string value"
## CONFIG_INT_VALUE=123
#
# Each matching value is loaded as a corresponding variable definition
# where if the value is "y", it is changed to "1", and if the value
# is a quoted string, the quotes are removed.
proc load-config-file {filename} {
	set n 0
	foreach line [split [readfile $filename] \n] {
		incr n
		set line [string trim $line]
		if {$line eq "" || [string match "#*" $line]} {
			continue
		}
		if {[regexp {^([^=:]*):?=(.*)} $line -> name value]} {
			set value [string trim $value]
			if {$value eq "y"} {
				set value 1
			} elseif {[string match {"*"} $value]} {
				set value [lindex $value 0]
			}
			dputs c "define $name $value"
			define $name $value
		} else {
			user-notice purple "$filename:$n: Warning: Failed to parse $line"
		}
	}
	if {$n == 0} {
		user-notice purple "Warning: $filename contains no configuration"
	}
}

# @setup-test-env
#
# Prepares the environment for running tests.
# Given the (absolute path of) $PUBLISH/lib and the name of the LD_LIBRARY_PATH variable,
# appends the publish lib $LD_LIBRARY_PATH in the environment to allow published shared libraries to be loaded
# Also sets TMAKE_LIBPATH to the same value for script helpers on Mac OS X
# since DYLD_LIBRARY_PATH can't be passed to scripts
# (See https://forums.developer.apple.com/message/31148)
proc setup-test-env {publishlib ldlibpath} {
	setenv TMAKE_LIBPATH $publishlib
	if {$ldlibpath ne ""} {
		set path [getenv $ldlibpath ""]
		append-with-space path $publishlib $::tcl_platform(pathSeparator)
		setenv $ldlibpath $path
	}


}

# @get-test-id
#
# Returns a unique test id of the form 'test#nnn'
# Used to help identify Test targets since they don't have
# a natural target name.
proc get-test-id {} {
	return test#[incr ::tmakedrb(testid)]
}

# @run-test-command testcommand
#
# This is a helper for running test commands.
# The environment is set up with setup-test-env
# Then SRCDIR is exported to the environment
# stdout, stderr and errok are checked from the caller to determine
# how output/errors are handled/checked
proc run-test-command {testcommand} {
	upvar stdout stdout
	upvar stderr stderr
	upvar errok errok
	upvar SRCDIR SRCDIR

	set cmdline $testcommand

	set outfile {}

	foreach i {stdout stderr} redir {> 2>} {
		if {[exists $i]} {
			set outfile($i) [file tempfile]
			lappend testcommand ${redir}$outfile($i)
		}
	}

	if {![exists stdout]} {
		lappend testcommand >@stdout
	}

	# Get this value from the calling scope and set in the environment
	setenv SRCDIR $SRCDIR
	incr ::tmakedrb(testruncount)
	set rc [catch {
		vputs [string trim $testcommand]
		exec {*}$testcommand
	} msg opts]
	if {[exists errok]} {
		set rc 0
	}
	if {$rc == 0} {
		# Succeeded. Does the output match?
		foreach {i gotfile} $outfile {
			set expfile [set $i]
			set got [readfile $gotfile]
			set exp [readfile $expfile]
			if {$got ne $exp} {
				if {$rc == 0} {
					set rc 1
					pputs \n\t$cmdline\n
					set msg "\nError: Output does not match"
				}
				vputs "diff -u $expfile $gotfile"
				catch {
					exec diff -u $expfile $gotfile >@stdout
				}
			}
		}
	}

	# Delete output
	foreach file [dict values $outfile] {
		file delete -force $file
	}

	if {$rc == 0} {
		incr ::tmakedrb(testpasscount)
		return 0
	}
	build-error $msg
	return -code break
}

# @hard-link dest source ?target-args...?
#
# Creates a rule to link $dest to $source
# Additional arguments may be passed and are added to the target rule.
#
proc hard-link {args} {
	#show-this-rule

	getopt {dest source args} args

	# XXX: If the platform doesn't support hard links,
	# consider falling back to soft links and then to file copy
	target $dest -inputs $source -do {
		file delete $target
		file-link $target $inputs
	} {*}$args

	# Note that we can't use Clean here because $dest is already
	# a local name
	add-clean [make-local clean] $dest
	add-clean [make-local distclean] $dest
}

# @install-file ?--strip=$STRIPCMD? ?--bin? target source
#
# Helper for installing files
# Copies the file from $source to $target, then performs zero or more actions
# depending upon the flags (which is a list)
#
# --bin                 - make the target executable with chmodx-file
# --strip=$STRIPCMD     - If specified, strips the target with the given strip command
#
proc install-file {args} {
	getopt {--strip: --bin target source} args

	vputs "Copy $source $target"
	file copy -force $source $target
	if {$bin} {
		chmodx-file $target
	}
	if {[exists strip]} {
		vputs "Strip $target"
		exec {*}$strip $target
	}
}

# @chmodx-file target
#
# Makes the given file executable with chmod +x
proc chmodx-file {target} {
	vputs "Chmod $target"
	exec chmod +x $target
}

# @strip-file flags target
#
# Invokes '$STRIP $flags $target' to strip the given executable
#
# If $STRIP is not set, does nothing
proc strip-file {flags target} {
}

# @remove-empty-directories filename-list
#
# Considers the set of directories containing each filename in the list.
# Removes any of those directories that are empty.
proc remove-empty-directories {files} {
	set dirs {}
	foreach file $files {
		while {1} {
			set dirname [file dirname $file]
			if {$dirname eq $file || $dirname eq "."} {
				break
			}
			dict set dirs [file dirname $file] 1
			set file $dirname
		}
	}
	if {[dict size $dirs]} {
		# Sort in reverse order so that abc/def/ghi is removed before abc/def
		#dputs m "file delete {*}[lsort -decreasing [dict keys $dirs]]"
		foreach dir [lsort -decreasing [dict keys $dirs]] {
			catch { file delete $dir }
		}
	}
}

# @clean-files filename-list ?msg?
#
# Helper to clean files (and any empty directories)
#
# Removes the list of files, and then any directories that contain those
# files which have become empty.
#
# If $msg is provided, it is printed via 'note', otherwise a default
# message is printed.
proc clean-files {files {msg {}}} {
	if {[llength $files]} {
		vputs "rm $files"
		if {$msg ne ""} {
			note "Clean [llength $files] $msg"
		}
		file delete {*}$files
		# Also need to remove any empty directories
		remove-empty-directories $files
	}
}

# @clean-target type msg
#
# Create the phony clean target of the given type and message.
# The created target invokes clean-files
#
# Additional files can be added to the target with 'add-clean'
#
proc clean-target {type msg} {
	target $type -phony -nofail -vars cleanfiles {} -msg "note $msg [local-dir]" -do {
		clean-files $cleanfiles
	}
}

# @add-clean type filename-list
#
# Adds the given files to the list to be removed for the given type (target)
#
proc add-clean {type filelist} {
	# This could be done with Depends or target, but it is much
	# faster to simply append to the rule variable directly
	target-add-var $type cleanfiles [file-build $filelist]
}

# @add-src-clean type filename-list
#
# Like add-clean, except $filelist are in the source directory rather than the build directory
#
proc add-src-clean {type filelist} {
	target-add-var $type cleanfiles $filelist
}

# @find-project-bin binfile ?-chdir 0|1? ?-optional 0|1?
#
# Searches for the given binary file as follows:
# 1. If $binfile is a known target, the result is the target
# 2. If $binfile is of the form <bin>name, the result is the published binary
# 3. If the file exists in the local directory, the result is the file
# 4. Otherwise, if optional=1, the file is assumed to be an external binary
# 5. Otherwise an error is raised.
#
# The result is a list of two values: {dependency filename}
#
# The first value is a build dependency for the file. (Empty for an external binary)
# The second value is the path to the file suitable for executing it, taking
# into account the setting of 'chdir'.
proc find-project-bin {bin args} {
	set opts [list -chdir 0 -optional 0 {*}$args]

	set localbin [make-local $bin]

	if {[is-target? $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin is a local target}
		if {$opts(-chdir)} {
			set result [list $localbin ./$bin]
		} else {
			# Note: Use [build-dir] here rather than [file-build] to retain ./
			#       if building in-tree
			set result [list $localbin [build-dir]/$localbin]
		}
	} elseif {[regexp {^<bin>(.*)} $bin -> basename]} {
		dputxs l {[find-source-location]: find-project-bin: $bin is a publish target}
		set publishbin [publish-prefix bin]$basename
		if {$opts(-chdir)} {
			# We will be running in [file-build [local-dir]],
			# while the executable to run is in [file-build $PUBLISH/bin]
			# So calculate a relative path
			set curdir [file-build [local-dir]]
			set builddir [publish-path bin]
			# It can't hurt to create the $PUBLISH/bin here and it makes relative-path always work
			file mkdir $builddir
			set reldir [relative-path $builddir $curdir]

			set result [list $bin $reldir/$basename]
		} else {
			set result [list $bin [file-build $publishbin]]
		}
	} elseif {[file exists $localbin]} {
		dputxs l {[find-source-location]: find-project-bin: $localbin exists as source}
		if {$opts(-chdir)} {
			# Need to adjust the interp to account for chdir
			set result [list $localbin [file-src-relative $localbin]]
		} else {
			set result [list $localbin $localbin]
		}
	} elseif {$opts(-optional)} {
		dputxs l {[find-source-location]: find-project-bin: $bin is assumed to be external}
		set result [list "" $bin]
	} else {
		# Not found
		build-error [warning-location "$bin is neither a local nor a published (<bin>) target"]
		set result [list "" ""]
	}
	dputxs l {[find-source-location]: find-project-bin returning $result}
	return $result
}

add-deferred-action {
	# Need to add $PUBLISH/include to the include paths
	IncludePaths --build [publish-dir include]
}

# ==================================================================
# HIGH LEVEL RULES
# ==================================================================

rule Executable {args} {
Executable --test --chdir --nobuild --publish --no|strip --install=<dir> target sources...

Builds an executable from one or more source files. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the executable.

Imported variables: CCLD (from Linker), LD_FLAGS (from LinkFlags), PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS

The following options are supported:
  --test              Marks the executable as a test (see Test)
  --chdir             This options is passed to Test if --test is also specified.
  --nobuild           Don't make this executable dependent on phony 'all', which is otherwise the default
  --publish           Publishes the executable (see PublishBin)
  --install=<dir>     Install the executable to the given directory (see InstallFile)
  --strip[=full|dynamic|none]  Sets the strip type on installation. --strip means full. omitted means none. (see InstallFile)
} {
	add-default-opts args
	show-this-rule
	set strip none
	getopt {--test --chdir --nobuild --publish --strip:full --install: target args} args

	set localtarget [make-local $target]
	set targetexe $target[get-define EXEEXT]
	set localtargetexe $localtarget[get-define EXEEXT]

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	define? CCLD [get-define CC]

	# Capture the current value of CCLD, LD_FLAGS and SYSLIBS
	target $localtargetexe -inputs {*}$objects [get-define LOCAL_LIBS] -depends [get-define PROJDEPS] -msg {note Link $targetname} -do {
		run $CCLD $LD_FLAGS $LDFLAGS -o $target $inputs $PROJLIBS $SYSLIBS
	} -getvars CCLD LD_FLAGS PROJLIBS SYSLIBS {*}[target-alias $target $targetexe]
	Clean $targetexe

	if {$publish} {
		PublishBin $target
	}

	if {[info exists install]} {
		set opts --bin
		if {$strip ni {none full dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		if {$strip eq "full"} {
			lappend opts --strip
		} elseif {$strip eq "dynamic"} {
			lappend opts --striplib
		}
		InstallFile {*}$opts [file-join $install $targetexe] $localtargetexe
	}
	if {$test} {
		if {$chdir} {
			Test --chdir $target
		} else {
			Test $target
		}
	}
	if {!$nobuild} {
		Phony all $localtargetexe
	}
}

rule PublishBin {args} {
PublishBin ?--script? name ...

Publishes one or more executables (either binaries or scripts)
Unless --script is specified, the executable extension (e.g. .exe) is used.

Note that 'name' can be 'target=src' to rename a file when published.
} {
	show-this-rule

	getopt {--script args} args

	set destdir [publish-dir bin]

	if {$script} {
		set exe ""
	} else {
		set exe [get-define EXEEXT]
	}


	foreach {dest src} [expand-filespec $destdir $args 0] {
		hard-link $dest$exe $src$exe -vars dest bin/$dest -msg {note Publish $targetname} -alias <bin>[file tail $dest]
		target $dest$exe -add -do {
			chmodx-file $target
		}
	}
}

rule Publish {args} {
Publish ?--keepdir? dir name...

Publishes one or more files to directory $PUBLISH/$dir

Accepts the following file names:
  - Regular filenames
  - Renaming rules of the form: target=src
  - Glob patterns (.e.g *.img)

Normally files are publish directly into $PUBLISH/$dir, but if --keepdir is
specified, the relative source directory is kept and replicated under $PUBLISH/$dir

Note: Libraries and Binaries should not be published with this rule.
Rather Publishlib and PublishBin should be used.
} {
	show-this-rule
	getopt {--keepdir dir args} args

	if {$dir eq "bin"} {
		user-notice purple [warning-location "Warning: Use PublishBin to publish binaries"]
	}
	if {$dir eq "lib" && [string match lib* $args]} {
		user-notice purple [warning-location "Warning: Use Lib --publish to publish libraries"]
	}

	foreach {dest src} [expand-filespec $dir $args $keepdir] {
		publish-one-file $dest $src
	}
}

rule ArchiveLib {args} {
ArchiveLib ?--publish? ?--install=<dir>? basename sources...

Creates an archive library from the given sources. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are combined with $AR and $RANLIB to create the archive library.

		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target

Used variables: AR, ARFLAGS, RANLIB

The following options are supported:
  --publish           Publishes the library (see PublishLib)
  --install=<dir>     Install the library to the given directory (see InstallFile)
} {
	show-this-rule
	getopt {--publish --install: basename args} args

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set libname lib$basename.a
	set libalias <lib>$basename

	set locallibname [make-local $libname]
	target $locallibname -inputs {*}$objects -msg {note Ar $targetname} -do {
		file delete $target
		run $AR $ARFLAGS $target {*}[expand-objects $inputs]
		run $RANLIB $target
	}

	# Note: Libraries are not built by default, but are added to a local 'libs' rule
	Phony libs $locallibname
	Clean $libname
	define-append LOCAL_LIBS $locallibname

	if {[info exists install]} {
		InstallFile [file-join $install $libname] $locallibname
	}
	if {$publish} {
		publish-lib $libname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects
	}
}

rule SharedLib {args} {
SharedLib ?--publish? ?--strip=<type>? ?--version=<ver>? ?--soversion=<ver>? ?--install=<dir> basename source...

Creates a shared library from the given sources. For each source, the appropriate ObjectRule is used
to generate the object file, and these files are linked (along with any libraries) to create the shared library.

Imported variables: CCLD (from Linker), PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: SH_LDFLAGS, LDFLAGS, SH_SOEXT, SH_SOEXTVER, SH_SOPREFIX

The following options are supported:
  --publish           For compatibility. Note that shared libraries are always published. (see PublishLib)
  --install=<dir>     Install the shared library to the given directory (see InstallFile)
  --version=<ver>     A version for the shared library of the form n.n.n (1-3 parts)
  --soversion=<ver>   Override the soname version. Otherwise the first part of the version is used.
  --strip[=dynamic|none]   Sets the strip type on installation. --strip means dynamic. omitted means none. (see InstallFile)
} {
	show-this-rule
	add-default-opts args
	set strip none
	getopt {--publish --strip:dynamic --version: --soversion: --install: basename args} args

	if {![info exists version]} {
		set version 0
	}
	set n 0
	foreach part [split $version .] {
		if {![string is integer -strict $part]} {
			set n -1
			break
		}
		incr n
	}
	if {$n < 0 || $n > 3} {
		build-error [warning-location "Not a valid shared library version number: $version"]
		return
	}

	# What names may our shared lib have?
	set nameinfo [list [get-define SH_SOEXTVER] $version %s [get-define SH_SOEXT]]
	set default_soversion $version
	if {$n > 1} {
		# If more that one part is given, the first one is the defaul soversion
		lassign [split $version .] default_soversion
		lappend nameinfo [get-define SH_SOEXTVER] $version
		lappend nameinfo [get-define SH_SOEXTVER] $default_soversion
	}

	set names {}
	set libname {}

	foreach {fmt version} $nameinfo {
		if {$fmt eq ""} {
			continue
		}
		set name lib$basename[format $fmt $version]
		if {$libname eq {}} {
			set libname $name
		}
		if {$name ni $names} {
			lappend names $name
		}
	}

	# Flatten and glob inputs
	set objects [Objects [Glob --all [join $args]]]

	set locallibname [make-local $libname]
	set srcs [join $args]
	set libalias <lib>$basename
	ObjectCFlags $srcs [get-define SH_CFLAGS]

	set setsoname {}
	if {[get-define SH_SOPREFIX ""] ne ""} {
		if {![info exists soversion]} {
			set soversion $default_soversion
		}
		set soname lib$basename[format [get-define SH_SOEXTVER] $soversion]
		set setsoname [get-define SH_SOPREFIX]$soname
	}

	define? CCLD [get-define CC]

	# Note: Do not link against local archive libs (LOCAL_LIBS)
	# XXX: Here we use $LDFLAGS to capture any user-specified link flags (.e.g. -mbig-endian).
	#      Assume that these are required both for shared libs and for executables.
	#      Any shared-library-only flags are in $SH_LDFLAGS.
	#      Is LinkFlags/LD_FLAGS also required?

	target $locallibname -inputs {*}$objects -depends [get-define PROJDEPS] -msg {note SharedLib $targetname} -do {
		run $CCLD $SH_LDFLAGS $LDFLAGS -o $target $setsoname {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS -vars setsoname $setsoname
	Clean $locallibname

	# Only the fully versioned name is built in the local dir
	Phony libs $locallibname
	Clean $libname

	# Note: --publish is dummy. Shared libs always need to be published to be used
	# The reason is that it gets difficult to manage LD_LIBRARY_PATH or equalivalent.
	# If shared libraries are always published, a single definition of LD_LIBRARY_PATH=$PUBLISH/lib
	# will work for all shared libs
	incr publish

	if {$publish} {
		# Publish along with the various symlinks and create an alias
		publish-shared-lib $names $locallibname $libalias

		# Used to make expand-objects work
		dict set ::tmakedrb(objmap) $libalias $objects

		# Local executables link against this library
		UseLibs $basename
	}
	if {[info exists install]} {
		if {$strip ni {none dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		set opts {}
		if {$strip eq "dynamic"} {
			lappend opts --striplib
		}

		install-shared-lib {*}$opts $install $names $locallibname
	}
}

# If desired, this can be aliased to SharedLib in project.spec
alias Lib ArchiveLib

rule SharedObject {args} {
SharedObject ?--install=<dir>? ?--no|strip? target sources...

Builds a dynamically loadable shared object from the given sources.
For each source, the appropriate ObjectRule is used to generate the object file,
and these files are linked (along with any libraries) to create the loadable object.

Imported variables: CCLD (from Linker), SHOBJ_LDFLAGS (must be set appropriately),
                    PROJLIBS and PROJDEPS (from UseLibs), SYSLIBS (from UseSystemLibs)
Used variables: LDFLAGS, SHOBJ_CFLAGS (must be set appropriately)

Note that sources are marked to be built with SHOBJ_CFLAGS via ObjectCFlags.

The following options are supported:
  --install=<dir>              Install the shared object to the given directory (see InstallFile)
  --strip[=dynamic|none]       Sets the strip type on installation. --strip means dynamic. omitted means none. (see InstallFile)
} {
	show-this-rule
	add-default-opts args

	set strip none
	getopt {--install: --strip:dynamic target args} args

	set srcs [join $args]

	define? CCLD [get-define CC]

	# Must build objects with -fpic, etc.
	ObjectCFlags $srcs [get-define SHOBJ_CFLAGS]

	set localtarget [make-local $target]

	target $localtarget -inputs {*}[Objects $srcs] -depends [get-define PROJDEPS] -msg {note SharedObject $targetname} -do {
		run $CCLD $SHOBJ_LDFLAGS -o $target {*}[expand-objects $inputs] $PROJLIBS $SYSLIBS
	} -getvars CCLD PROJLIBS SYSLIBS
	Clean $target
	Phony all $localtarget

	if {[info exists install]} {
		set opts --bin
		if {$strip ni {none dynamic}} {
			build-error [warning-location "Unknown --strip option $strip"]
		}
		if {$strip eq "dynamic"} {
			lappend opts --striplib
		}
		InstallFile {*}$opts [file-join $install $target] $localtarget
	}
}

rule Objects {args} {
Objects source...

Create an object file from each source file
Uses the appropriate ObjectRule for each source.
Returns a list of objects
Accepts object files (.o) in addition to source files
and simply returns them
} {
	show-this-rule
	set args [join $args]
	set objs {}
	foreach src $args {
		if {[string match <lib>* $src]} {
			lappend objs $src
		} else {
			lappend objs [Object [change-ext .o $src] $src]
		}
	}
	return $objs
}

rule Object {target src} {
Object obj src

Creates object $target from source $src by using the appropriate ObjectRule, e.g. ObjectRule.c
for .c sources.
} {
	show-this-rule
	set ext [file ext $src]
	set obj [make-local $target]
	set src [make-local $src]
	if {$ext ne ".o"} {
		if {[info commands ObjectRule$ext] eq ""} {
			build-error [warning-location "Don't know how to build Object from $src"]
			return $obj
		} else {
			set obj [ObjectRule$ext $obj $src]
			Clean $target
		}
	}
	return $obj
}

rule ObjectCFlags {srcs args} {
ObjectCFlags source ...

Like CFlags, but instead of adding C_FLAGS for all subsequent rules, adds
C_FLAGS only to the objects created from the given list of source files
} {
	show-this-rule
	foreach src $srcs {
		set obj [change-ext .o $src]
		target [make-local $obj] -vars C_FLAGS [join $args]
	}
}

rule CFlags {args} {
CFlags ...

Add the given flags to C_FLAGS (used in ObjectRule.c)
e.g.  CFlags -DABC=7

Note that to pass a string value, it generally sufficient to quote it normally:

  CFlags -DVERSION="v1.0"

However if the value contains spaces, quote with a double backslash:

  CFlags -DVERSION="prog\\ v1.0"
} {
	show-this-rule
	define-append C_FLAGS {*}$args
}

rule C++Flags {args} {
C++Flags ...

Add the given flags to CXX_FLAGS (used in ObjectRule.cpp)

See CFlags
} {
	define-append CXX_FLAGS {*}$args
}

rule LinkFlags {args} {
LinkFlags ...

Add the given flags to LD_FLAGS (used in Executable and SharedLib)
} {
	define-append LD_FLAGS {*}$args
}

rule Linker {linker} {
Linker prog

Defines the linker to use for subsequent Executable and SharedLib ($CCLD).
By default $CC is used. For C++ applications, it is typical to set:

  Linker $CXX
} {
	define CCLD $linker
}

rule UseLibs {args} {
UseLibs projlib ...

Identifies published project libraries from other directories that are required for
linking subsequent Executables, Shared Libraries and Shared Objects.

The libraries are both added as dependencies (via $PROJDEPS) and added to the link line
(via $PROJLIBS)

For non-project libraries (such as system libraries), see UseSystemLibs and LinkFlags
} {
	# Create/append to PROJLIBS (the link line)
	if {[get-define PROJLIBS] eq ""} {
		define PROJLIBS "-L[publish-path lib]"
	}
	define-append PROJLIBS [prefix -l $args]

	# Now the dependencies
	define-append PROJDEPS [prefix <lib> $args]
}

rule IncludePaths {args} {
IncludePaths ?--reset? ?--build? ?--source? paths...

Arranges to search the given paths for header files. By default, the paths (relative)
to the current local directory, are searched in both the source tree and the build tree,
however specifying only one of --build and --source restricts to search to just that tree.

The paths are added:
- to $INCPATHS for use by dynamic header dependency searching
- to CFlags ($C_FLAGS) as -I <path>
- to C++Flags ($CXX_FLAGS) as -I <path>

If --reset is specified, INCPATHS, C_FLAGS, and CXX_FLAGS are reset to their default values,
before any IncludePaths invocations. This can be useful to remove the implicit 'IncludePaths .'
} {
	show-this-rule

	getopt {--reset --build --source args} args

	if {$reset} {
		global tmakedrb
		# Reset INCPATHS, C_FLAGS and CXX_FLAGS to their defaults
		foreach i {INCPATHS C_FLAGS CXX_FLAGS} {
			define $i [dict get $tmakedrb $i]
		}
	}

	if {!$build && !$source} {
		# No options means both
		incr build
		incr source
	}

	set srcdir [local-dir]
	set builddir [file-build [local-dir]]

	foreach dir $args {
		set srcpath [file-join $srcdir $dir]
		set buildpath [file-join $builddir $dir]

		if {$srcpath in [get-define INCPATHS]} {
			dputs m "IncludePaths: Ignoring duplicate $srcpath"
			# Already have this one added, so ignore it
			continue
		}
		define-append INCPATHS $srcpath
		if {$source} {
			CFlags [prefix -I $srcpath]
			C++Flags [prefix -I $srcpath]
		}
		if {$build} {
			CFlags [prefix -I $buildpath]
			C++Flags [prefix -I $buildpath]
		}
	}
}

rule Load {args} {
Load ?--nocare? ?--config? filename

Reads a configuration file in one of two forms.
If --config is specified, the following form is expected:

  CONFIG_BOOL_VALUE=y (or m)
  CONFIG_STR_VALUE="string value"
  CONFIG_INT_VALUE=123

Otherwise a Tcl source file is expected to contain 'define' commands. e.g.

  define CONFIG_BOOL_VALUE
  define CONFIG_STR_VALUE "string value"
  define CONFIG_INT_VALUE 123

Unless --nocare is specified, the file must exist.

The symbols contained in the file are defined, and the file is marked
as a project dependency. This means that if the file changes, it is re-read.
It is possibly for the build to create/re-create this file, in which case the
parsing phase will be restarted.
} {
	show-this-rule

	getopt {--nocare --config filename} args

	# XXX: Should we allow loading an out-of-tree file?

	if {[is-target? $filename]} {
		set f [file-build $filename]
		dputs m "Load: $filename is a target => $f"
	} elseif {[file exists $filename]} {
		dputs m "Load: $filename is source"
		set f $filename
		lappend result $f
	} elseif {![is-cleaning?] && !$nocare} {
		build-fatal-error [warning-location "Error: Load $filename does not exist and is not a target"]
		tmake-exit 1
	}

	if {[info exists f] && [file exists $f]} {
		if {$config} {
			dputs m "load-config-file $f"
			load-config-file $f
		} else {
			dputs m "source $f"
			source $f
		}
		# If we find the file, we now care about it
		set nocare 0
	}
	add-project-file $filename $nocare
}

rule UseSystemLibs {args} {
UseSystemLibs ...

Adds system libraries to be used when linking subsequent Executables, Shared Libraries and Shared Objects
via the $SYSLIBS variable.
Typical usage is:

  UseSystemLibs -ldl -lm
} {
	define-append SYSLIBS {*}$args
}

rule PublishIncludes {args} {
PublishIncludes ?--keepdir? name ...

Shorthand for:

	Publish ?--keepdir? include name ...
} {
	getopt {--keepdir args} args

	if {$keepdir} {
		Publish --keepdir include {*}$args
	} else {
		Publish include {*}$args
	}
}

rule PrecompiledHeader {header} {
PrecompiledHeader headerfile.h

Arranges for the given header file to be precompiled and included
when compiling subsequent C/C++ sources.
} {
	show-this-rule

	set local [make-local $header]

	# Build the precompiled header
	ObjectRule.c $local.gch $local
	Clean $local.gch
	# Need to publish both of these to the same directory
	PublishIncludes $header $header.gch

	# Now add this as an included for for subsequent compilation
	# Should we be using -include $header or -include-pch?
	# Is the latter only a clang thing?
	CFlags -include $header
	#CFlags -include-pch [publish-path include]/$header.gch

	# And we need to make sources depend on this too
	define PRECOMPILED_HEADER [publish-dir include]/$header.gch
}

rule Test {args} {
Test --interp=<interp> --errok --chdir --quiet --stdout=<stdout.exp.file> --stderr=<stderr.exp.file> command args

Runs the test command
If --stdout and/or --stderr is specified, the actual output is checked.
If it doesn't match, the test fails.
} {
	show-this-rule

	getopt {--interp: --errok --chdir --quiet --stdout: --stderr: command args} args
	set testid [get-test-id]
	set depends {}
	set localcommand [make-local $command]

	set opts {}
	set deps {}
	set vars {}

	if {$chdir} {
		lappend opts -chdir
	}
	if {$errok} {
		lappend vars errok 1
	}

	# If there is an interpreter, find it
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir -optional 1] dep filename

		# In this case, the command is a script - find it
		lassign [find-project-bin $command -chdir $chdir -optional 0] cmddep scriptpath
		set testcommand [list $filename $scriptpath {*}$args]

		if {$dep ne ""} {
			lappend deps $dep
		}
	} else {
		# Find the local or published command and add it to the command and deps
		lassign [find-project-bin $command -chdir $chdir -optional 0] dep filename

		set testcommand [list $filename {*}$args]
		lappend deps $dep
	}

	lappend vars testcommand $testcommand

	if {!$quiet} {
		lappend opts -msg [list note Test $testcommand]
	}

	# set up srcpath to allow the test command/script to find resources
	if {$chdir} {
		# We are in objdir/... and we need to find [local-dir] from src
		set srcdir [file-src-relative [local-dir]]
	} else {
		set srcdir [local-dir]
		lappend vars SRCDIR [local-dir]
	}
	lappend vars SRCDIR $srcdir

	foreach i {stdout stderr} {
		if {[info exists $i]} {
			set path [set $i]
			lappend deps [make-local $path]
			lappend vars $i [file-join $srcdir $path]
		}
	}

	lappend vars publishlib [file-join [get-define TOPBUILDDIR] [publish-dir lib]]

	target [make-local $testid] -phony -depends $deps -vars {*}$vars {*}$opts -do {
		setup-test-env $publishlib $LD_LIBRARY_PATH
		run-test-command $testcommand
	} -getvars LD_LIBRARY_PATH -slow

	Phony test [make-local $testid]

	return $testid
}

rule CopyFile {dest source} {
CopyFile dest source

Copies the source file to the destination file
} {
	show-this-rule
	target [make-local $dest] -inputs [make-local $source] -msg [list note Copy $dest] -do {
		file delete $target
		file copy $inputs $target
	}
	Clean $dest
}

# @install-file ?--strip=$STRIPCMD? ?--bin? target source
#
# Helper for installing files
# Copies the file from $source to $target, then performs zero or more actions
# depending upon the flags (which is a list)
#
# --bin                 - make the target executable with chmodx-file
# --strip=$STRIPCMD     - If specified, strips the target with the given strip command
#
rule InstallFile {args} {
InstallFile ?--strip|--striplib? ?--bin? dest source

Installs the given source file to the destination (file) relative to $DESTDIR
The following options are supported:

	--bin      - make the target executable
	--strip    - strips the target with $STRIP $STRIPFLAGS
	--striplib - strips the target with $STRIP $STRIPLIBFLAGS

Adds the rule to the global 'install' target and adds the file the list of files
to be uninstalled with 'uninstall'
} {
	show-this-rule

	getopt {--strip --striplib --bin dest src} args

	#puts "InstallFile $dest $src"

	set destfile [get-define DESTDIR]$dest
	if {$strip && $striplib} {
		build-error "Only one of --strip and --striplib can be specified"
	}
	set installopts {}
	if {$strip} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPFLAGS]"
	} elseif {$striplib} {
		lappend installopts "--strip=[get-define STRIP] [get-define STRIPLIBFLAGS]"
	}
	if {$bin} {
		lappend installopts --bin
	}

	if {[is-target? $destfile]} {
		user-notice purple [warning-location "Warning: Duplicate install rule for $dest at [make-source-location $destfile]"]
		return
	}
	# Note that we pass variable $dest purely so we can show a nice path in the message
	target $destfile -nocache -inputs $src -vars dest $dest installopts $installopts -msg {note Install $dest} -do {
		install-file {*}$installopts $target $inputs
	}
	target install -depends $destfile

	# This file also needs to be uninstalled
	add-clean uninstall $destfile

	return $destfile
}

rule Install {args} {
Install ?--bin? ?--strip|--striplib? ?--keepdir? destdir file-spec...

A convenience wrapper around InstallFile to allow multiple files to be installed at once.
See InstallFile for more details.

The following arguments are supported:
  --bin               Adds 'bin' to the InstallFile flags
  --strip             Adds 'strip' to the InstallFile flags
  --keepdir           Passes --keepdir to InstallFile
  destdir             Installs to the given directory
  file-spec...        A file specification for files to be installed. See 'File specifications' above.
} {
	show-this-rule

	getopt {--bin --strip --striplib --keepdir destdir args} args
	set args [join $args]
	set opts {}
	if {$bin} {
		lappend opts --bin
	}
	if {$strip} {
		lappend opts --strip
	}
	if {$striplib} {
		lappend opts --striplib
	}

	set srcs {}
	foreach {dest src} [expand-filespec $destdir $args $keepdir] {
		lappend srcs $src
		InstallFile {*}$opts $dest $src
	}
	return $srcs
}

rule Clean {args} {
Clean ?--source? target ...

Adds the given targets to the list of files to be removed on 'tmake clean'
} {
	# DistClean also cleans these files
	DistClean {*}$args

	getopt {--src --source args} args

	set args [join $args]

	if {$source || $src} {
		add-src-clean [make-local clean] $args
	} else {
		add-clean [make-local clean] [make-local {*}$args]
	}
}

rule DistClean {args} {
DistClean ?--source? target ...

Adds the given targets to the list of files to be removed on 'tmake distclean'
If --source is specified, the target is relative to the source directory
rather than the build directory.
} {
	getopt {--source --src args} args

	set args [join $args]

	if {$src} {
		user-notice purple [warning-location "Warning: DistClean --src is deprecated, use --source instead"]
	}
	if {$source || $src} {
		add-src-clean [make-local distclean] $args
	} else {
		add-clean [make-local distclean] [make-local {*}$args]
	}
}

rule Generate {args} {
Generate ?--interp=<interp>? ?--chdir? target generator inputs rules target-args...

A general purpose rule to create a target via a generator (program or script).
The arguments are as follows:
  --interp   Optional built or external program required to run the generator. Available as $interp
  --chdir    If specified, the generator runs from the local directory
  target     The target to generator. May be a list of one or more targets. Available as $target
  generator  The generator program or script. May be a local built target, a published built target
             (in which case the <bin> prefix is used), or empty for none. Available as $script
  inputs     Local files that are inputs to the generator. Available as $inputs
  rules      A -do script that generates the target
  target-args  Additional arguments to 'target'

The following is an example of a local, built generator.

  Executable mkindex mkindex.c
  Generate page_index.h mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex' were created in another directory and published with 'Executable --publish'
or 'PublishBin', we would use the following:

  Generate page_index.h <bin>mkindex *.c {
    run $script $inputs >$target
  }

If 'mkindex.rb' were a script that used a locally built version of 'ruby' to run, we would use:

  Generate --interp=<bin>ruby page_index.h mkindex.rb *.c {
    run $interp $script -o $target $inputs
  }

} {
	# XXX: Would be nice if script and inputs were optional
	getopt {--interp: --chdir target script inputs rules args} args

	set localtarget [make-local {*}$target]

	set opts {}
	if {[info exists interp]} {
		lassign [find-project-bin $interp -chdir $chdir] dep filename
		lappend opts -depends $dep -vars interp $filename
	}
	if {$script ne ""} {
		lassign [find-project-bin $script -chdir $chdir] dep filename
		lappend opts -depends $dep -vars script $filename
	}
	if {$chdir} {
		lappend args -chdir
	}
	target $localtarget -inputs {*}[make-local {*}$inputs] {*}$opts -do $rules -msg {note Generate $targetname} {*}$args
	Clean $target
}

rule Depends {target args} {
Depends target target-args...

Creates a local target with the given additional target arguments.
} {
	target [make-local {*}$target] -depends {*}$args
}

rule Phony {target args} {
Phony target target-args...

Creates a Phony, local target with the given additional target arguments.
} {
	show-this-rule
	target [make-local {*}$target] -phony -depends {*}$args
}

proc LocalMakefile {name} {
	user-notice purple [warning-location "Warning: LocalMakefile is deprecated and ignored"]
}

rule DefaultOptions {rule args} {
DefaultOptions <command> options...

e.g. DefaultOptions Executable --strip
e.g. DefaultOptions SharedObject --strip=dynamic

Allows default options to be supplied for commands.
Note that currently only Executable, SharedObject and SharedLib are supported.
} {
	set-default-opts $rule $args
}

rule DefaultTarget {name} {
DefaultTarget target

Sets the default (local) target.
i.e. when tmake is invoked with no options.
The default is 'all'
} {
	show-this-rule
	set-default-target $name
}

rule HostLibs {args} {
HostLibs ...

Like UseSystemLibs, but for host builds with HostExecutable.
Adds the given arguments to HOST_SYSLIBS
} {
	define-append HOST_SYSLIBS {*}$args
}

rule HostExecutable {target args} {
HostExecutable target sources ...

A very simple version of Executable for building host (as opposed to target) applications.

Imported variables: HOST_CFLAGS, HOST_SYSLIBS (from HostLibs)
Used variables: CC_FOR_BUILD (default to cc)

Note: HostExecutable and HostLibs are stopgaps until separate build contexts are fully support
} {
	set localtarget [make-local $target]

	set localtargetexe $localtarget[get-define HOST_EXEEXT]
	set targetexe $target[get-define HOST_EXEEXT]

	target $localtargetexe -inputs {*}[make-local {*}$args] -msg {note HostExecutable $targetname} -getvars HOST_CFLAGS HOST_SYSLIBS -do {
		run $CC_FOR_BUILD $HOST_CFLAGS -o $target $inputs $HOST_SYSLIBS
	} -dyndep {
		header-scan-regexp-recursive $local "" $CHDRPATTERN
	} {*}[target-alias $target $targetexe]

	PublishBin $target
	Clean $targetexe

	return $localtarget
}

rule ExternalBuild {user_spec} {
ExternalBuild build-specification

Simplifies integration of a project with it's own build system.

Supports configure, build, clean and distclean targets.

build-specification is a dictionary containing some or all of the following entries:

  configure          - Name of the configure script, or "" if none. [default: configure]
  configure_opts     - Additional options to configure [default: none]
  configure_targets  - Targets generated by 'configure' [default: none]
  build              - Command to build [default: make]
  build_opts         - Additional options to build [default: none]
  build_targets      - Non-library targets generated by 'make' [default: none]
  lib_targets        - Archive library targets generated by 'make', as a list of: libname filename ... [default: none]
  clean              - Command to clean [default: make clean]
  distclean          - Command to distclean [default: make distclean]

Notes:
- The build is done "out of tree", and configure must accept --host and --build
- CONFIGURE_HOST and CONFIGURE_BUILD must be defined
- Currently shared libaries are not supported
- Header files, binaries etc. should be published and installed as normal
- The only dependencies for the external project are:
  - The completion of the configure and build commands
  - The existence of the configure and build targets
  - The commands used to configure and build
- configure_opts and build_opts are expanded at build time, so they may include, e.g. [get-define]
} {
	# Set up the default behaviour
	set spec {
		configure {configure}
		configure_opts {}
		build {make}
		build_opts {}
		clean {make clean}
		distclean {make distclean}
		configure_targets {}
		build_targets {}
		lib_targets {}
	}
	foreach {k v} $user_spec {
		if {$k eq "#"} {
			continue
		}
		if {![exists spec($k)]} {
			user-error "ExternalBuild doesn't recognise $k=$v"
		}
		set spec($k) $v
	}

	# --- configure ----
	if {$spec(configure) ne ""} {
		lassign [find-project-bin $spec(configure) -chdir 1] script_dep script_filename
		set configure_targets [list .configure {*}$spec(configure_targets)]

		set configure_opts [list --host=[get-define CONFIGURE_HOST] --build=[get-define CONFIGURE_BUILD] {*}[subst $spec(configure_opts)]]

		Depends $configure_targets [make-local $spec(configure)] -msg [list note External [make-local configure]] -do {
			run $script_filename $configure_opts
			writefile .configure "done"
		} -vars script_filename $script_filename configure_opts $configure_opts -chdir

		# Assume .distclean can only run if configured
		Phony .distclean -do {
			if {[file exists .configure]} {
				run $cmd
			}
		} -vars cmd $spec(distclean) -chdir
		Depends distclean [make-local .distclean]
		DistClean .configure
	} else {
		# Create a dummy configure step
		Depends .configure -do {
			writefile $target "done"
		}
		DistClean .configure
	}

	# --- build ----
	set build_targets [list .build {*}$spec(build_targets)]
	foreach {basename lib} $spec(lib_targets) {
		lappend build_targets $lib
	}
	set build_opts [subst $spec(build_opts)]

	Depends $build_targets [make-local .configure] -msg [list note External [make-local build]] -do {
		run $cmd $build_opts
		writefile .build "done"
	} -vars cmd $spec(build) build_opts $build_opts -chdir

	# Assume .clean can only run if configured
	Phony .clean -do {
		if {[file exists .configure]} {
			run $cmd
		}
	} -vars cmd $spec(clean) -chdir
	Depends clean [make-local .clean]
	Clean .built

	# --- libs ----
	foreach {basename lib} $spec(lib_targets) {
		set libname [file tail $lib]
		set libalias <lib>$basename
		set liblocal [make-local $lib]

		Phony libs $liblocal

		# Can't use publish-lib here because the lib may be in a subdir
		hard-link [publish-prefix lib]$libname $liblocal -msg {note Publish $targetname} -alias $libalias
		#publish-lib $libname $libalias
	}

	# XXX support for shared libs ...
}


# ==================================================================
# Built-in targets
# ==================================================================

clean-target clean Clean
clean-target distclean DistClean
clean-target uninstall Uninstall

Phony all
Phony libs
Phony install all
Phony test

Depends clean clean-orphans
Depends distclean clean-orphans

DistClean .makecache

# Invoked manually
Phony clean-orphans -do {
	do-delete-orphans [get-orphan-targets]
	# Now remove the trash
	if {[file exists .trash]} {
		note Clean .trash
		file delete -force .trash
	}
}

# @delete-orphan-files files ...
#
# This callback is invoked to delete orphans
# This version replaces the builtin version.
# Instead of deleting files immediately, orphans are moved into
# the .trash directory. This directory is only removed via the
# 'clean', 'distclean' or 'clean-orphans' targets.
proc delete-orphan-files {args} {
	file mkdir .trash
	foreach file $args {
		if {[file exists $file]} {
			set trashfile .trash/[string map {/ _} $file]
			# Can't simple use file rename -force in case the files hard hard links
			file delete $trashfile
			file rename $file $trashfile
		}
	}
}
